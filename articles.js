module.exports = [{"link":"2015/05/05/after-respondent","title":"答辩","published":"2015-05-05T08:30:39.000Z","tags":["Diary"],"html":"<p>忙活了这么久，答辩在上周终于结束了。\n这次的毕业设计乱搞Android+Java Web+WinPhone，特别是WinPhone客户端简直浪费了我超多时间。根本就不想去碰C#和装VisualStudio，好在最后还是硬着头皮把功能实现了。\n答辩完后几天，便是整理论文，修整格式，最后把精装版打印出来提交完事。</p>\n<p>于是大学四年貌似最后要修的学分也都弄完了。</p>\n<p>整理毕业设计中做过的工作</p>\n<p><img src=\"\" alt=\"graduation-note\">\n<img src=\"\" alt=\"graduation-note\"></p>\n<p>真是有种把大学四年学过的东西糅合在一起 乱合体的感觉，也算不上是精妙の结合，因为没有优雅的UI，也没有复杂的算法。\n这段时间什么都没有更新，其实有做很多笔记，然而那段时间每天晚上下班回来想到要搞毕设，就没有整理好。</p>\n<p>值得吐槽的是，学院答辩实在太水--跟我同一批次答辩的所谓学生：\n有搞Unity3D之MMORPG的：什么是Unity3D的毕业设计呢，就是完全套用现有的U3D MMORPG游戏引擎模板，然后自己下载网上的模型套了上去，再改了下物品的命名。6个人就改两个地方，一天的工作量分开6份还不如弄懂一个简单的算法。\n有搞什么&quot;XX乐园系统的项目维护与扩张&quot;，就是将一个写好的Web系统，啥也没加，借了源码贴在论文上。\n最搞笑的是那种HelloWorld都不会写但是题目居然是大数据挖掘算法论文的，原来不用懂基本知识就可以写出Map-Reduce 之流的算法论文。</p>\n<p>这么水都能通过，让我觉得我花了这么多时间在这上面--然而并没有什么卵用。</p>\n<hr>\n<p>答辩完的这几天啊，发现我的VPS感觉实在是出现了有些卡顿的现象。\n正寻思解决办法，看到了使用Node.JS框架的静态博客Hexo...支持Markdown语法，可迁移到Github Pages上...\n于是捣鼓环境安装试用又搞了几天，发现好多东西需要准备。还是简单了解Node.JS 再作准备吧</p>\n"},{"link":"2014/06/15/aliyun-server-management","title":"云服务器实战：aliyun服务器环境配置与管理","published":"2014-06-15T03:42:30.000Z","tags":["VPS","Linux"],"html":"<p>狠下心租了一个月aliyun的服务器作服务器端实战练习，55块钱的最低配置。</p>\n<p>服务器系统：CentOS 6.4</p>\n<p>在购买了服务器之后\n你的注册邮箱会收到一封邮件</p>\n<p>上面含有你购买的服务器的一些细节，如图</p>\n<p><img src=\"\" alt=\"\"><span style=\"color: black; font-family: Arial; font-size: 9pt;\"></p>\n<p>需要用到的如下</p>\n<p>服务器IP：ServerIP（用ServerIP表示我的服务器地址\n就不透露了）</p>\n<p>默认用户名：root（默认的Linux用户名都是root）</p>\n<p>初始密码：rootpwd（用rootpwd表示我的root密码）</p>\n<p>那么，如何对已经购买的服务器进行操作，达到能运行网站应用的地步呢？</p>\n<ol>\n<li>首先要使用一个远程连接服务器，用命令行管理服务器的客户端软件。</li>\n</ol>\n<p>我使用的是windows连接\n服务器端的linux</p>\n<p>所以推荐使用SecureCRT这款软件来连接服务器</p>\n<p>百度搜索 SecureCRT 64位破解版\n自行下载即可。</p>\n<p>界面如下</p>\n<p><img src=\"\" alt=\"\"><span style=\"color: black; font-family: Arial; font-size: 9pt;\"></p>\n<ol>\n<li>连接服务器</li>\n</ol>\n<p>在SecureCRT界面\n按下Alt+Q或者\n点击左上角的快速连接</p>\n<p><img src=\"\" alt=\"\"><span style=\"color: black; font-family: Arial; font-size: 9pt;\"></p>\n<p>在主机名处填入自己的ip地址，就是ServerIP</p>\n<p>用户名填root</p>\n<p>回车连接之后，他会要求你输入密码，就是个人的初始密码rootpwd</p>\n<p>如果一切完好\n此时就会连接成功，进入服务器的终端界面，就是Linux下的终端。</p>\n<p>使用方法与Linux终端完全一致，只不过没有了图形界面，环境配置可能会遇到点问题。</p>\n<p>所以我们先来解决\n用这个SecureCRT上传文件到服务器端的方法吧。</p>\n<p>平时上传文件呢，大多数都是用FTP来传输，这样Linux客户端要安装FTP协议，我们这边也要安装多一个flashFXP客户端什么的，比较繁琐，直接用SecureCRT支持的上传</p>\n<ol>\n<li>首先，我们在服务器的终端安装sz/rz服务</li>\n</ol>\n<p>终端输入</p>\n<pre><code>yum install lrzsz\n</code></pre><p>安装完成。</p>\n<ol>\n<li>设置 windows本地的\n上传/下载文件夹。</li>\n</ol>\n<p>在SecureCRT 上方菜单中  选项--会话选项--终端--X/Y/Z modem 修改</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>比如说要上传一个JDK （因为JDK 用yum 来安装的话只能装openjdk貌似..）我们先把下载好的JDK-8-linux-x64.rpm放在\n自己的G:下载\n目录下</p>\n<p>在服务器端\n进入到要粘贴的文件夹，比如我在/home 下新建了一个叫做JDK的文件夹，我们cd进去</p>\n<p>此时，点击传输\n如图</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>点击Zmoderm上传列表，选择放在G:下载\n下的要上传的文件\n点击开始上传</p>\n<p>然后服务器端就自动开始上传进程了。</p>\n<p>大概的操作方式就是这些，如果是配置JSP开发环境的话\n可以参考之前在本地虚拟机安装Ubuntu的配置方式。</p>\n"},{"link":"2014/06/15/android-software-fqrouter2","title":"Android软件推荐:fqrouter:真正打开国外GooglePlay应用商店","published":"2014-06-15T04:39:51.000Z","tags":["Android","Google"],"html":"<h2 id=\"background\">Background</h2>\n<p>安装了GooglePlay应用商店的童鞋，是不是觉得平时在用的GooglePlay充斥着各种相对垃圾的软件，感受不到整个GooglePlay应用商店的优势，如果上面排行榜总是推荐那些国内的应用，亦或是什么约炮宝典，XX宝典的垃圾广告软件，那跟国内那些普通的安卓市场一类有何区别？</p>\n<p>其实国外的GooglePlay非常实用，这才体现了这个应用商店的优势：</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>推荐一款能上外国GooglePlay的软件：fqrouter 当前版本2.8.0, 可以通过打开GooglePlay 搜索获得下载。</p>\n<p>下载安装之后，打开运行，到配置页面，如图</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>打开Google市场，即可进入高端洋气的国外GooglePlay市场。</p>\n"},{"link":"2016/04/03/angular-dynamic-title-using-factory","title":"Angular单页应用动态切换页面标题","published":"2016-04-03T14:27:24.000Z","tags":["AngularJS","JavaScript"],"html":"<h2 id=\"background\">Background</h2>\n<p>在运行angular单页应用的时候,有时候需要能够动态的根据当前的view来切换当前的标题.\nJavaScript原生语法中,其实是可以直接利用<code>document.title=&#39;xxx&#39;</code>来实现.</p>\n<p>但是根据Kary Gor的建议,所有原生的DOM操作其实都建议在directive中进行.\n所以参考StackOverFlow上的一个做法,实现动态切换当前页标题.</p>\n<h2 id=\"solution\">Solution</h2>\n<p>总体的实现步骤分为以下几步:</p>\n<ol>\n<li>建立一个factory用于控制当前页标题</li>\n<li>建立一个controller,专门用于控制最上级html的header部分的操作</li>\n<li>在其他子controller,调用更变页面标题的方法</li>\n</ol>\n<h3 id=\"-pageservice\">创建pageService</h3>\n<pre><code class=\"undefinedjs\">/** Services for html page such as Header */\n\nvar angular = require(&#39;angular&#39;);\n//noinspection JSCheckFunctionSignatures\nvar $injector = angular.injector([&#39;ng&#39;]);\nvar $log = $injector.get(&#39;$log&#39;);\nvar _ = require(&#39;lodash&#39;);\n\nvar pageService = function pageService(){\n  var svc = this;\n  svc.defaultTitle = &#39;Aquariuslt Home&#39;;\n  svc.title = svc.defaultTitle;\n\n  function getTitle(){\n    return svc.title;\n  }\n\n  function setTitle(newTitle){\n    if(!_.isEmpty(newTitle)){\n      svc.title = newTitle + &#39; - &#39; + svc.defaultTitle;\n    }\n    else{\n      svc.title = svc.defaultTitle;\n    }\n    $log.info(&#39;set new title:&#39;,svc.title);\n  }\n\n  return{\n    getTitle:getTitle,\n    setTitle:setTitle\n  };\n};\n\nmodule.exports = pageService;\n</code></pre>\n<h3 id=\"-pagecontroller\">创建pageController</h3>\n<p>page-controller.js:</p>\n<pre><code class=\"undefinedjs\">var pageService = require(&#39;../services/page-service&#39;)();\n\nmodule.exports = function pageController(){\n  var page = this;\n  page.service = pageService;\n};\n</code></pre>\n<p>index.html:</p>\n<p>在html标签直接添加一个controller作为scope.\n一开始是直接在<code>&lt;title&gt;&lt;/title&gt;</code>标签内直接使用<code>page.service.getTitle()</code>的.\n但是发现在angular还没有加载完成的时候,默认的标题 会显示成这个表达式本身的字符串,非常丑陋.\n于是用了<code>ng-bind</code>去绑定.在angular数据绑定还没生效的时候,使用原来的默认标题.</p>\n<pre><code class=\"undefinedhtml\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; ng-app=&quot;home&quot; ng-controller=&quot;pageController as page&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n  &lt;link rel=&quot;shortcut icon&quot; href=&quot;http://blog.aquariuslt.com/images/avator.png&quot;&gt;\n  &lt;base href=&quot;#&quot;&gt;\n  &lt;title ng-bind=&quot;page.service.getTitle()&quot;&gt;Aquariuslt Home&lt;/title&gt;\n  &lt;!-- Load CSS Bundles Here --&gt;\n  &lt;!-- CSS --&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;header ng-include=&quot;&#39;app/common/views/header.html&#39;&quot;&gt;&lt;/header&gt;\n  &lt;ui-view&gt;&lt;/ui-view&gt;\n  &lt;!-- Load JavaScript Bundles Here --&gt;\n  &lt;!-- JS --&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3 id=\"-controller-\">其他子controller的调用方法</h3>\n<p>比如我有一个tag页面:\n<a href=\"http://aquariuslt.com/#/tag/Java\">http://aquariuslt.com/#/tag/Java</a></p>\n<p>我需要将当前页面的标题前缀加上<code>Tag Contains Java</code>\n则需要在这个页面的controller中这样调用:</p>\n<pre><code class=\"undefinedjs\">var pageService = require(&#39;../../common/services/page-service&#39;)();\nvar articleService = require(&#39;../services/article-service&#39;)();\n\nmodule.exports = function tagController($stateParams,$interval){\n  var vm = this;\n\n  vm.atomList = [\n    &quot;http://blog.aquariuslt.com/atom&quot;,\n    &quot;http://debug.aquariuslt.com/atom&quot;,\n    &quot;http://game.aquariuslt.com/atom&quot;\n  ];\n  vm.tagName = $stateParams.tagName;\n  vm.indeterminateValue = 0;\n  vm.showProgressBar = false;\n  vm.tagDetailList = [];\n\n  init();\n\n  function init(){\n    initTitle();\n    loadTagDetail();\n  }\n\n  function initTitle(){\n    pageService.setTitle(&#39;Tags Contains &#39;+vm.tagName);\n  }\n\n  function loadTagDetail(){\n    startInterval();\n    articleService.loadArticleSummaryList(vm.atomList,function(error,summaryList){\n      vm.tagDetailList = articleService.filterArticleListByTagName(summaryList,vm.tagName);\n      stopInterval();\n    });\n  }\n\n  function updateProgressBar(){\n    if(vm.showProgressBar){\n      vm.indeterminateValue += 1;\n      if (vm.indeterminateValue &gt; 100) {\n        vm.indeterminateValue = 0;\n      }\n    }\n  }\n\n  function startInterval(){\n    vm.showProgressBar = true;\n    $interval(updateProgressBar, 100, 0, true);\n  }\n\n  function stopInterval(){\n    vm.showProgressBar = false;\n    $interval.cancel(updateProgressBar);\n  }\n\n};\n</code></pre>\n"},{"link":"2016/03/20/angular-material-md-button-using-lowercase","title":"Angular Material md-button 不全部大写","published":"2016-03-20T07:33:50.000Z","tags":["JavaScript","CSS","AngularJS"],"html":"<h2 id=\"background\">BackGround</h2>\n<p>刚刚接触<code>Angular-Material</code>,发现其<code>md-button</code>指令是内文本全大写</p>\n<h2 id=\"solution\">Solution</h2>\n<p>在CSS里面添加</p>\n<pre><code class=\"undefinedcss\">/** For md-button lowercase using lowercase */\n.md-button {\n  text-transform: capitalize !important;\n}\n</code></pre>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1j2w_LVXXXXXWXpXXXXXXXXXX.png\" alt=\"After Update CSS\"></p>\n"},{"link":"2016/04/30/angular-ui-performance-tuning-experience","title":"Angular常规性能优化阶段总结","published":"2016-04-30T07:33:50.000Z","tags":["AngularJS","JavaScript"],"html":"<h2 id=\"background\">Background</h2>\n<p>还是上一篇<a href=\"http://aquariuslt.com/#/post/2016/04/26/what-i-have-done-these-days\">文章</a>里面讲到,\n最近在为项目进行性能优化的时候,有总结到一些经验.<br>现在梳理一遍,方便以后排查问题.  </p>\n<h2 id=\"references\">References</h2>\n<p>在进行Angular页面的性能测试以及学习优化手段之前,查阅了挺多资料.<br>其中非常推荐一些前端大牛的博客文章,不仅在技术方面深有造诣,而且表达能力非常清晰,能够条理清晰地将经验传授给大家.  </p>\n<p>下面是一些推荐阅读的博客,给我提供了很多帮助,加深了对Angular的认识.  </p>\n<ul>\n<li><a href=\"https://github.com/xufei/blog/\">xufei blog</a>\n...准备贴下一个地址的时候,居然发现这个知乎的地址居然也是xufei大大的回答.\n恩.应该提供最有价值帮助的就是他了.</li>\n</ul>\n<h2 id=\"solutions\">Solutions</h2>\n<h3 id=\"plugins-angularjs-batarang\">Plugins:AngularJS Batarang</h3>\n<p>利用Angular官方开发的Chrome插件<code>AngularJS Batarang</code>来监控页面性能.<br><a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\">Angular Batarang</a><br><img src=\"https://img.alicdn.com/tfscom/TB1OmxkKXXXXXXIXXXXXXXXXXXX.png\" alt=\"运行截图\">  </p>\n<p>通过<code>Angular Batarang</code>,我们可以轻易的统计在页面的<code>watcher</code>数量,<code>$scope</code>中变量的数量.\n还有平均一段时间内<code>angular</code>执行<code>$digest</code>的数量.</p>\n<p>对于代码不熟悉的项目前端,查找分析性能瓶颈的时候,可以通过通过该插件进行二分对于,快速定位出瓶颈处.\n当然,如果在对angular比较熟悉,在开发的过程中也遵循了常见的性能优化约定,该插件的监控作用就不大.\n最后还是只能通过其他手段细化性能瓶颈定位粒度.</p>\n<p>经过本人测试,对于大部分使用Angular的页面都支持良好.(可惜不支持CommonJS打包成的我的主站的分析)</p>\n<h3 id=\"once-binding\">Once Binding</h3>\n<p>在常见的CRUD系统中,我们经常会遇到很多数据展示的区域,但是这些数据一旦渲染好,一般不需要强刷新.\n比如页面标题,菜单选项等不需要实时更新的情况.所以这时候可以通过<code>Once Binding</code>,即一次绑定,渲染一次即可,不必监控该表达式.</p>\n<p>之前遇到的情况是,我们的页面header会有一个通知栏,展开会通知那些已经显示的列表.<br>单条通知样子类似于微博的这种:<br>![通知栏(<a href=\"https://img.alicdn.com/tfscom/TB17PpkKXXXXXX8XXXXXXXXXXXX.png\">https://img.alicdn.com/tfscom/TB17PpkKXXXXXX8XXXXXXXXXXXX.png</a>)\n在没优化之前,通知部分的伪代码如下:</p>\n<pre><code class=\"undefinedhtml\">&lt;div class=&quot;notification&quot;&gt;\n  &lt;ul&gt;\n    &lt;li ng-repeat=&quot;notification in vm.displayNotifications&quot;&gt;\n      &lt;div href=&quot;{{notification.targetUrl}}&quot;&gt;\n        &lt;p&gt;{{notifications.title}}&lt;/p&gt;\n        &lt;p&gt;{{notifications.summary}}&lt;/p&gt;\n        &lt;p&gt;{{notifications.time}}&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n<p>经过一轮生产环境数据统计,某部分用户的未读通知范围会在200 - 7W 条.<br>哈哈看到就尿了,如果这么算的话,7W条的那个用户页面将会有至少 7W*4 = 28W的watcher在监听他们的变化.<br>且不论数据为什么需要全部渲染出来,如果将代码修改成Once Binding,则页面的长期watcher数量将会减少28W个.</p>\n<p>特别是对于使用了<code>ng-repeat</code>的元素,一定要考虑将</p>\n<p>使用一次绑定表达式之后如下</p>\n<pre><code class=\"undefinedhtml\">&lt;div class=&quot;notification&quot;&gt;\n  &lt;ul&gt;\n    &lt;li ng-repeat=&quot;notification in vm.displayNotifications&quot;&gt;\n      &lt;div href=&quot;{{::notification.targetUrl}}&quot;&gt;\n        &lt;p&gt;{{::notifications.title}}&lt;/p&gt;\n        &lt;p&gt;{{::notifications.summary}}&lt;/p&gt;\n        &lt;p&gt;{{::notifications.time}}&lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id=\"use-variable-instead-function-expression\">Use variable instead function expression</h3>\n<p>之前遇到一个需求,在业务逻辑上需要显示一个模型,这个模型大概是下面这样的:</p>\n<pre><code class=\"undefinedjson\">{\n  &quot;businessKeys&quot;:[\n    {\n      &quot;type&quot;:&quot;a&quot;,\n      &quot;value&quot;:&quot;aValue&quot;\n    },\n    {\n      &quot;type&quot;:&quot;b&quot;,\n      &quot;value&quot;:&quot;bValue&quot;\n    },\n    {\n      &quot;type&quot;:&quot;c&quot;,\n      &quot;value&quot;:&quot;cValue&quot;\n    },\n    {\n      &quot;type&quot;:&quot;c&quot;,\n      &quot;value&quot;:&quot;cValue&quot;\n    }\n  ],\n  &quot;otherInfo&quot;:&quot;otherInfo...&quot;\n}\n</code></pre>\n<p>在字段里面是有一个不定长的数组,数组里面实际上是一堆key-value形式的键值对.\n之所以不定长是因为里面有时候有些key是没有对应的值的.\n在UI上显示出来的时候,先前的做法就是绑定一个方法:</p>\n<pre><code>{{vm.getValueByBusinessKeysType(object,keyName)}}\n</code></pre><p>在页面上使用一个方法表达式而不是直接的变量表达式的时候,会导致方法执行多次.\n由于这个<code>getValueByBusinessKeysType</code>的方法,需要通过数组查找而不是直接一个map\n所以就会导致性能问题.</p>\n<p>目前的解决方案是:将数据在加载的时候经过扁平化处理,即将key直接以property的形式直接赋予Object.\n通过直接绑定property表达式来显示.\n这样也有效提高了一些性能</p>\n<h3 id=\"chain-filter\">Chain Filter</h3>\n<p>Angular的Filter性能一直不够好.\n在刚刚接触Angular的时候,阅读文档发现Filter的功能还挺好用的,特别是做一些关键字过滤表格数据,格式处理等方面的工作,<br>实在是太方便了,于是我们在为我们的table的header上每个column都添加了一个关键字过滤框,使用angular的filter做分页的工作.  </p>\n<p>由于我们的表格需要显示的业务数据比较多,column数大概在15-25左右.\n在每一个header的column上添加独立的关键字过滤框,大概就添加了20个.</p>\n<p>假设当前页面的总数据 会有有30条.\n用户喜欢在几个过滤框上输入一些相关的关键字信息过滤.(filterA,filterB)</p>\n<pre><code class=\"undefinedjs\">function filterA(dataArray,filterCriteria){\n  return filteredDataArrayByFilterCriteriaA;\n}\n\nfunction filterB(dataArray,filterCriteria){\n  return filteredDataArrayByFilterCriteriaB;\n}\n</code></pre>\n<p>当每一个过滤框都属于一个单独的filter去绑定的话,如果执行AB filter,将会按照下面的顺序执行</p>\n<blockquote>\n<p><code>dataArray</code> length:30\n<code>filteredDataArrayByFilterCriteriaA</code>  (至少两次filterA,此时length约20)<br><code>filteredDataArrayByFilterCriteriaB</code>  (至少两次filterB,此时length约5)</p>\n</blockquote>\n<p>如果我们在计算关键字过滤的时候使用的是遍历查询,以单次对单个元素对比的操作工作量为1.<br>那么在这两重filter的总计算工作量就会变成<code>30*2+20*2=100</code>次</p>\n<p>回到实际业务,通过在filter中添加log来记录filter循环运算的次数,惊讶的发现实际上filter的运算次数在25个column的情况下,<br>普遍一次过滤框的查询,会导致3K左右的运算次数,相当惊人.</p>\n<p>目前的解决方案是通过降低工程代码的可读性,将多个filter的功能合并成一个总的filter,在总的filter里面处理一连串的单个filter过滤过程.</p>\n<p>之前的代码可能是这样:</p>\n<pre><code class=\"undefinedhtml\">&lt;tr ng-repeat=&quot;singleData in vm.dataArray | filterA | filterB | filterC ..... | filterZ&quot;&gt;&lt;/tr&gt;\n</code></pre>\n<pre><code class=\"undefinedjs\">function filterA(dataArray){\n  //implement filterA\n}\n\nfunction filterB(dataArray){\n  //implement filterB\n}\n\nfunction filterC(dataArray){\n  //implement filterC\n}\n</code></pre>\n<p>合并之后看起来是这样</p>\n<pre><code class=\"undefinedhtml\">&lt;tr ng-repeat=&quot;singleData in vm.dataArray | combinedFilter&quot;\n</code></pre>\n<pre><code class=\"undefinedjs\">function combinedFilter(dataArrat){\n  //implement filterA\n  //implement filterB\n  //implement filterC\n}\n</code></pre>\n<h3 id=\"using-ng-model-option-delay-update\">Using ng-model-option delay update</h3>\n<p>因为使用了angular的filter功能做前端的关键词过滤,实际上所有的查询工作都是同步的.\n因为是同步,所以在前端javascript进行相对较密集的查询运算的时候,卡顿就会相当明显.\n如果对过滤输入框进行了<code>ng-model</code>的绑定,则当输入框的内容进行改变的时候,会立刻出发filter运算.\n通常用户输入的时候大部分可能是连续的单词或者子字符串的输入,在一次主观上的输入还没有结束的时候,因为输入框中文字的改变,<br>而频繁触发查询,实际上页面性能也会相当不好.\n这里有一个小tips就是为一些实时查询性不是很高的输入区域添加ng-model-options,增加angular检查数据update的时间间隔,\n相当于可以等用户把想要的搜索关键词输入完毕之后,再执行js代码的查询工作.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>本次结合了一些实际工作中使用angular遇到的性能问题的解决方案,当然也有遇到一些与原生js,socket.io相关的性能问题.\n由于tag不同,不混淆在一起说了.</p>\n"},{"link":"2015/10/25/apache-shiro-spring-integration","title":"Spring 整合 Apache Shiro 实现各等级的权限管理","published":"2015-10-25T08:41:17.000Z","tags":["Spring","Security","Shiro","Java"],"html":"<h2 id=\"background\">Background</h2>\n<p>前几个月在做一个常规的权限隔离功能的时候,恰好使用过Apache Shiro.\nApache Shiro 是一款Java的安全框架,通常用作Web应用的权限校验,身份验证.</p>\n<blockquote>\n<p>Apache Shiro is a powerful and easy-to-use Java security framework that performs authentication,\nauthorization, cryptography, and session management. With Shiro’s easy-to-understand API, you\ncan quickly and easily secure any application – from the smallest mobile applications to the\nlargest web and enterprise applications.</p>\n</blockquote>\n<p>在参考过 IBM 开发社区关于Shiro的博客 一篇文章 <a href=\"http://www.ibm.com/developerworks/cn/java/j-lo-shiro/\">在Web项目中应用Apache Shiro</a>\n与开涛博客的一个跟我学Shiro系列文章 <a href=\"http://jinnianshilongnian.iteye.com/blog/2024723\">开涛博客-跟我学Shiro</a></p>\n<blockquote>\n<p>不得不说的是IBM Developer社区的文章一向属于生动易懂.\n但是上面的这篇讲得并没有之前推荐的讲Spring-DataJPA的那篇文章那样浅显,\n于是才有了现在这份笔记</p>\n</blockquote>\n<h2 id=\"-\">权限控制</h2>\n<p>我所接触到的权限控制大概可以分成两个级别 URL和方法级别.</p>\n<p>以常见的论坛用户来举例.论坛用户简要的分成两种 管理员<code>Admin</code>,普通用户<code>Normal</code>.\n其中管理员能够进入用户管理,帖子管理的页面进行CRUD操作.\n普通用户则只能进行自己帖子的CRU操作,以及顶贴什么的.</p>\n<p>如果只进行URL级别的拦截,只需要在每一个URL的访问时 获取用户的角色是<code>Admin</code>还是<code>Normal</code>即可.</p>\n<p>如果是进行方法级别的拦截,则可能根据功能的设计衍生出很多设计方案(一眼就能想到的大概是树状,平行等).\n但是由于跟数据库的设计密切相关,所以这个级别不细讲.\n言归正传(不知道是不是看light大大博客看多了,语气有点奇怪),下面结合上面的论坛用户的一个场景进行逻辑与代码的讲解</p>\n<h3 id=\"url-\">URL级别的权限控制</h3>\n<h4 id=\"-\">业务场景假设</h4>\n<p>首先,我们假设有以下几种种URL</p>\n<pre><code>/user/create        //用户创建,Admin专属\n/post/create        //发帖 Admin,Normal共有\n/login              //登陆\n/logout             //注销\n</code></pre><h4 id=\"shiro-\">Shiro基本配置</h4>\n<h5 id=\"maven\">Maven</h5>\n<p><code>$&lt;shiro.version&gt;</code>请自行替换成当前的最新版本</p>\n<pre><code class=\"undefinedxml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;\n    &lt;version&gt;${shiro.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n    &lt;version&gt;${shiro.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;\n    &lt;version&gt;${shiro.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;\n    &lt;version&gt;${shiro.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h5 id=\"web-xml\">web.xml</h5>\n<p>为了实现与Spring同一个级别的URL拦截,需要将Shiro的Filter配置在Spring MVC的Dispatcher Servlet同一个级别</p>\n<pre><code class=\"undefinedxml\">&lt;filter&gt;\n    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre>\n<h5 id=\"spring-applicationcontext-xml\">Spring ApplicationContext.xml</h5>\n<p>在与Spring进行整合的时候,为了方便拼切配置,在Spring 里面导入另一份专用于Shiro的xml配置</p>\n<pre><code class=\"undefinedxml\">&lt;import resource=&quot;config/security/applicationContext-shiro-captcha.xml&quot;/&gt;\n</code></pre>\n<h5 id=\"spring-applicationcontext-shiro-captcha-xml\">Spring applicationContext-shiro-captcha.xml</h5>\n<p>先将整个 shiro的xml配置贴出来,接下来在逐一解说其内容</p>\n<pre><code class=\"undefinedxml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&quot;\n       default-lazy-init=&quot;true&quot;&gt;\n\n    &lt;description&gt;Shiro安全配置&lt;/description&gt;\n\n    &lt;!-- Shiro&#39;s main business-tier object for web-enabled applications --&gt;\n    &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;\n        &lt;property name=&quot;realm&quot; ref=&quot;shiroRealm&quot;/&gt;\n        &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 項目自定义的Realm --&gt;\n    &lt;bean id=&quot;shiroRealm&quot; class=&quot;com.quariuslt.service.security.BookingShiroRealm&quot;&gt;\n        &lt;property name=&quot;loginSessionService&quot; ref=&quot;loginSessionService&quot;/&gt;\n        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;\n        &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 用户授权信息Cache, 采用EhCache --&gt;\n    &lt;bean id=&quot;shiroEhcacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;\n        &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:config/security/ehcache-shiro.xml&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt;\n    &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;\n\n\n    &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt;\n        &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;captchaFilter&quot; class=&quot;com.quariuslt.service.security.CaptchaFormAuthenticationFilter&quot;/&gt;\n    &lt;bean id=&quot;adminPermissionFilter&quot; class=&quot;com.quariuslt.service.security.AdminPermissionFilter&quot;/&gt;\n    &lt;bean id=&quot;normalPermissionFilter&quot; class=&quot;com.quariuslt.service.security.NormalPermissionFilter&quot;/&gt;\n\n    &lt;!-- Shiro Filter --&gt;\n    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;\n        &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;\n        &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;\n        &lt;property name=&quot;successUrl&quot; value=&quot;/booking/search&quot;/&gt;\n        &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/&quot;/&gt;\n        &lt;property name=&quot;filters&quot;&gt;\n            &lt;map&gt;\n                &lt;entry key=&quot;authc&quot; value-ref=&quot;captchaFilter&quot;/&gt;\n                &lt;!--&lt;entry key=&quot;roles[admin]&quot; value-ref=&quot;captchaFilter&quot;/&gt;--&gt;\n                &lt;!--&lt;entry key=&quot;roles[normal]&quot; value-ref=&quot;captchaFilter&quot;/&gt;--&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n        &lt;property name=&quot;filterChainDefinitions&quot;&gt;\n            &lt;value&gt;\n                /=authc\n                /register = anon\n                /forgot =anon\n                /login = anon\n                /login/action* = anon\n                /logout = logout\n                /js/** = anon\n                /rest/**=anon\n                /image/**=anon\n                /jawr_loader.js=anon\n                /user/create=roles[admin]\n                /post/create/**=roles[normal|admin]\n                /** =authc\n            &lt;/value&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h4 id=\"-\">配置详解</h4>\n<p>首先要理解一件事情,就是Shiro的权限控制 源自于Web.xml的Filter,在Filter中获取目标URL的请求,解析以达到根据请求是否到达下一集Filter的作用.\n再要理解一件约定大于配置的问题,了解Shiro的一些默认配置解说.</p>\n<p>在贴出来的<code>shiro-captcha.xml</code>配置代码中:</p>\n<pre><code class=\"undefinedxml\">&lt;!-- Shiro Filter --&gt;\n&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;\n    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;\n    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;\n    &lt;property name=&quot;successUrl&quot; value=&quot;/booking/search&quot;/&gt;\n    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/&quot;/&gt;\n    &lt;property name=&quot;filters&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key=&quot;authc&quot; value-ref=&quot;captchaFilter&quot;/&gt;\n            &lt;!--&lt;entry key=&quot;roles[admin]&quot; value-ref=&quot;captchaFilter&quot;/&gt;--&gt;\n            &lt;!--&lt;entry key=&quot;roles[normal]&quot; value-ref=&quot;captchaFilter&quot;/&gt;--&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n    &lt;property name=&quot;filterChainDefinitions&quot;&gt;\n        &lt;value&gt;\n            /=authc\n            /register = anon\n            /forgot =anon\n            /login = anon\n            /login/action* = anon\n            /logout = logout\n            /js/** = anon\n            /rest/**=anon\n            /image/**=anon\n            /jawr_loader.js=anon\n            /user/create=roles[admin]\n            /post/create/**=roles[normal|admin]\n            /** =authc\n        &lt;/value&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>先来看<code>&lt;property name=&quot;filterChainDefinitions&quot;&gt;</code>中的属性.</p>\n<p><values>的内容,其实是url对应权限的一些mapping.表示对应的url mapping 需要对应的权限.\n其中<code>authc</code>,<code>anon</code>,<code>logout</code>样例中提及的这三个,是Shiro自己的默认配置</p>\n<blockquote>\n<p><code>authc</code>表示,这这个mapping代表的url需要登陆之后才能查看\n<code>anon</code>表示,这个mapping代表的url全部放行,所以可以看到所有js文件与image文件都被放行了\n<code>logout</code> 表示这个mapping代表的url将进行一次注销操作,在浏览器客户端进行的是session的注销,在服务器端则是进行缓存的删除</p>\n</blockquote>\n<p>其中 <code>roles[admin],roles[normal|admin]</code> 则是自己定义的过滤规则.\n表示<code>/user/create</code>只有角色包含<code>admin</code>的有权限访问\n且<code>/post/create</code>则是角色是<code>admin</code>或<code>normal</code>的有权限访问</p>\n<h5 id=\"-\">登录与注销</h5>\n<h6 id=\"-\">登录</h6>\n<p>对于所有需要登录的URL可以通过 <code>authc</code>一个拦截器来拦截\n在未登录的状态下,所有所有需要登录的URL都是自动跳转到上面XML所配置的<code>loginUrl</code>之中.\n当然这里返回的是 一个对 <code>/login</code>路径的get请求</p>\n<pre><code class=\"undefinedxml\">&lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;\n</code></pre>\n<h6 id=\"-\">注销</h6>\n<p>注销也很简单,只要任意url能够跳转到<code>/logout</code>,便会自动注销.</p>\n<h5 id=\"-\">同步登录与异步登陆</h5>\n<p>其实在Shiro的配置中,通过阅读源码可以看出,其实<code>loginUrl</code>一个属性,代表的是\n当Method=Get的请求到达其值对应的url(/login)时,返回登录的页面.\n当Method=Post的请求到达其值对应的url(/login)时,进入到的就是Shiro本身的登陆操作\n该操作,通过读取<code>securityManager</code>的配置,</p>\n<pre><code class=\"undefinedxml\">&lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;\n</code></pre>\n<p>通过自定义的realm <code>BookingShiroRealm</code></p>\n<blockquote>\n<p>此处<code>BookingShiroRealm</code>是自己定义的名称,只是为了符合但是的业务需要起的名字</p>\n</blockquote>\n<pre><code class=\"undefinedxml\">&lt;!-- Shiro&#39;s main business-tier object for web-enabled applications --&gt;\n&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;\n    &lt;property name=&quot;realm&quot; ref=&quot;shiroRealm&quot;/&gt;\n    &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;\n&lt;/bean&gt;\n\n&lt;!-- 項目自定义的Realm --&gt;\n&lt;bean id=&quot;shiroRealm&quot; class=&quot;com.quariuslt.service.security.BookingShiroRealm&quot;&gt;\n    &lt;property name=&quot;loginSessionService&quot; ref=&quot;loginSessionService&quot;/&gt;\n    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;\n    &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>接下来解说一下\n<code>BookingShiroRealm.java</code>\n的内容</p>\n<pre><code class=\"undefinedJava\">public class BookingShiroRealm extends AuthorizingRealm {\n    public static final String LOGIN_SESSION_NAME=&quot;loginSession&quot;;\n    public static final String SIMPLE_AUTHORIZATION_INFO=&quot;simpleAuthorizationInfo&quot;;\n\n    private LoginSessionService loginSessionService;\n\n    private UserService userService;\n\n\n    public LoginSessionService getLoginSessionService() {\n        return loginSessionService;\n    }\n\n    public void setLoginSessionService(LoginSessionService loginSessionService) {\n        this.loginSessionService = loginSessionService;\n    }\n\n    public UserService getUserService() {\n        return userService;\n    }\n\n    public void setUserService(UserService userService) {\n        this.userService = userService;\n    }\n\n    /*授权信息*/\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        LoginSession loginSession = (LoginSession) principals.fromRealm(getName()).iterator().next();\n        if(SecurityUtils.getSubject().getSession().getAttribute(LOGIN_SESSION_NAME)==null){\n            SecurityUtils.getSubject().getSession().setAttribute(LOGIN_SESSION_NAME, loginSession);\n        }\n        if(SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO)==null){\n\n            UserDto userDto=userService.findUserById(loginSession.getUserId());\n            if (userDto != null) {\n                SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n                Set&lt;RoleDto&gt; roleDtoSet=userService.getUserRolesByUserId(userDto.getId());\n                for(RoleDto roleDto:roleDtoSet){\n                    info.addRole(roleDto.getName().toLowerCase());\n                }\n\n                SecurityUtils.getSubject().getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO, info);\n            } else {\n                return null;\n            }\n        }\n        return (AuthorizationInfo)SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO);\n    }\n\n    /*认证信息*/\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        System.out.println(&quot;Come to BookingShiroRealm&quot;);\n        UsernamePasswordToken token=(UsernamePasswordToken)authenticationToken;\n        String userId=token.getUsername();\n        String cryptedPassword= String.valueOf(token.getPassword());\n        if(StringUtils.isNotEmpty(userId)){\n            UserDto targetUser=userService.getByUserId(userId);\n            System.out.println(&quot;TargetUser:&quot;+userId+&quot; InputPassWord:&quot;+cryptedPassword+&quot; DB PassWord:&quot;+targetUser.getCryptedPassword());\n            if(cryptedPassword.equals(targetUser.getCryptedPassword())){\n                System.out.println(&quot;BookingShiroRealm:Login Success&quot;);\n                LoginSession loginSession=new LoginSession(targetUser.getId(), targetUser.getUserId(),targetUser.getEmail(),SecurityUtils.getSubject().getSession().getHost());\n                loginSessionService.clearSessionByUserId(userId);\n                loginSessionService.save(loginSession);\n                return new SimpleAuthenticationInfo(loginSession,targetUser.getCryptedPassword().toCharArray(),getName());\n            }\n        }\n        return null;\n    }\n}\n</code></pre>\n<p><code>AuthorizingRealm</code>是Shiro负责身份认证的抽象类.\n需要实现其<code>doGetAuthenticationInfo</code>方法,实现 对提交过来的用户名/密码 等账号信息,跟数据库进行交互判定登陆是否成功的过程.\n和实现其<code>doGetAuthorizationInfo</code>方法,实现对需要登陆之后 对权限的认证.</p>\n<p>在说到登陆的校验之前,可以看到在<code>doGetAuthenticationInfo</code>方法里面 有一个authenticationToken.里面包含了登陆传递过来的用户名和密码信息.这里又是怎么来的呢.\n此时返回来回到Spring配置Shiro的xml <code>applicationContext-shiro-captcha.xml</code>\n会发现</p>\n<pre><code class=\"undefinedxml\">&lt;property name=&quot;filters&quot;&gt;\n    &lt;map&gt;\n        &lt;entry key=&quot;authc&quot; value-ref=&quot;captchaFilter&quot;/&gt;\n        &lt;entry key=&quot;roles[admin]&quot; value-ref=&quot;captchaFilter&quot;/&gt;\n        &lt;entry key=&quot;roles[normal]&quot; value-ref=&quot;captchaFilter&quot;/&gt;\n    &lt;/map&gt;\n&lt;/property&gt;\n</code></pre>\n<p>里面会有一个<code>captchaFilter</code>,\n指向其注入的类 <code>CaptchaFormAuthenticationFilter.java</code></p>\n<p>附上<code>CaptchaFormAuthenticationFilter</code>代码</p>\n<pre><code class=\"undefinedJava\">public class CaptchaFormAuthenticationFilter extends FormAuthenticationFilter {\n\n    public static final String DEFAULT_CAPTCHA_PARAM = &quot;captcha&quot;;\n\n    private String captchaParam = DEFAULT_CAPTCHA_PARAM;\n\n    public String getCaptchaParam() {\n\n        return captchaParam;\n\n    }\n\n    protected String getCaptcha(ServletRequest request) {\n\n        return WebUtils.getCleanParam(request, getCaptchaParam());\n\n    }\n\n    @Override\n    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {\n        setFailureAttribute(request, e);\n        return true;\n    }\n\n    @Override\n    protected void setFailureAttribute(ServletRequest request, AuthenticationException ae) {\n        String className = ae.getClass().getName();\n        request.setAttribute(getFailureKeyAttribute(), className);\n    }\n\n    //这里进行密码的加密\n    @Override\n    protected CaptchaUsernamePasswordToken createToken(ServletRequest request, ServletResponse response) {\n        System.out.println(&quot;Come to CreateToken&quot;);\n        String username = getUsername(request);\n        String password = getPassword(request);\n        String captcha = getCaptcha(request);\n        boolean rememberMe = isRememberMe(request);\n        String host = getHost(request);\n\n        System.out.println(&quot;Captcha UserName(UserId):&quot; + username);\n        System.out.println(&quot;Captcha Password:&quot; + password);\n        System.out.println(&quot;Captcha RememberMe:&quot; + rememberMe);\n\n\n        return new CaptchaUsernamePasswordToken(username,\n                password.toCharArray(), rememberMe, host, captcha);\n\n    }\n\n\n    @Override\n    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {\n        CaptchaUsernamePasswordToken token = createToken(request, response);\n\n        try {\n            System.out.println(&quot;Execute Login~&quot;);\n            Subject subject = getSubject(request, response);\n            subject.login(token);\n\n            return onLoginSuccess(token,subject, request, response);\n        } catch (AuthenticationException e) {\n            return onLoginFailure(token,e, request, response);\n        }\n    }\n}\n</code></pre>\n<p>继承<code>FormAuthenticationFilter</code>的<code>CaptchaFormAuthenticationFilter</code>并重写其<code>CaptchaUsernamePasswordToken</code>方法.\n用于通过<code>/login</code>的POST方式提交过来的时候,便会先经过此filter的<code>createToken</code>方法进行token的生成</p>\n<p>假设有一个登陆页面的<code>/login</code>使用同步提交方式,即通过页面的form表单,<code>action=&quot;/login&quot;</code>,<code>method=&quot;POST&quot;</code>提交到后台,触发流程是</p>\n<blockquote>\n<ol>\n<li>到达 <code>FormAuthenticationFilter</code> 根据表单 生成Token.</li>\n<li>调用 Shiro专门处理认证的 <code>subject</code>其<code>login</code>方法进行登陆</li>\n<li><code>login</code>方法 通过调用 自定义的<code>BookingShiroRealm</code>方法所实现的顶级接口 来实现对数据库的信息的读取</li>\n<li>判定登陆用户名与密码 匹配之后,可以通过Shiro自己配置的缓存保存认证信息.</li>\n</ol>\n</blockquote>\n<p>但是在这个时代,还通过同步登陆 实在是太TM捞了,其实异步登陆提交,只需要 手动调用subject.login方法即可\n将第一步到达<code>FormAuthenticationFilter</code>的token手动生成</p>\n<p>异步登陆的实现代码 大概如下(以Controller为例)</p>\n<pre><code class=\"undefinedJava\">@RequestMapping(value = &quot;/action&quot;, method = RequestMethod.POST,produces = MediaType.APPLICATION_JSON_VALUE)\n@ResponseBody\npublic LoginMessage loginAction(\n        @RequestParam(value = &quot;username&quot;) String username,\n        @RequestParam(value = &quot;password&quot;) String password,\n        @RequestParam(value = &quot;rememberMe&quot;, required = false, defaultValue = &quot;false&quot;) boolean rememberMe,\n        ServletRequest request) {\n    LoginMessage loginMessage = new LoginMessage(BKGConstants.ActionStatus.FAILURE.getDescription());\n    Subject subject = SecurityUtils.getSubject();\n\n\n    //尝试获取 跳转到Login前的那个页面的url\n    if(null != WebUtils.getSavedRequest(request)) {\n        String requestURI= WebUtils.getSavedRequest(request).getRequestURI();\n        loginMessage.setRedirect(requestURI);\n    }\n\n    try {\n        String salt=userService.getByUserId(username).getSalt();\n        UsernamePasswordToken token = new UsernamePasswordToken(username, EncryptUtil.encrypt(password,salt));\n        subject.login(token);\n        loginMessage.setStatus(BKGConstants.ActionStatus.SUCCESS.getDescription());\n\n        //尝试判断 用户是不是第一次登陆\n        UserDto currentUser=userService.getByUserId(username);\n        if (currentUser.getActive().equals(BKGConstants.UserAccountStatus.FIRST_LOGIN.getIndex())){\n            String redirectPath=request.getServletContext().getContextPath()+&quot;/user/password/reset&quot;;\n            loginMessage.setRedirect(redirectPath);\n        }\n\n\n    } catch (UnknownAccountException e) {\n        loginMessage.setMessage(BKGConstants.LoginFailureMessage.PASSWORD_WRONG.getDescription());\n    } catch (IncorrectCredentialsException |NullPointerException e) {\n        loginMessage.setMessage(BKGConstants.LoginFailureMessage.USER_NOT_EXIST.getDescription());\n    } catch (AuthenticationException e) {\n        loginMessage.setMessage(BKGConstants.LoginFailureMessage.ACCOUNT_LOCK.getDescription());\n    }\n    return loginMessage;\n}\n\nclass LoginMessage {\n    private String status;\n    private String message;\n    private String redirect;\n\n    public LoginMessage(String status) {\n        this.status = status;\n    }\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    public String getRedirect() {\n        return redirect;\n    }\n\n    public void setRedirect(String redirect) {\n        this.redirect = redirect;\n    }\n}\n</code></pre>\n<h5 id=\"-\">角色校验</h5>\n<p>登陆的时候,其实只是实现了 <code>登陆认证</code>,<code>缓存登录信息</code>的过程.\n并没有实现,<code>权限赋予</code>的过程.只有第一次遇到 需要登陆且特定权限的url的时候,才会请求后台是否有进入对应url的权限.</p>\n<p>在讲权限之前,概括一下数据库的设计</p>\n<pre><code class=\"undefinedSQL\">CREATE TABLE USERS\n(\n    ID BIGINT PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    ACTIVE BIT NOT NULL,\n    ADDRESS VARCHAR(300),\n    CITY VARCHAR(50),\n    COMPANY VARCHAR(20),\n    COUNTRY VARCHAR(50),\n    CRYPTED_PASSWORD VARCHAR(255),\n    DEPARTMENT VARCHAR(20),\n    DISPLAY_NAME VARCHAR(128),\n    EMAIL VARCHAR(60) NOT NULL,\n    FAX VARCHAR(100),\n    FIRST_NAME VARCHAR(40),\n    GENDER VARCHAR(6),\n    JOBTITLE VARCHAR(100),\n    LAST_NAME VARCHAR(40),\n    LOCATION VARCHAR(50),\n    MIDDLE_NAME VARCHAR(40),\n    OFFICE VARCHAR(20),\n    OFFICECODE VARCHAR(22),\n    PHONE VARCHAR(128),\n    SALT VARCHAR(255) NOT NULL,\n    STAFFID VARCHAR(20),\n    STAFFROLE VARCHAR(15),\n    TERRITORY VARCHAR(100),\n    USERID VARCHAR(20) NOT NULL\n);\n\n\nCREATE TABLE ROLES\n(\n    ID BIGINT PRIMARY KEY NOT NULL AUTO_INCREMENT,\n    DESCRIPTION VARCHAR(255),\n    NAME VARCHAR(255) NOT NULL\n);\nCREATE UNIQUE INDEX UK_OFX66KERUAPI6VYQPV6F2OR37 ON ROLES (NAME);\n\nCREATE TABLE ROLE_USER\n(\n    ROLE_ID BIGINT NOT NULL,\n    USER_ID BIGINT NOT NULL,\n    PRIMARY KEY (ROLE_ID, USER_ID),\n    FOREIGN KEY (ROLE_ID) REFERENCES ROLES (ID),\n    FOREIGN KEY (USER_ID) REFERENCES USERS (ID)\n);\n\nCREATE INDEX FK_NJAJEL6A2Q8TR36EMB9L8VW7N ON ROLE_USER (USER_ID);\n</code></pre>\n<p>数据库有三个表 <code>USERS</code>,<code>ROLES</code>,<code>USER_ROLE</code>\n其实在设计上<code>User</code>表跟<code>ROLE</code>表是多对多的关系,即User里面有一个Set<Role>,Role里面也有一个Set<User>\n通过中间表<code>USER_ROLE</code>来实现多对多关联.</p>\n<p>下面来看 身份认证的具体实现\n<code>BookingShiroRealm.java</code></p>\n<pre><code class=\"undefinedJava\">protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    LoginSession loginSession = (LoginSession) principals.fromRealm(getName()).iterator().next();\n    if(SecurityUtils.getSubject().getSession().getAttribute(LOGIN_SESSION_NAME)==null){\n        SecurityUtils.getSubject().getSession().setAttribute(LOGIN_SESSION_NAME, loginSession);\n    }\n    if(SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO)==null){\n\n        UserDto userDto=userService.findUserById(loginSession.getUserId());\n        if (userDto != null) {\n            SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n            Set&lt;RoleDto&gt; roleDtoSet=userService.getUserRolesByUserId(userDto.getId());\n            for(RoleDto roleDto:roleDtoSet){\n                info.addRole(roleDto.getName().toLowerCase());\n            }\n\n            SecurityUtils.getSubject().getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO, info);\n        } else {\n            return null;\n        }\n    }\n    return (AuthorizationInfo)SecurityUtils.getSubject().getSession().getAttribute(SIMPLE_AUTHORIZATION_INFO);\n}\n</code></pre>\n<p>通过</p>\n<pre><code class=\"undefinedJava\">Subject.getSession().setAttribute(SIMPLE_AUTHORIZATION_INFO,info)\n</code></pre>\n<p>来实现一个 根据通过已经登陆的用户,获取其在数据库中所具有的角色的名字的集合 生成字符串,然后存在Session里面.\n当需要对应的权限,且发现已经有<code>SIMPLE_AUTHORIZATION_INFO</code>这个属性,则根据属性中是否含有对应字符串的来判定是否有对应权限.</p>\n<p>当然 对应权限的获取,也是通过shiro 配置里面的captchaFilter的具体实现类,实现其<code>isAccessAllowed</code>方法来判定.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>本次主要分享了Share 如何在Spring中整合Apache Shiro的过程.\n但是整体配置依然是通过XML统一配置,其实Shiro在近期的版本已经有了Annotation级别的方法能够方便的对URL的Mapping进行注解.\n具体的应用过程,就像Spring 2.X 升级到 3.X 的过程一样,但是由于没有实战,不便多说.</p>\n"},{"link":"2015/11/10/beanutils-vs-reflection","title":"记一次神奇的优化过程:Java反射 VS Apache BeanUtils VS Spring BeanUtils","published":"2015-11-10T15:13:41.000Z","tags":["Java","Apache"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近老大分配了个性能优化的任务,因为主要页面在Production上打开的时间太长,(大概7s?卧槽 第一次听到的时候还以为我听错了).\n居然这么慢..\n其实是有主程序大大带着我做,所以在扫了一遍前端ExtJS的结构之后,发现错综复杂四年以来不同技术层次的人都在同一个页面上添油加醋,\n了解以前的需求之后完全重构基本是不可能的,所以前端的性能优化就交给主程序大大,我跑去扫一下服务器端有什么性能瓶颈.</p>\n<h3 id=\"-jprofiler-\">使用 JProfiler 分析 代码性能</h3>\n<blockquote>\n<p>通过网上找来的资料,比较了一份周围的资料\nIBM的 <a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-profiling/\">常用 Java Profiling 工具的分析与比较</a>\n最后决定使用JProfiler进行性能分析</p>\n</blockquote>\n<h4 id=\"intellij-idea-jprofiler-weblogic-\">IntelliJ IDEA集成 JProfiler 监控 Weblogic 实例</h4>\n<p>idea 集成了 (应该是JProfiler本身就带了idea的插件安装) 安装之后就会 在启动服务器运行的 按钮多出一个 使用JProfiler 运行.</p>\n<blockquote>\n<p>由于JProfiler 本身也是通过javaagent的方法更改一些类加载运行时策略,所以会跟Jrebel冲突.\n所以在使用JProfiler监控性能的时候,如果之前在weblogic服务器运行配置的过程中添加了jrebel.jar 作为javaagent的参数,务必删掉\n其余配置 与之前的<a href=\"http://blog.aquariuslt.com/2015/10/08/jrebel-configuration-with-weblogic-in-idea/\">Jrebel插件结合weblogic</a>一样</p>\n</blockquote>\n<h4 id=\"-jprofiler-\">通过JProfiler 分析方法执行时间</h4>\n<p>通过JProfiler插件启动weblogic服务器实例之后,JProfiler的GUI界面将会启动,并成功监听到对应的实例进程.\n实例成功启动之后,下面会有一个CPU Time的标签页,选中并点击<code>record</code>.\n触发任意次目标方法,即可看到所有方法的执行时间\n<img src=\"https://img.alicdn.com/tfscom/TB1Q_QmKpXXXXaAXpXXXXXXXXXX.png\" alt=\"方法执行时间\"></p>\n<h3 id=\"-\">正文:性能优化部分</h3>\n<p>言归正传,在看到性能分析记录的时候,一个叫做\n<code>ReflectionUtil.convertObjectWithSameFields()</code>\n的方法,方法体如下</p>\n<pre><code class=\"undefinedJava\">/**\n* Convert between two Object with the same field, setter and getter\n*\n* @param target\n*            the object wants to be convert to\n* @param source\n*            the object as source of converter\n*/\npublic static void convertObjectToObjectWithSameFields(Object target, Object source) {\n    List&lt;Field&gt; detailFields = new ArrayList&lt;Field&gt;();\n    List&lt;Field&gt; oFields = new ArrayList&lt;Field&gt;();\n    for (Class&lt;?&gt; clas = target.getClass(); clas != Object.class; clas = clas.getSuperclass()) {\n        detailFields.addAll(Arrays.asList(clas.getDeclaredFields()));\n    }\n    for (Class&lt;?&gt; clas = source.getClass(); clas != Object.class; clas = clas.getSuperclass()) {\n        oFields.addAll(Arrays.asList(clas.getDeclaredFields()));\n    }\n    for (Field dField : detailFields) {\n        for (Field oField : oFields) {\n            String targetField = dField.getName();\n            String sourceField = oField.getName();\n            if (targetField.equals(sourceField)) {\n                try {\n                    Object object = getAttributeValue(oField.getName(), source, true);\n                    if (object != null)\n                        setAttributeValue(dField.getName(), object, target, object.getClass());\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>原来是使用了JDK的反射API,遍历两个Bean的属性去进行对应的<code>getter</code>,<code>setter</code>方法.时间复杂度为O(n*m),(可是到后面发现好像并不是这个时间复杂度的问题,囧).\n由于JDK原生的Reflection比较辣鸡,效率比较慢,所以造成了本次性能瓶颈的原因之一.</p>\n<p>一开始先是想到了Apache CommonUtils类库里面的BeanUtils 和 PropertyUtils来替换同事造的效率很低的轮子\n通过看源码,大概发现BeanUtils是这样实现属性复制的</p>\n<p>首先他会将 需要进行属性复制的两个Bean抽取出来,然后一个Map储存其类型和名字相同的属性.\n接着这个Map会根据里面的几种属性分成对应的属性(大概是基本类型,List类型,Map类型以及自定义类型)</p>\n<p>在进行属性复制的时候,会根据该动态Bean里面的属性,来找到目标Bean是否含有对应的setProperites方法,然后调用 源Bean的getProperties方法.</p>\n<p>但是这个BeanUtils 有个缺点,就是遇到很操蛋的属性(恰好遇到这个情况)的时候,不能对一些属性进行ignore操作.</p>\n<blockquote>\n<p>原因是需要转换的两个JavaBean其实并不是规范的JavaBean\n其中一个JavaBean 有一个getter方法,叫做getXX() 但是返回的却是 一个List集合的第一个元素.\n这时候操蛋的另一个JavaBean 也有一个 setter方法,叫做setXX() 但是这个JavaBean却是规范的JavaBean.</p>\n</blockquote>\n<p>最后是使用Spring-Bean的BeanUtils解决问题的.因为它能够传第一个ingore的属性名集合进去,不读这部分.</p>\n<p>优化结果是,将原来的轮子替换成Spring的BeanUtils.\n结果比在本地测试快了700ms,希望在Production上也有300+ms的优化表现.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>实现不同的JavaBean(常见场景是Entity,DTO,VO)之间相同属性名的转化过程,可以利用BeanUtils.copyProperties来实现.</p>\n"},{"link":"2015/10/01/blog-with-hexo","title":"Blog-with-Hexo","published":"2015-10-01T05:53:47.000Z","tags":["Blog"],"html":"<h2 id=\"hostname\">HostName</h2>\n<p>心血来潮搞了个CNAME,发现CNAME的方式看上去更加美观.所以先暂时弄了个blog的host.\nBlog的SourceCode也会上传到Github做备份</p>\n<p><img src=\"http://7xn6p8.com1.z0.glb.clouddn.com/hexo-in-idea.png\" alt=\"hexo-in-idea\"></p>\n"},{"link":"2015/10/01/debug-with-hexo","title":"Debug-with-Hexo","published":"2015-10-01T05:53:47.000Z","tags":["Hexo","Blog"],"html":"<h2 id=\"-blog\">  - Blog</h2>\n<h2 id=\"debug-with-hexo\">Debug with Hexo</h2>\n<p>Debug Note of Hexo Blog.\n为了频繁防止低质量的debug日志放在<a href=\"http://blog.aquariuslt.com\">正式博客</a>上.\n特意设置了这样一个专门防止debug系列的site.</p>\n"},{"link":"2015/07/10/domain-transfer-from-aliyun-to-godaddy","title":"域名运营商转移：从万网转出到Godaddy","published":"2015-07-10T04:58:40.000Z","tags":["Domain","VPS"],"html":"<h2 id=\"background\">Background</h2>\n<p>前几天收到万网的通知，之前没注意看霸王条款，把阿里云主机迁移到DO了。</p>\n<p><img src=\"\" alt=\"aliyun-notification\">\n卧槽就因为我在你家买了域名不用你家VPS就要浪费我辛辛苦苦备案了一个月的网站吗？一怒之下决定转移运营商。</p>\n<p>域名转移运营商(万网到Godaddy)，从总体的角度来说要如下几点</p>\n<h3 id=\"-\">从原运营商那里拿到 原来的域名锁密钥</h3>\n<p>这一步就非常只麻烦，需要分成以下几小步</p>\n<ol>\n<li>登陆万网<a href=\"http://wanwang.aliyun.com/\">http://wanwang.aliyun.com/</a>，(登了才发现 万网改成aliyun域名了)解除域名保护的锁。\n点击域名进入管理页面\n[<img src=\"\" alt=\"Domain Management\">]</li>\n<li><p>关闭各种安全验证\n这一步很重要，因为如果不关闭安全认证，通过Whois 查看你的域名，则你的域名的所有者将会显示成  万网的 YinSiBaoHu@aliyun.com 神马的，这将会导致你的真正邮箱收不到 需转入的域名运营商(Godaddy)发来的请求邮件。\n<a href=\"\"><img src=\"\" alt=\"Close Authorization\"></a></p>\n</li>\n<li><p>验证手机，接收短信。然后核对邮箱，获取转移码\n这里按照提示操作，由于我操作过了 没有对应的截图。</p>\n</li>\n</ol>\n<p>当邮箱收到了转移码之后，开始进行第二大步。</p>\n<h3 id=\"-\">注册需要转入的域名运营商</h3>\n<p>P.S.我选的是Godaddy</p>\n<ol>\n<li>添加域名转移请求，付费。\n在Godaddy主页 选择“All Products”-“Transfer Domains”\n[<img src=\"\" alt=\"Transfer Domain\">\n在搜索需要转入的域名页面，输入要申请转入的域名 搜索。然后会上方会出现一个 列表，选中要转移的域名，点击checkout。</li>\n</ol>\n<p>之后就是用支付宝支付，大概50RMB。这里不管要转入的域名所有权是不是你的，都必须先付费。</p>\n<ol>\n<li>开始发送转移域名请求\n在“Domain”-“Pending Transfers in” 中可以看到要转移的域名列表。\n由于我这里已经进行了转移，所以作文字说明。\n[<img src=\"\" alt=\"Start Transfer\"></li>\n</ol>\n<p>首先，要确认你要转入的域名，Admin Email那一栏是不是 你的邮箱。\n如果之前在万网那边没有取消隐私保护，那么这里的AdminEmail就会变成 aliyun的保护邮箱。\n<img src=\"\" alt=\"Cancel Private Protect\">\n确认邮箱是自己的域名邮箱之后，中间的Status一栏，是发送域名转移的第一步请求。</p>\n<p>点击第一步之后，你的域名邮箱应该会受到一封邮件\n[<img src=\"\" alt=\"Verify ID\">\n里面带有一个 TransferID和Code 用来帮Godaddy确认你是邮箱主人。</p>\n<p>然后输入ID和Code之后，就可以用第一步万网给你发来的转移密码，进行转移。</p>\n<p>最后转移到万网可以看到\n<a href=\"\"><img src=\"\" alt=\"Wait for operation\"></a>\n等几天就成功了。\n记得重置 域名的dns和ip。</p>\n"},{"link":"2015/02/20/early-future-past-memory","title":"曾经憧憬的未来，现在竟是缅怀遥不可及过去","published":"2015-02-19T22:43:14.000Z","tags":["Diary"],"html":"<p>回家收拾东西的时候，好多东西勾起了回忆。</p>\n<h2 id=\"-\">光盘</h2>\n<p>这些光盘，分成三种类型：游戏碟，系统盘，杂志碟。\n当年机器太垃圾，第一台电脑 赛扬600(被我超到900)+192M内存(8M还分到了显存)+CRT显示器，想装个War3都卡。还是买了一大堆游戏碟，在如此垃圾的老爷机上 打通了许多单机：暗黑破坏神2，洛克人X458,War3剧情,空之轨迹 登蹬\n后来初中的时候升级到了 闪龙2800+ +1G内存 +X800XT(AGP插口里面算中高了)\n开始接触点能玩的游戏 大概是地牢围攻 泰坦之旅 (三国群英传...总感觉质量很低) 魔戒\n再到后来 自己买了WOW的碟 按照教程假设服务器 打单机的WOW.那是我第一次用Navicat 还有装MySQL 等等</p>\n<h2 id=\"-\">小说与名著</h2>\n<p> [<img src=\"\" alt=\"小说与名著\"></p>\n<p> [<img src=\"\" alt=\"小说与名著2\"></p>\n<p>看到以前买过的好多书 《哈利波特》7本 还一堆垃圾工具书 还一些名著。\n我想我的近视就是当年躺在床上侧睡看完了这些书而造成的吧。。跟掌机一点关系都没</p>\n<h2 id=\"-\">老机器的零件</h2>\n<p> [<img src=\"\" alt=\"40G老硬盘\"></p>\n<p>赛扬600 老爷机的那台40G的硬盘 IDE接口 那个年代经常拆东墙补西墙\n以至于后来的电脑虽然有250G空间 还是买了个DVD刻录机和许多空盘刻录用。我还记得那个刻录机的型号是三星TS-H652M</p>\n<h2 id=\"-\">杂志</h2>\n<p> [<img src=\"\" alt=\"电脑杂志\">\n书柜再往下打开 就是一堆电脑杂志。\n以前零花钱一个月有50 全被拿来买报纸和杂志:2.5RMB的《电脑包》<em>3,8.5RMB的《微型计算机》</em>1,6RMB的《电脑迷》,5RMB的《电脑爱好者*2》 直到后来上了高中 接触了WOW 也少有断买过。</p>\n<p>刚对装机感兴趣的时候，觉得配置就是一切。望着遥不可及的高价格PC，能够将他们写在纸上，然后列出他们的参数规格，也挺有快感。\n还清楚记得 初中的时候写了一份当时觉得特牛逼的列表，那时候AMD单核还是能干翻Intel\nCPU:AMD-FX62\n内存是海盗船的\n显卡是讯景的7900GTX(广告软文看的多居然接受了他是个牛逼的一线品牌的观念)\n电源是广告上那个900W的\n还有当时希捷新推出的垂直储存技术的新硬盘.....</p>\n<hr>\n<p>后来我把好多好多用不上 占地方的东西扔了。\n清理干净，不留羁绊。</p>\n<p>当年希望赶紧长大，经济独立，财务自由，可以光明正大打游戏。\n经过这些年才发现，过上舒适的生活，并没有想象中那么顺利。</p>\n<p>曾经憧憬的未来，现在竟是缅怀遥不可及过去。</p>\n"},{"link":"2015/10/02/extjs-experience-customize-component","title":"ExtJS-Experience","published":"2015-10-01T16:10:22.000Z","tags":["ExtJS","JavaScript"],"html":"<h1 id=\"extjs-experience\">ExtJS Experience</h1>\n<h2 id=\"-\">前言</h2>\n<p>前几个月用前端用的比较多的ExtJS,正好趁能够重新写的部分将之前的ExtJS代码逻辑重新整理一下.\n由于使用的版本是ExtJS 4.2, 只有里面的store才有数据绑定的概念.直到ExtJS 5 才出现ViewModel这种MVVM的概念,所以我在写代码的时候遵守的是ExtJS MVC的规约,尽量将View和Controller分开,抽取所有逻辑在Controller或者组件方法重写中.</p>\n<p>主要自己总结出来的几个地方:</p>\n<blockquote>\n<ul>\n<li>ExtJS MVC结构</li>\n<li>ExtJS 在本项目中用到的常用组件控制</li>\n<li>ExtJS 自定义组件</li>\n</ul>\n</blockquote>\n<h2 id=\"mvc-\">MVC结构</h2>\n<h3 id=\"extjs-mvc-\">ExtJS的MVC组成</h3>\n<p>ExtJS的MVC结构实际上全是Model(Store),View,Controller.\n与基本的MVC概念还多出了一个Store的概念.\n其实Store主要的作用(至少在我项目中是这么用的)有如下几个:</p>\n<ul>\n<li>提供Model与后台服务端之间的数据读取代理(场景:下拉列表的自动完成)</li>\n<li>提供Model在UI上的表格组件的双向绑定(场景:表格的上的数据绑定)</li>\n</ul>\n<h3 id=\"extjs-mvc-\">ExtJS MVC代码结构</h3>\n<p>以一个带有城市查询功能的注册页面来说,一个完整的ExtJS MVC代码结构应该是这样:</p>\n<pre><code>|-register\n|--controller\n|---RegisterController.js\n|--model\n|--store\n|---CityStore.js\n|---CountryStore.js\n|---CountyStore.js\n|---StateStore.js\n|--view\n|---RegisterView.js\n|-RegisterApp.js\n</code></pre><p>可以看到 model不是必须的,其实store也不一定会需要,视乎实际场景需要.</p>\n<p>在MVC结构之下,在html引入js文件的时候,需要注意顺序.\n大概是所有<code>Model</code>,<code>Store</code>,<code>View</code>,<code>Controller</code>,最后才到<code>App.js</code></p>\n<p>原因是在ExtJS MVC结构之下,整个html的body部分其实都是由ExtJS来渲染的,\n所以将整个MVC交给Ext的application去管理.\n而<code>App.js</code>则是负责整个application的实际需要文件的加载,和当前页面默认View的渲染</p>\n<p>来看一下<code>RegisterApp.js</code>的代码</p>\n<pre><code class=\"undefinedJavaScript\">Ext.application({\n    name:&#39;Register&#39;,\n    appFolder:&#39;/js/register&#39;,\n\n    views:[\n        &#39;RegisterView&#39;\n    ],\n    controllers:[\n        &#39;RegisterController&#39;\n    ],\n    stores:[\n        &#39;CityStore&#39;,\n        &#39;CountyStore&#39;,\n        &#39;CountryStore&#39;,\n        &#39;StateStore&#39;\n    ],\n    launch:function(){\n        Ext.create(&#39;Register.view.RegisterView&#39;).show();\n    }\n});\n</code></pre>\n<p>上面的意思是当加载<code>RegisterApp.js</code>之后,会做以下事情:</p>\n<blockquote>\n<ol>\n<li>根据<code>name:&#39;Register&#39;</code>去加载对应的MVC组件</li>\n<li>以RegisterView作为初始页面去渲染</li>\n</ol>\n</blockquote>\n<p>第一点中说明<code>name:&#39;Register&#39;</code>的作用主要是作为 app 的名字\n定义了name之后,查找model,view,controller,store,都是通过代码中\nExtJS定义的 name+(model/view/store/controller)+自定义组件名 来定位对应的组件.</p>\n<p>比如在上面<code>RegisterApp.js</code>中加载了</p>\n<pre><code class=\"undefinedJavaScript\">views:[\n    &#39;RegisterView&#39;\n]\n</code></pre>\n<p>实际上RegisterView.js中的代码是下面这样的:</p>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Register.view.RegisterView&#39;,{\n    extend:&#39;Ext.container.Viewport&#39;,\n\n    initComponent:function(){}\n}\n</code></pre>\n<p>同理,自定义<code>model</code>,<code>store</code>,<code>controller</code>也是这样.</p>\n<h3 id=\"mvc-\">MVC组件基本说明</h3>\n<p>定义<code>model</code>,<code>view</code>,<code>store</code>,<code>controller</code>等组件,都需要继承ExtJS本身的组件\n下面还是以Register界面做例子,说明一下controller,view,store</p>\n<h4 id=\"view\">View</h4>\n<p>View需要继承<code>Ext.container.Viewport</code>,\n之后重写initComponent方法来编写界面上的组件与布局.\n这里<code>Ext.applyIf</code>的意思是,不仅仅是重写方法,而是在原有的方法上做部分的替换和覆盖,在applyIf的作用域没有定义到的变量/值,则从所继承的组件中获取\n如果用<code>Ext.apply</code>则是强行覆盖,与Git的force push意思差不多.</p>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Register.view.RegisterView&#39;,{\n    extend:&#39;Ext.container.Viewport&#39;,\n\n    id:&#39;RegisterViewPort&#39;,\n    itemId:&#39;RegisterViewPort&#39;,\n\n    layout:{\n        type:&#39;hbox&#39;,\n        align:&#39;middle&#39;,\n        pack:&#39;center&#39;\n    },\n\n    initComponent:function(){\n        var self=this;\n        Ext.applyIf(self,{\n            //components\n        });\n        self.callParent(arguments);\n    }\n});\n</code></pre>\n<h4 id=\"controller\">Controller</h4>\n<p>Controller需要继承<code>Ext.app.Controller</code>\n通过复写init方法,在control()内部指定对应的选择器的组件,在对应的事件发生的时候要执行的方法\n在这个controller.js中,表明了:</p>\n<blockquote>\n<ol>\n<li>当id为cancelRegisterButton的组件,在点击的时候执行<code>jumpToLoginPage</code>方法.</li>\n<li>当id为registerButton的组件,在点击的时候执行<code>registerCompanyAndUser</code>方法</li>\n</ol>\n</blockquote>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Register.controller.RegisterController&#39;,{\n    extend:&#39;Ext.app.Controller&#39;,\n\n    init:function(application){\n        this.control({\n            &quot;#cancelRegisterButton&quot;:{\n                click:this.jumpToLoginPage\n            },\n            &quot;#registerButton&quot;:{\n                click:this.registerCompanyAndUser\n            }\n        });\n    },\n\n    jumpToLoginPage:function(){\n            window.location.href=ctx+&quot;/login&quot;;\n    },\n\n\n    registerCompanyAndUser:function(){\n        var self=this;\n\n        //1.Validate\n        var validateFlag = self.validateRegisterForm();\n        if(!validateFlag)return ;\n\n        //2.Collect data and submit\n        self.collectRegisterFormData();\n    },\n}\n</code></pre>\n<h3 id=\"store\">Store</h3>\n<p>Store需要继承<code>Ext.data.Store</code>组件</p>\n<p>Store需要配合model使用,或者直接在store中以field来定义model\n在下面这份代码里面,<code>CityStore</code>主要的作用是为了提供一些城市的下拉列表</p>\n<p>大致内容是:\n当一个组件(Combobox下拉菜单/GridPanel表格面板)指定了CityStore作为Store的时候,\n通过ajax方式访问后台 <code>/rest/location/city/list</code>的地址获取城市列表\n其中返回的格式以<code>application/json</code>格式解析成json.\n以json数组中的 id,code,name的键值对构建成store的内部model.</p>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Register.store.CityStore&#39;,{\n    extend:&#39;Ext.data.Store&#39;,\n\n    storeId:&#39;CityStore&#39;,\n    autoLoad:false,\n    fields:[\n        &#39;id&#39;,\n        &#39;code&#39;,\n        &#39;name&#39;\n    ],\n    proxy:{\n        type:&#39;ajax&#39;,\n        url:ctx+&#39;/rest/location/city/list&#39;,\n        reader:{\n            type:&#39;json&#39;\n        }\n    }\n});\n</code></pre>\n<h3 id=\"-\">效果预览</h3>\n<p><img src=\"http://7xn6p8.com1.z0.glb.clouddn.com/register-city-autocomplete.gif\" alt=\"Register\"></p>\n<h2 id=\"-\">常见组件效果</h2>\n<blockquote>\n<p>待更新,可能是一个列表</p>\n</blockquote>\n<h2 id=\"-\">自定义组件</h2>\n<p>一些主要的自定义的一些组件,需要配合后台使用.\n在自定义组件的时候,其实最主要是去官方文档查看到底这个轮子需不需要造,在确定需要造轮子之后,还要考虑这个轮子的可复用范围.\n所以我自定义一些组件的时候,主要也是通过查看ExtJS对应组件源码的实现,复写当中的一些方法,达到效果</p>\n<h3 id=\"allowblankcombobox\">AllowBlankCombobox</h3>\n<p><strong>允许为空的下拉列表</strong></p>\n<h4 id=\"-\">背景</h4>\n<p>在需要用下拉列表,以及其自动完成功能的时候,为了防止用户输入错误的值,\n后台匹配不到对应的id,通常会在combobox组件下添加<code>forceSelection:true</code>,\n使得用户输入错误的时候,自动返回到上一个选择.</p>\n<p>但是这样问题来了,用户一旦在可编辑的下拉列表输入了任意值之后,就再也不能将该combobox留空.\n一旦留空,就会返回到上一个选择的值.</p>\n<blockquote>\n<p>通过研究这部分的源码,发现源码中直接把空的情况也当当做所谓的乱输入了.因为在源码中如果 调用<code>findRecordByDisplay(value)</code>一旦没有对应的record也被等同是用户胡乱输入.\n所以就重写了assertValue方法,增加了判断为空的情况</p>\n</blockquote>\n<h4 id=\"-\">适用场景</h4>\n<p>需要强制用户在使用可编辑的下拉列表时 选择任意auto-complete出来的值或者设成空</p>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Ext.component.AllowBlankCombobox&#39;, {\n    extend: &#39;Ext.form.field.ComboBox&#39;,\n    alias: &#39;widget.allowblankcombobox&#39;,\n\n    assertValue: function () {\n        var me = this,\n            value = me.getRawValue(),\n            rec, currentValue;\n\n        if (me.forceSelection) {\n            if (me.multiSelect) {\n                if (value !== me.getDisplayValue()) {\n                    me.setValue(me.lastSelection);\n                }\n            } else {\n\n\n                rec = me.findRecordByDisplay(value);\n                if (rec) {\n                    currentValue = me.value;\n\n\n                    if (!me.findRecordByValue(currentValue)) {\n                        me.select(rec, true);\n                    }\n                } else {\n                    if(me.getRawValue() == &#39;&#39;){\n                        me.setValue(&#39;&#39;);\n                    }\n                    else {\n                        me.setValue(me.lastSelection);\n                    }\n                }\n            }\n        }\n        me.collapse();\n    }\n});\n</code></pre>\n<h3 id=\"uniquetextfield\">UniqueTextField</h3>\n<p><strong>唯一值文本框</strong></p>\n<h4 id=\"-\">适用场景</h4>\n<p>其实这个使用范围挺广,但是我现在这样写泛用泛用性不高.\n主要是使用了异步校验的方式来校验email,username之类是否能使用.</p>\n<blockquote>\n<p>实现上跟ptype不一样,因为ptype还需要另外自定义一遍.\n所以还是使用onchange就触发的validator来执行\n将值通过Ajax发送到后台校验,然后通过field.markInValid方法来进行invalid的校验.</p>\n</blockquote>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Ext.component.UniqueTextField&#39;,{\n    extend:&#39;Ext.form.field.Text&#39;,\n    alias:&#39;widget.uniquetextfield&#39;,\n    msgTarget:&#39;side&#39;,\n\n    duplicateType:&#39;&#39;,\n\n    //vtype:&#39;alphanum&#39;,\n\n\n    validator:function(){\n        var self=this;\n        if(null==self.duplicateType||self.duplicateType==&#39;&#39;){\n            return true;\n        }\n        return self.validateByDuplicateType(self.duplicateType);\n    },\n\n\n    /*\n    *    Default Configuration\n    *    can override and customize it.\n    *\n    * */\n    validateEmailUrl:ctx+&#39;/rest/user/validate/email&#39;,\n    validateCompanyNameUrl:ctx+&#39;/rest/user/validate/companyName&#39;,\n    validateUserIdUrl:ctx+&#39;/rest/user/validate/userId&#39;,\n\n    validateByDuplicateType:function(duplicateType){\n        var self=this;\n        var validateValue=self.getValue();\n        var validateUrl=function(){\n            if(duplicateType==&#39;email&#39;)return self.validateEmailUrl;\n            else if(duplicateType==&#39;userId&#39;)return self.validateUserIdUrl;\n            else return self.validateCompanyNameUrl;\n        };\n\n        var validateFlag=true;\n        //start tip area masking\n        Ext.Ajax.request({\n            url:validateUrl,\n            method:&#39;GET&#39;,\n            timeout:6000,\n            params:{\n                fieldValue:validateValue\n            },\n            success:function(response){\n                var responseMessage=Ext.decode(response.responseText);\n                //remove tip area masking and show the validate result\n                if(responseMessage.status==&#39;success&#39;){\n                    validateFlag=true;\n                }\n                else{\n                    validateFlag=responseMessage.reason;\n                    self.markInvalid(validateFlag);\n                }\n            }\n        });\n\n        return validateFlag;\n    }\n\n});\n</code></pre>\n<h3 id=\"customdatefield\">CustomDateField</h3>\n<p><strong>自定义存取与后台格式匹配的datefield,datecolumn</strong></p>\n<h4 id=\"-\">背景</h4>\n<p>因为项目CRUD经常需要将页面上的时间存取成与后台匹配的数据格式,所以就自己定义了一些\n前后端匹配互相转换的组件.没什么参考意义,只是觉得在View里面每一个<code>datefield</code>,<code>datecolumn</code>都通过<code>render:function()</code>的方式去写转换逻辑太不优雅了</p>\n<pre><code class=\"undefinedJavaScript\">Ext.define(&#39;Ext.component.DateField&#39;,{\n    extend: &#39;Ext.form.field.Date&#39;,\n    alias: &#39;widget.customdatefield&#39;,//不使用驼峰是因为 Component 名默认就是全小写\n    format:&#39;Y-m-d:Hi&#39;,\n    altFormats:&#39;YmdHis.u&#39;,\n    displayFormat:&#39;Y-m-d&#39;,\n    valueFormat:&#39;YmdHis.u&#39;,\n    initComponent: function() {\n        var self=this;\n        var value = this.value ||Ext.Date.clearTime(new Date());\n        value = Ext.Date.format(value,self.format);\n        this.callParent();\n        this.value = value;\n    },\n\n    onSelect:function(field,value){\n        var self=this;\n        self.setValue(Ext.util.Format.date(value,self.valueFormat));\n        self.callParent(arguments);\n    },\n    setValue:function(value){\n        var self=this;\n        self.callParent(arguments);\n    },\n    getValue:function(){\n        var self=this;\n        var dateString=Ext.Date.parse(self.getRawValue(),self.format);\n        var returnValue=Ext.util.Format.date(dateString,self.valueFormat);\n        return returnValue;\n    }\n});\n</code></pre>\n<h2 id=\"-\">总结</h2>\n<p>通过这段时间的项目学习,无论是前端还是后端都开始有了更深一层的认识.\n从不知道如何实现,到如何实现得优雅,贴合框架本身,不造无谓轮子的角度来看,可以总结出一些使用ExtJS的经验.</p>\n<h3 id=\"-\">多看官方文档</h3>\n<p><a href=\"http://docs.sencha.com/extjs/4.2.2/#!/guide/application_architecture\">官方文档</a>\n不要看所谓的<code>脚本娃娃</code>之流的汉化版.缺经断骨,看了还以为ExtJS本身没有这个方法或者事件,需要自己去实现呢\n在了解已有API功能的情况下再尝试增加新的轮子</p>\n<h3 id=\"-\">多横向比较</h3>\n<p>大半年前接触ExtJS的时候,当时觉得使用ExtJS的产品比较少,市场占有率少,感觉像是学了个并没有什么卵用的技术.</p>\n<p>跟之前接触的AngularJS,与普遍的JQuery相比,当然没有一些方便的功能.\n但是当我接触了JavaScript OOP编程,了解到prototype等概念之后,我开始感觉到ExtJS强大的类库与组件的使用也是相当好的JavaScript的学习时机.\n得益于idea本身的代码分析功能,自动找出代码中复写到的ExtJS组件的部分,让我开始阅读其组件的源码实现,获益良多.\n对JS的认识进展得相当快.</p>\n<p>通过了解其他不同的前端框架,不管是阅读还是实际取去用,增加一下技术广度 后面就不会逼逼这项技术好low了.</p>\n<p>通过了解其他不同的前端框架,不管是阅读还是实际去用,增加以下技术广度,后面就不会逼逼</p>\n"},{"link":"2016/04/10/google-codejam-2016-qualification-round","title":"Google CodeJam 2016 Qualification","published":"2016-04-10T09:30:55.000Z","tags":["Java","Google"],"html":"<p>今早结束的Google CodeJam 2016资格赛.\n由于智商问题和加班了一天,所以只能水出前面两道水题.\n但是还是稍微涨了点姿势.\n记录下解题的过程和一些小彩蛋.</p>\n<p>将我的A和B的Solution放在<a href=\"https://github.com/Aquariuslt/CodeJam\">Github</a>上了.</p>\n<h2 id=\"a-counting-sheep\">A: Counting Sheep</h2>\n<h3 id=\"problem-description\">Problem Description</h3>\n<p>Bleatrix Trotter the sheep has devised a strategy that helps her fall asleep faster. First, she picks a number N. Then she starts naming N, 2 × N, 3 × N, and so on. Whenever she names a number, she thinks about all of the digits in that number. She keeps track of which digits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far as part of any number she has named. Once she has seen each of the ten digits at least once, she will fall asleep.</p>\n<p>Bleatrix must start with N and must always name (i + 1) × N directly after i × N. For example, suppose that Bleatrix picks N = 1692. She would count as follows:</p>\n<p>N = 1692. Now she has seen the digits 1, 2, 6, and 9.\n2N = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9.\n3N = 5076. Now she has seen all ten digits, and falls asleep.\nWhat is the last number that she will name before falling asleep? If she will count forever, print INSOMNIA instead.</p>\n<p>Input</p>\n<p>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line with a single integer N, the number Bleatrix has chosen.</p>\n<p>Output</p>\n<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the last number that Bleatrix will name before falling asleep, according to the rules described in the statement.</p>\n<p>Limits</p>\n<p>1 ≤ T ≤ 100.\nSmall dataset</p>\n<p>0 ≤ N ≤ 200.\nLarge dataset</p>\n<p>0 ≤ N ≤ 10^6.\nSample</p>\n<p>Input</p>\n<pre><code>5\n0\n1\n2\n11\n1692\n</code></pre><p>Output</p>\n<pre><code>Case #1: INSOMNIA\nCase #2: 10\nCase #3: 90\nCase #4: 110\nCase #5: 5076\n</code></pre><p>In Case #1, since 2 × 0 = 0, 3 × 0 = 0, and so on, Bleatrix will never see any digit other than 0, and so she will count forever and never fall asleep. Poor sheep!\nIn Case #2, Bleatrix will name 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. The 0 will be the last digit needed, and so she will fall asleep after 10.\nIn Case #3, Bleatrix will name 2, 4, 6... and so on. She will not see the digit 9 in any number until 90, at which point she will fall asleep. By that point, she will have already seen the digits 0, 1, 2, 3, 4, 5, 6, 7, and 8, which will have appeared for the first time in the numbers 10, 10, 2, 30, 4, 50, 6, 70, and 8, respectively.\nIn Case #4, Bleatrix will name 11, 22, 33, 44, 55, 66, 77, 88, 99, 110 and then fall asleep.\nCase #5 is the one described in the problem statement. Note that it would only show up in the Large dataset, and not in the Small dataset.</p>\n<h3 id=\"translation\">Translation</h3>\n<p>这道题相当容易读懂,表面意思就是:\n一个叫<code>Bleatrix</code>的家伙睡觉之前喜欢数羊咩,但是他要数到一定条件才睡得着.\n他每次会从一个数字<code>N</code>开始数.第一下数<code>N</code>,第二下数<code>2*N</code>...第M下数<code>M*N</code>.\n当从开始数到后面,一直到出现过的数字包含了<code>1234567890</code>所有数字的时候就会睡着了.\n求的是数字<code>N</code>对应的让他能够睡着的那个数.</p>\n<h3 id=\"solution\">Solution</h3>\n<p>做法是用一个从N开始枚举.\n出现过的数字用<code>HashSet</code>来保存,每出现一个数字的时候,将该数字按照每一位拆分,打进这个<code>HashSet</code>里面.\n当<code>HashSet</code>的长度大于等于10的时候跳出循环.</p>\n<h3 id=\"source-code\">Source Code</h3>\n<pre><code class=\"undefinedjava\">package com.aquariuslt.codejam;\n\nimport com.aquariuslt.codejam.utils.Reader;\n\nimport org.junit.Test;\n\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/** Created by Aquariuslt on 4/9/16.*/\npublic class CountingSheep {\n    private static int numberOfCases;\n    private static int startSheepNumber[];\n    private static int result[];\n\n\n    private static void input(){\n        InputStream inputStream = ClassLoader.getSystemResourceAsStream(&quot;A/A-large.in&quot;);\n        Reader.init(inputStream);\n        try{\n            numberOfCases = Reader.nextInt();\n            startSheepNumber = new int[numberOfCases];\n            result = new int[numberOfCases];\n            for(int i=0;i&lt;numberOfCases;i++){\n                startSheepNumber[i] = Reader.nextInt();\n            }\n        }\n        catch (Exception e){\n            //Do nothing\n        }\n\n    }\n\n    private static void solve(){\n        for(int i=0;i&lt;numberOfCases;i++){\n            result[i] = solveSingleNumber(startSheepNumber[i]);\n        }\n    }\n\n    private static int solveSingleNumber(int singleNumber){\n        Set&lt;Integer&gt; digitalSet = new HashSet&lt;&gt;();\n        if(singleNumber==0){\n            return 0;\n        }\n        else{\n            int currentNumber = singleNumber;\n            while(digitalSet.size()&lt;10){\n                digitalSet.addAll(convertIntToDigitalSet(currentNumber));\n                currentNumber += singleNumber;\n            }\n            return currentNumber;\n        }\n    }\n\n    private static Set&lt;Integer&gt; convertIntToDigitalSet(int number){\n        int currentNumber = number;\n        Set&lt;Integer&gt; digitalSet = new HashSet&lt;&gt;();\n        while(currentNumber/10&gt;0){\n            digitalSet.add(currentNumber % 10);\n            currentNumber = currentNumber/10;\n        }\n        return digitalSet;\n    }\n\n    private static void output(){\n        for(int i=0;i&lt;numberOfCases;i++){\n            if(result[i] == 0){\n                System.out.printf(&quot;Case #%d: INSOMNIA\\n&quot;,(i+1));\n            }\n            else{\n                System.out.printf(&quot;Case #%d: %d\\n&quot;,(i+1),result[i]);\n            }\n        }\n    }\n\n\n    @Test\n    public void testCountingSheep() {\n        input();\n        solve();\n        output();\n    }\n}\n</code></pre>\n<h2 id=\"b-revenge-of-the-pancakes\">B: Revenge of the Pancakes</h2>\n<h3 id=\"problem-description\">Problem Description</h3>\n<p>The Infinite House of Pancakes has just introduced a new kind of pancake! It has a happy face made of chocolate chips on one side (the &quot;happy side&quot;), and nothing on the other side (the &quot;blank side&quot;).</p>\n<p>You are the head waiter on duty, and the kitchen has just given you a stack of pancakes to serve to a customer. Like any good pancake server, you have X-ray pancake vision, and you can see whether each pancake in the stack has the happy side up or the blank side up. You think the customer will be happiest if every pancake is happy side up when you serve them.</p>\n<p>You know the following maneuver: carefully lift up some number of pancakes (possibly all of them) from the top of the stack, flip that entire group over, and then put the group back down on top of any pancakes that you did not lift up. When flipping a group of pancakes, you flip the entire group in one motion; you do not individually flip each pancake. Formally: if we number the pancakes 1, 2, ..., N from top to bottom, you choose the top i pancakes to flip. Then, after the flip, the stack is i, i-1, ..., 2, 1, i+1, i+2, ..., N. Pancakes 1, 2, ..., i now have the opposite side up, whereas pancakes i+1, i+2, ..., N have the same side up that they had up before.</p>\n<p>For example, let&#39;s denote the happy side as + and the blank side as -. Suppose that the stack, starting from the top, is --+-. One valid way to execute the maneuver would be to pick up the top three, flip the entire group, and put them back down on the remaining fourth pancake (which would stay where it is and remain unchanged). The new state of the stack would then be -++-. The other valid ways would be to pick up and flip the top one, the top two, or all four. It would not be valid to choose and flip the middle two or the bottom one, for example; you can only take some number off the top.</p>\n<p>You will not serve the customer until every pancake is happy side up, but you don&#39;t want the pancakes to get cold, so you have to act fast! What is the smallest number of times you will need to execute the maneuver to get all the pancakes happy side up, if you make optimal choices?</p>\n<p>Input</p>\n<p>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of one line with a string S, each character of which is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up). The string, when read left to right, represents the stack when viewed from top to bottom.</p>\n<p>Output</p>\n<p>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of times you will need to execute the maneuver to get all the pancakes happy side up.</p>\n<p>Limits</p>\n<p>1 ≤ T ≤ 100.\nEvery character in S is either + or -.</p>\n<p>Small dataset</p>\n<p>1 ≤ length of S ≤ 10.\nLarge dataset</p>\n<p>1 ≤ length of S ≤ 100.\nSample</p>\n<p>Input</p>\n<pre><code>5\n-\n-+\n+-\n+++\n--+-\n</code></pre><p>Output</p>\n<pre><code>Case #1: 1\nCase #2: 1\nCase #3: 2\nCase #4: 0\nCase #5: 3\n</code></pre><p>In Case #1, you only need to execute the maneuver once, flipping the first (and only) pancake.\nIn Case #2, you only need to execute the maneuver once, flipping only the first pancake.\nIn Case #3, you must execute the maneuver twice. One optimal solution is to flip only the first pancake, changing the stack to --, and then flip both pancakes, changing the stack to ++. Notice that you cannot just flip the bottom pancake individually to get a one-move solution; every time you execute the maneuver, you must select a stack starting from the top.\nIn Case #4, all of the pancakes are already happy side up, so there is no need to do anything.(这里他们打错成<code>anthing</code>了.)\nIn Case #5, one valid solution is to first flip the entire stack of pancakes to get +-++, then flip the top pancake to get --++, then finally flip the top two pancakes to get ++++.</p>\n<h3 id=\"translation\">Translation</h3>\n<p>这道题原意是这样子的:\n大概就是翻蛋糕.给出一个字符串,只包含<code>-</code>和<code>+</code>两个部分 分别代表正面和反面.\n如果给出的字符串是<code>--+-</code>\n那么在实际中,蛋糕的摆放会是这样子的:</p>\n<p>反面朝上\n反面朝上\n正面朝上\n反面朝上\n<em>---我是底盘---</em>\n<em>-我是伺应的手-</em></p>\n<p>有一个铲子每次都能够在两层蛋糕之间插入,然后将这个铲上面的所有蛋糕一次铲起来!\n接着将这些铲起来的蛋糕连着一起反过来,再放回盘子上.</p>\n<p>目标是给出一个这样排列的蛋糕序列,求用铲子操作多少次能够将蛋糕全部变成向上的状态.</p>\n<h3 id=\"solution\">Solution</h3>\n<p>有一种思路就是从右往左开始遍历,当遇到目前一个层次是反面的时候,就进行一次<code>翻面</code>操作.\n为了记录当前一个蛋糕的面实际是向上还是向下,我设定了一个flag与最原先输入的当前蛋糕面状态进行异或操作,得到当前面的状态.</p>\n<p>即</p>\n<pre><code>private int solveSingleCase(int[] pancakeArray) {\n    int revengeCount = 0;\n    int revengeFlag = 0;\n    for (int pancakeLength = pancakeArray.length, i = pancakeLength - 1; i &gt;= 0; i--) {\n        if ((pancakeArray[i] ^ revengeFlag) == 0) { //通过异或得出当前的面实际朝向.\n            revengeCount++;\n            revengeFlag = 1 - revengeFlag;\n        }\n    }\n    return revengeCount;\n}\n</code></pre><h3 id=\"source-code\">Source Code</h3>\n<pre><code class=\"undefinedjava\">package com.aquariuslt.codejam;\n\nimport com.aquariuslt.codejam.utils.Reader;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/** Created by Aquariuslt on 4/9/16.*/\npublic class RevengePancakes {\n    private static final int MAX_STRING_LENGTH = 101;\n\n    private int caseCount;\n    private int[][] pancakeIntArray;\n    private int[] result;\n\n    private void input() {\n        InputStream inputStream = ClassLoader.getSystemResourceAsStream(&quot;B/B-large.in&quot;);\n        Reader.init(inputStream);\n        try {\n            caseCount = Reader.nextInt();\n            result = new int[caseCount];\n            pancakeIntArray = new int[caseCount][MAX_STRING_LENGTH];\n            for (int i = 0; i &lt; caseCount; i++) {\n                String currentPancakeString = Reader.next();\n                pancakeIntArray[i] = convertStringToInt(currentPancakeString);\n            }\n        } catch (IOException e) {\n            //e.printStackTrace();\n        }\n\n    }\n\n    private int[] convertStringToInt(String currentPancakeString) {\n        int currentPancakeStringLength = currentPancakeString.length();\n        int[] currentPancakeIntArray = new int[currentPancakeStringLength];\n        for (int i = 0, strLength = currentPancakeString.length(); i &lt; strLength; i++) {\n            currentPancakeIntArray[i] = currentPancakeString.charAt(i) == &#39;+&#39; ? 1 : 0;\n        }\n        return currentPancakeIntArray;\n    }\n\n    private void solve() {\n        for (int i = 0, length = result.length; i &lt; length; i++) {\n            result[i] = solveSingleCase(pancakeIntArray[i]);\n        }\n    }\n\n    private int solveSingleCase(int[] pancakeArray) {\n        int revengeCount = 0;\n        int revengeFlag = 0;\n        for (int pancakeLength = pancakeArray.length, i = pancakeLength - 1; i &gt;= 0; i--) {\n            if ((pancakeArray[i] ^ revengeFlag) == 0) {\n                revengeCount++;\n                revengeFlag = 1 - revengeFlag;\n            }\n        }\n        return revengeCount;\n    }\n\n    private void output() {\n        for (int i = 0; i &lt; caseCount; i++) {\n            System.out.printf(&quot;Case #%d: %d\\n&quot;, (i + 1), result[i]);\n        }\n    }\n\n\n    @Test\n    public void testRevengePancakes() {\n        input();\n        solve();\n        output();\n    }\n}\n\n\n/**\n * if &#39;-&#39; means &#39;0&#39;, &#39;+&#39; means &#39;1&#39; we can convert case to: Case 1: input : -            0 target: +\n * 1\n *\n * Case 2: input : -+           01 target: ++           11\n *\n * Case 3: input : +-           10 target: ++           11\n *\n * Case 4: input : +++          111 target: +++          111\n *\n * Case 5: input : --+-         0010 target: ++++         1111\n */\n</code></pre>\n<h2 id=\"java-reader-in-acm\">Java Reader in ACM</h2>\n<p>本来一直在用<code>Java的Scanner做input</code>.\n但是一直没想过如果正式比赛还真的有人用Java去提交,那么<code>Scanner</code>的性能到底如何呢.\n很久之前看过一篇文章比较<code>cin</code>和<code>scanf</code>的性能.\n然后看到了这篇文章,通过数据比较高呼<code>Java Scanner is Slooooow</code></p>\n<p><a href=\"https://www.cpe.ku.ac.th/~jim/java-io.html\">Faster Input for Java</a></p>\n<p>通过比较Java的<code>Scanner</code>与<code>BufferedReader</code> + <code>StringTokenizer</code>来比较性能的话.\n证明了<code>Scanner</code>读入输入流相对要慢4倍.</p>\n<p>所以我在代码里面第一次使用了这种方式</p>\n<pre><code class=\"undefinedjava\">public class Reader {\n    private static BufferedReader reader;\n    private static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    public static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(&quot;&quot;);\n    }\n\n    /** get next word */\n    public static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}\n</code></pre>\n<p>然后将输入文件放在resource里面,将输入流直接改成resource即可.\nUsage:</p>\n<pre><code class=\"undefinedjava\">public class CountingSheep{\n\n    private static void input(){\n        InputStream inputStream = ClassLoader.getSystemResourceAsStream(&quot;A/A-large.in&quot;);\n        Reader.init(inputStream);\n        try{\n            numberOfCases = Reader.nextInt();\n            startSheepNumber = new int[numberOfCases];\n            result = new int[numberOfCases];\n            for(int i=0;i&lt;numberOfCases;i++){\n                startSheepNumber[i] = Reader.nextInt();\n            }\n        }\n        catch (Exception e){\n            //Do nothing\n        }\n    }\n}\n</code></pre>\n"},{"link":"2014/10/11/google-java-code-style","title":"[转]Google Java Code Style","published":"2014-10-11T06:15:47.000Z","tags":["Google","Java"],"html":"<p>规范代码，做个爱整洁的强迫症患者。</p>\n<p>&nbsp;</p>\n<h1 id=\"-google-java-http-hawstein-com-posts-google-java-style-html-\"><a href=\"http://hawstein.com/posts/google-java-style.html\">Google Java编程风格指南</a></h1>\n<div class=\"authoring\">January 20, 2014</div>\n<div>作者：Hawstein\n出处：<a href=\"http://hawstein.com/posts/google-java-style.html\">http://hawstein.com/posts/google-java-style.html</a>\n声明：本文采用以下协议进行授权： <a href=\"http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh\">自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0</a> ，转载请注明作者及出处。</div>\n\n<h2 id=\"-\">目录</h2>\n<ol>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#Intro\">前言</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#SFBasic\">源文件基础</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#SFStruct\">源文件结构</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#Format\">格式</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#Naming\">命名约定</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#Practice\">编程实践</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#Javadoc\">Javadoc</a></li>\n<li><a href=\"http://hawstein.com/posts/google-java-style.html#End\">后记</a></li>\n</ol>\n<h2 id=\"-a-id-intro-a-\"><a id=\"Intro\"></a>前言</h2>\n<p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p>\n<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p>\n<h3 id=\"1-1-\">1.1 术语说明</h3>\n<p>在本文档中，除非另有说明：</p>\n<ol>\n<li>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)</li>\n<li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。\n其他的术语说明会偶尔在后面的文档出现。</li>\n</ol>\n<h3 id=\"1-2-\">1.2 指南说明</h3>\n<p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>\n<h2 id=\"-a-id-sfbasic-a-\"><a id=\"SFBasic\"></a>源文件基础</h2>\n<h3 id=\"2-1-\">2.1 文件名</h3>\n<p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>\n<h3 id=\"2-2-utf-8\">2.2 文件编码：UTF-8</h3>\n<p>源文件编码格式为UTF-8。</p>\n<h3 id=\"2-3-\">2.3 特殊字符</h3>\n<h4 id=\"2-3-1-\">2.3.1 空白字符</h4>\n<p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>\n<ol>\n<li>所有其它字符串中的空白字符都要进行转义。</li>\n<li>制表符不用于缩进。</li>\n</ol>\n<h4 id=\"2-3-2-\">2.3.2 特殊转义序列</h4>\n<p>对于具有特殊<a href=\"http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97\">转义序列</a>的任何字符(b, t, n, f, r, “, ‘及)，我们使用它的转义序列，而不是相应的八进制(比如<code>\u000012</code>)或Unicode(比如<code>u000a</code>)转义。</p>\n<h4 id=\"2-3-3-ascii-\">2.3.3 非ASCII字符</h4>\n<p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如u221e)，取决于哪个能让代码更易于阅读和理解。</p>\n<blockquote>\n<blockquote>\n<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。\n例如：</p>\n</blockquote>\n</blockquote>\n<pre><code>String unitAbbrev = &quot;μs&quot;;                                 | 赞，即使没有注释也非常清晰\nString unitAbbrev = &quot;u03bcs&quot;; // &quot;μs&quot;                    | 允许，但没有理由要这样做\nString unitAbbrev = &quot;u03bcs&quot;; // Greek letter mu, &quot;s&quot;    | 允许，但这样做显得笨拙还容易出错\nString unitAbbrev = &quot;u03bcs&quot;;                            | 很糟，读者根本看不出这是什么\nreturn &#39;ufeff&#39; + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释\n`&lt;/pre&gt;\n&gt; &gt; Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)\n\n## &lt;a id=&quot;SFStruct&quot;&gt;&lt;/a&gt;源文件结构\n\n一个源文件包含(按顺序地)：\n</code></pre><ol>\n<li>许可证或版权信息(如有需要)</li>\n<li>package语句</li>\n<li>import语句</li>\n<li><p>一个顶级类(<strong>只有一个</strong>)\n以上每个部分之间用一个空行隔开。</p>\n<h3 id=\"3-1-\">3.1 许可证或版权信息</h3>\n<p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>\n<h3 id=\"3-2-package-\">3.2 package语句</h3>\n<p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>\n<h3 id=\"3-3-import-\">3.3 import语句</h3>\n<h4 id=\"3-3-1-import-\">3.3.1 import不要使用通配符</h4>\n<p>即，不要出现类似这样的import语句：<code>import java.util.*;</code></p>\n<h4 id=\"3-3-2-\">3.3.2 不要换行</h4>\n<p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>\n<h4 id=\"3-3-3-\">3.3.3 顺序和间距</h4>\n<p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>\n</li>\n<li><p>所有的静态导入独立成组</p>\n</li>\n<li><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)</li>\n<li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li>\n<li><code>java</code> imports</li>\n<li><p><code>javax</code> imports\n组内不空行，按字典序排列。</p>\n<h3 id=\"3-4-\">3.4 类声明</h3>\n<h4 id=\"3-4-1-\">3.4.1 只有一个顶级类声明</h4>\n<p>每个顶级类都在一个与它同名的源文件中(当然，还包含<code>.java</code>后缀)。</p>\n<p>例外：<code>package-info.java</code>，该文件中可没有<code>package-info</code>类。</p>\n<h4 id=\"3-4-2-\">3.4.2 类成员顺序</h4>\n<p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>\n<h5 id=\"3-4-2-1-\">3.4.2.1 重载：永不分离</h5>\n<p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>\n<h2 id=\"-a-id-format-a-\"><a id=\"Format\"></a>格式</h2>\n<p><strong>术语说明</strong>：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>\n<h3 id=\"4-1-\">4.1 大括号</h3>\n<h4 id=\"4-1-1-\">4.1.1 使用大括号(即使是可选的)</h4>\n<p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>\n<h4 id=\"4-1-2-k-amp-r-\">4.1.2 非空块：K &amp; R 风格</h4>\n<p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href=\"http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html\">Egyptian brackets</a>):</p>\n</li>\n<li><p>左大括号前不换行</p>\n</li>\n<li>左大括号后换行</li>\n<li>右大括号前换行</li>\n<li><p>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。\n示例：</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n        &lt;span class=&quot;n&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProblemException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n        &lt;span class=&quot;n&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;</code></pre>\n</div>\n4.8.1节给出了enum类的一些例外。\n\n#### 4.1.3 空块：可以用简洁版本\n\n一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。\n\n示例：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doNothing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;</code></pre>\n</div>\n\n<h3 id=\"4-2-2-\">4.2 块缩进：2个空格</h3>\n<p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>\n<h3 id=\"4-3-\">4.3 一行一个语句</h3>\n<p>每个语句后要换行。</p>\n<h3 id=\"4-4-80-100\">4.4 列限制：80或100</h3>\n<p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>\n<p>例外：</p>\n</li>\n<li><p>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</p>\n</li>\n<li><code>package</code>和<code>import</code>语句(见3.2节和3.3节)。</li>\n<li><p>注释中那些可能被剪切并粘贴到shell中的命令行。</p>\n<h3 id=\"4-5-\">4.5 自动换行</h3>\n<p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>\n<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>\n<blockquote>\n<blockquote>\n<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>\n</blockquote>\n</blockquote>\n<h4 id=\"4-5-1-\">4.5.1 从哪里断开</h4>\n<p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>\n</li>\n<li><p>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&amp;lt;T extends Foo &amp;amp; Bar&amp;gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</p>\n</li>\n<li>如果在<code>赋值运算符</code>处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>\n<li>方法名或构造函数名与左括号留在同一行。</li>\n<li><p>逗号(,)与其前面的内容留在同一行。</p>\n<h4 id=\"4-5-2-4-\">4.5.2 自动换行时缩进至少+4个空格</h4>\n<p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>\n<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>\n<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>\n<h3 id=\"4-6-\">4.6 空白</h3>\n<h4 id=\"4-6-1-\">4.6.1 垂直空白</h4>\n<p>以下情况需要使用一个空行：</p>\n</li>\n<li><p>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。</p>\n<pre><code>*   **例外**：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。\n</code></pre></li>\n<li>在函数体内，语句的逻辑分组间使用空行。</li>\n<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>\n<li><p>要满足本文档中其他节的空行要求(比如3.3节：import语句)\n多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p>\n<h4 id=\"4-6-2-\">4.6.2 水平空白</h4>\n<p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>\n</li>\n<li><p>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</p>\n</li>\n<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>\n<li><p>在任何左大括号前(<code>{</code>)，两个例外：</p>\n<pre><code>*   `@SomeAnnotation({a, b})`(不使用空格)。\n</code></pre><ul>\n<li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>\n</ul>\n</li>\n<li><p>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</p>\n<pre><code>*   类型界限中的&amp;amp;(`&amp;lt;T extends Foo &amp;amp; Bar&amp;gt;`)。\n</code></pre><ul>\n<li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>\n<li><code>foreach</code>语句中的分号。</li>\n</ul>\n</li>\n<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>\n<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>\n<li>类型和变量之间：List list。</li>\n<li><p>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</p>\n<blockquote>\n<blockquote>\n<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"4-6-3-\">4.6.3 水平对齐：不做要求</h4>\n<p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>\n<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>\n<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this is fine&lt;/span&gt;\n&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this too&lt;/span&gt;\n\n&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// permitted, but future edits&lt;/span&gt;\n&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// may leave it unaligned&lt;/span&gt;</code></pre>\n</div>\n&gt; &gt; Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。\n\n### 4.7 用小括号来限定组：推荐\n\n除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。\n\n### 4.8 具体结构\n\n#### 4.8.1 枚举类\n\n枚举常量间用逗号隔开，换行可选。\n\n没有方法和文档的枚举类可写成数组初始化的格式：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Suit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CLUBS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEARTS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPADES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DIAMONDS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。\n\n#### 4.8.2 变量声明\n\n##### 4.8.2.1 每次只声明一个变量\n\n不要使用组合声明，比如<code>int a, b;</code>。\n\n##### 4.8.2.2 需要时才声明，并尽快进行初始化\n\n不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。\n\n#### 4.8.3 数组\n\n##### 4.8.3.1 数组初始化：可写成块状结构\n\n数组初始化可以写成块状结构，比如，下面的写法都是OK的：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; \n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n\n&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n\n&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;\n  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n\n&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;\n    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n\n<h5 id=\"4-8-3-2-c-\">4.8.3.2 非C风格的数组声明</h5>\n<p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p>\n<h4 id=\"4-8-4-switch-\">4.8.4 switch语句</h4>\n<p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(<code>case FOO:</code>或<code>default:</code>)，后面跟着一条或多条语句。</p>\n<h5 id=\"4-8-4-1-\">4.8.4.1 缩进</h5>\n<p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>\n<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>\n<h5 id=\"4-8-4-2-fall-through-\">4.8.4.2 Fall-through：注释</h5>\n<p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;\n  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;\n    &lt;span class=&quot;n&quot;&gt;prepareOneOrTwo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n    &lt;span class=&quot;c1&quot;&gt;// fall through&lt;/span&gt;\n  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;\n    &lt;span class=&quot;n&quot;&gt;handleOneTwoOrThree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;\n  &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;\n    &lt;span class=&quot;n&quot;&gt;handleLargeNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n\n<h5 id=\"4-8-4-3-default-\">4.8.4.3 default的情况要写出来</h5>\n<p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>\n<h4 id=\"4-8-5-annotations-\">4.8.5 注解(Annotations)</h4>\n<p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;\n&lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt;\n&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNameIfPresent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n<strong>例外</strong>：单个的注解可以和签名的第一行出现在同一行。例如：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;nd&quot;&gt;@Partial&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Mock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DataLoader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;</code></pre>\n</div>\n参数和局部变量注解没有特定规则。\n\n#### 4.8.6 注释\n\n##### 4.8.6.1 块注释风格\n\n块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... */</code>风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<code>*</code>开始， 并且与前一行的<code>*</code>对齐。以下示例注释都是OK的。\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;cm&quot;&gt;/*&lt;/span&gt;\n&lt;span class=&quot;cm&quot;&gt; * This is          // And so           /* Or you can&lt;/span&gt;\n&lt;span class=&quot;cm&quot;&gt; * okay.            // is this.          * even do this. */&lt;/span&gt;\n &lt;span class=&quot;o&quot;&gt;*/&lt;/span&gt;</code></pre>\n</div>\n注释不要封闭在由星号或其它字符绘制的框架里。\n&gt; &gt; Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。\n\n#### 4.8.7 Modifiers\n\n类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;strictfp&lt;/span&gt;</code></pre>\n</div>\n\n<h2 id=\"-a-id-naming-a-\"><a id=\"Naming\"></a>命名约定</h2>\n<h3 id=\"5-1-\">5.1 对所有标识符都通用的规则</h3>\n<p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>w+</code>。</p>\n<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>\n<h3 id=\"5-2-\">5.2 标识符类型的规则</h3>\n<h4 id=\"5-2-1-\">5.2.1 包名</h4>\n<p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>\n<h4 id=\"5-2-2-\">5.2.2 类名</h4>\n<p>类名都以<code>UpperCamelCase</code>风格编写。</p>\n<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>\n<p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>\n<h4 id=\"5-2-3-\">5.2.3 方法名</h4>\n<p>方法名都以<code>lowerCamelCase</code>风格编写。</p>\n<p>方法名通常是动词或动词短语。</p>\n<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&amp;lt;MethodUnderTest&amp;gt;_&amp;lt;state&amp;gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>\n<h4 id=\"5-2-4-\">5.2.4 常量名</h4>\n<p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>\n<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不<code>打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。\n<div class=\"highlight\">\n<pre>`<span class=\"c1\">// Constants</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">NUMBER</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">ImmutableList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">NAMES</span> <span class=\"o\">=</span> <span class=\"n\">ImmutableList</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"s\">&quot;Ed&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;Ann&quot;</span><span class=\"o\">);</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Joiner</span> <span class=\"n\">COMMA_JOINER</span> <span class=\"o\">=</span> <span class=\"n\">Joiner</span><span class=\"o\">.</span><span class=\"na\">on</span><span class=\"o\">(</span><span class=\"sc\">&#39;,&#39;</span><span class=\"o\">);</span>  <span class=\"c1\">// because Joiner is immutable</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">SomeMutableType</span><span class=\"o\">[]</span> <span class=\"n\">EMPTY_ARRAY</span> <span class=\"o\">=</span> <span class=\"o\">{};</span>\n<span class=\"kd\">enum</span> <span class=\"n\">SomeEnum</span> <span class=\"o\">{</span> <span class=\"n\">ENUM_CONSTANT</span> <span class=\"o\">}</span></p>\n<p><span class=\"c1\">// Not constants</span>\n<span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"n\">nonFinal</span> <span class=\"o\">=</span> <span class=\"s\">&quot;non-final&quot;</span><span class=\"o\">;</span>\n<span class=\"kd\">final</span> <span class=\"n\">String</span> <span class=\"n\">nonStatic</span> <span class=\"o\">=</span> <span class=\"s\">&quot;non-static&quot;</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">mutableCollection</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;();</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">ImmutableSet</span><span class=\"o\">&lt;</span><span class=\"n\">SomeMutableType</span><span class=\"o\">&gt;</span> <span class=\"n\">mutableElements</span> <span class=\"o\">=</span> <span class=\"n\">ImmutableSet</span><span class=\"o\">.</span><span class=\"na\">of</span><span class=\"o\">(</span><span class=\"n\">mutable</span><span class=\"o\">);</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Logger</span> <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">Logger</span><span class=\"o\">.</span><span class=\"na\">getLogger</span><span class=\"o\">(</span><span class=\"n\">MyClass</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">nonEmptyArray</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"s\">&quot;these&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;can&quot;</span><span class=\"o\">,</span> <span class=\"s\">&quot;change&quot;</span><span class=\"o\">};</span>\n`</pre>\n</div>\n这些名字通常是名词或名词短语。</p>\n<h4 id=\"5-2-5-\">5.2.5 非常量字段名</h4>\n<p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>\n<p>这些名字通常是名词或名词短语。</p>\n<h4 id=\"5-2-6-\">5.2.6 参数名</h4>\n<p>参数名以<code>lowerCamelCase</code>风格编写。</p>\n<p>参数应该避免用单个字符命名。</p>\n<h4 id=\"5-2-7-\">5.2.7 局部变量名</h4>\n<p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>\n<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>\n<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>\n<h4 id=\"5-2-8-\">5.2.8 类型变量名</h4>\n<p>类型变量可用以下两种风格之一进行命名：</p>\n</li>\n<li><p>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</p>\n</li>\n<li><p>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</p>\n<h3 id=\"5-3-camelcase-\">5.3 驼峰式命名法(CamelCase)</h3>\n<p><a href=\"http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB\">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如&quot;IPv6&quot;或&quot;iOS&quot;)。Google指定了以下的转换方案。</p>\n<p>名字从<code>散文形式</code>(prose form)开始:</p>\n</li>\n<li><p>把短语转换为纯ASCII码，并且移除任何单引号。例如：&quot;Müller’s algorithm&quot;将变成&quot;Muellers algorithm&quot;。</p>\n</li>\n<li><p>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</p>\n<pre><code>*   推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如&quot;AdWords&quot;将分割成&quot;ad words&quot;)。 需要注意的是&quot;iOS&quot;并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。\n</code></pre></li>\n<li><p>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</p>\n<pre><code>*   每个单词的第一个字母都大写，来得到大驼峰式命名。\n</code></pre><ul>\n<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>\n</ul>\n</li>\n<li><p>最后将所有的单词连接起来得到一个标识符。\n示例：</p>\n<h2 id=\"-pre-prose-form-correct-incorrect\"><pre>`Prose form                Correct               Incorrect</h2>\n<p>&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest\n&quot;new customer ID&quot;         newCustomerId         newCustomerID\n&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch\n&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS\n&quot;YouTube importer&quot;        YouTubeImporter</p>\n<pre><code>                      YoutubeImporter*\n</code></pre><p>`</pre>\n加星号处表示可以，但不推荐。</p>\n<blockquote>\n<blockquote>\n<p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：&quot;nonempty&quot;和&quot;non-empty&quot;都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"-a-id-practice-a-\"><a id=\"Practice\"></a>编程实践</h2>\n<h3 id=\"6-1-override-\">6.1 @Override：能用则用</h3>\n<p>只要是合法的，就把<code>@Override</code>注解给用上。</p>\n<h3 id=\"6-2-\">6.2 捕获的异常：不能忽视</h3>\n<p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p>\n<p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;\n  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleNumericResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumberFormatException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;c1&quot;&gt;// it&#39;s not numeric; that&#39;s fine, just continue&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;\n&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleTextResponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;</code></pre>\n</div>\n<strong>例外</strong>：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n  &lt;span class=&quot;n&quot;&gt;emptyStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n  &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NoSuchElementException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;\n&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n\n<h3 id=\"6-3-\">6.3 静态成员：使用类进行调用</h3>\n<p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aFoo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...;&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;Foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;aStaticMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// good&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;aFoo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;aStaticMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// bad&lt;/span&gt;\n&lt;span class=&quot;n&quot;&gt;somethingThatYieldsAFoo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;aStaticMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// very bad&lt;/span&gt;</code></pre>\n</div>\n\n<h3 id=\"6-4-finalizers-\">6.4 Finalizers: 禁用</h3>\n<p>极少会去重载<code>Object.finalize</code>。</p>\n<blockquote>\n<blockquote>\n<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href=\"http://books.google.com/books?isbn=8131726592\">Effective Java</a> 第7条款：“Avoid Finalizers”，然后不要使用它。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"-a-id-javadoc-a-javadoc\"><a id=\"Javadoc\"></a>Javadoc</h2>\n<h3 id=\"7-1-\">7.1 格式</h3>\n<h4 id=\"7-1-1-\">7.1.1 一般形式</h4>\n<p>Javadoc块的基本格式如下所示：\n<div class=\"highlight\">\n<pre><code>&lt;span class=&quot;cm&quot;&gt;/**&lt;/span&gt;\n&lt;span class=&quot;cm&quot;&gt; * Multiple lines of Javadoc text are written here,&lt;/span&gt;\n&lt;span class=&quot;cm&quot;&gt; * wrapped normally...&lt;/span&gt;\n&lt;span class=&quot;cm&quot;&gt; */&lt;/span&gt;\n&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;</code></pre>\n</div>\n或者是以下单行形式：\n<div class=\"highlight\">\n<pre>`<span class=\"cm\">/<em>* An especially short bit of Javadoc. </em>/</span></p>\n</li>\n</ol>\n<p></div>\n基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>\n<h4 id=\"7-1-2-\">7.1.2 段落</h4>\n<p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&amp;lt;p&amp;gt;</code>，并且它和第一个单词间没有空格。</p>\n<h4 id=\"7-1-3-javadoc-\">7.1.3 Javadoc标记</h4>\n<p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>\n<h3 id=\"7-2-\">7.2 摘要片段</h3>\n<p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>\n<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>\n<blockquote>\n<blockquote>\n<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"7-3-javadoc\">7.3 哪里需要使用Javadoc</h3>\n<p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>\n<h4 id=\"7-3-1-\">7.3.1 例外：不言自明的方法</h4>\n<p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>\n<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>\n<blockquote>\n<blockquote>\n<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"7-3-2-\">7.3.2 例外：重载</h4>\n<p>如果一个方法重载了超类中的方法，那么Javadoc并非必需的。</p>\n<h4 id=\"7-3-3-javadoc\">7.3.3 可选的Javadoc</h4>\n<p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>\n<p>&nbsp;</p>\n"},{"link":"2016/04/09/hadoop-2-7-2-single-node-and-cluster-mode-installation-guide","title":"Hadoop 2.7.2 单节点与集群安装部署","published":"2016-04-09T05:09:51.000Z","tags":["Hadoop","Linux"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近需要做一些大数据相关项目,至少需要搭建Hadoop的基本环境.\n由于用到的是目前版本号最高的Hadoop 2.7.2.跟文档比较多的2.6 以下的版本相比,在部署集群的时候遇见了很多坑.\n所以写一份安装指南,记录一下跌坑的过程,以示警惕.</p>\n<p>在环境搭建的过程中,参考了以下两篇文章:\n其中Apache的官方Wiki文档写的真难读.\n建议直接先看一遍aws的指南再动手.</p>\n<p><a href=\"https://wiki.apache.org/hadoop/GettingStartedWithHadoop\">https://wiki.apache.org/hadoop/GettingStartedWithHadoop</a>\n<a href=\"https://rstudio-pubs-static.s3.amazonaws.com/78508_abe89197267240dfb6f4facb361a20ed.html\">https://rstudio-pubs-static.s3.amazonaws.com/</a></p>\n<h2 id=\"table-of-content\">Table Of Content</h2>\n<p>暂不讨论Hadoop及基于其应用的场景描述,文本只讨论基本的环境搭建步骤和与之涉及的知识点.\n按照顺序总结出本文的内容节点.</p>\n<ol>\n<li>宏观了解在集群上部署Hadoop的过程</li>\n<li>虚拟机基本网络配置与机器配置</li>\n<li>下载并解压Hadoop</li>\n<li>创建专为运行Hadoop的用户</li>\n<li>环境变量的设定</li>\n<li>修改Hadoop配置文件</li>\n<li><p>启动Hadoop服务</p>\n</li>\n<li><p>防跌坑指南</p>\n</li>\n</ol>\n<h2 id=\"environment-setup\">Environment Setup</h2>\n<h3 id=\"overview-how-developer-deploy-hadoop-in-cluster-mode\">Overview: How Developer deploy Hadoop in cluster mode</h3>\n<p>通常来说,一个运维工程师是如何部署一个Hadoop集群呢?\n集群可以当成1台Master机器和多台Slaves机器.\n在全新的Linux机器群中创建Hadoop集群,按我的理解可以分成以下几步.</p>\n<ol>\n<li>在Master上下载 Hadoop,并修改对应的Hadoop配置文件.</li>\n<li>将修改好配置的Hadoop目录打包,分发到各个Slave中,解压到固定的执行目录.</li>\n<li>修改所有机器的hosts文件,将局域网中的所有ip-hostname进行mapping.</li>\n<li>在所有机器上安装ssh,Master和Slaves之间将通过ssh进行运行时的通讯控制.</li>\n<li>在Master上启动Hadoop服务.统一管理所有Slave节点.</li>\n</ol>\n<h3 id=\"network-and-information-about-virtual-machine\">Network and Information about Virtual Machine</h3>\n<p>因为只是实验集群的部署,所以没有用到真机.\n实际上虚拟机内部的多台机器所组成的集群,其实总的I/O还是会被物理机器限制.</p>\n<p>我将使用的是1台Master和两台Slaves\n三台机器都是<code>vmware</code>上的虚拟机,网络方式都是以NAT桥接\n具体的配置如下:</p>\n<ul>\n<li><p>Master:\nip:192.168.239.142\nhostname:elementary-os\ncpu:4 core\nram:16G</p>\n</li>\n<li><p>Slaves:\nip:192.168.239.144,192.168.239.145\nhostname:hd-worker-a,hd-worker-b\ncpu:1 core\nram:4G\nharddisk:20G</p>\n</li>\n</ul>\n<p>P.S. Master 和 Slaves 都是基于64位的<code>Ubuntu14.04.3LTS</code>内核的Linux.\n可以视为都是通过直接安装<code>Ubuntu14.04.3.LTS</code>.</p>\n<p>为了通过<code>/etc/hosts</code>文件通过机器名访问对应的ip,\n在每一个节点上面都修改对应的<code>/etc/hosts</code>文件,将集群中所有节点加到文件里面</p>\n<pre><code class=\"undefinedbash\">$ sudo vi /etc/hosts\n</code></pre>\n<p>在文件底部添加以下几行(实际操作中,请将hostname替换成自己实际机器的hostname与ip)</p>\n<pre><code># Hadoop Cluster Setup\n## Master\n192.168.239.142   elementary-os\n\n## Slaves\n192.168.239.144   hd-worker-a\n192.168.239.145   hd-worker-b\n</code></pre><h3 id=\"download-hadoop\">Download Hadoop</h3>\n<p>下载地址:<a href=\"http://mirrors.noc.im/apache/hadoop/common/current/\">http://mirrors.noc.im/apache/hadoop/common/current/</a></p>\n<p>下载之后,会得到一个<code>Hadoop2.7.2</code>的解压包.\n在下一步章节我们将会将其移动到其他目录.</p>\n<h3 id=\"add-hadoop-group-and-user\">Add Hadoop Group and User</h3>\n<p>在所有节点上都创建一个名为<code>hduser</code>的user,并将其加到sudo列表里面.\n在接下来的所有bash命令,默认都通过该创建的<code>hduser</code>来执行.</p>\n<pre><code>$ sudo addgroup hadoop\n$ sudo adduser --ingroup hadoop hduser\n$ sudo adduser hduser sudo\n</code></pre><h3 id=\"installing-ssh-and-copy-public-key-to-remote-machine\">Installing SSH and Copy Public Key to remote machine</h3>\n<p>什么是SSH\nSSH (“Secure SHell”) is a protocol for securely accessing one machine from another.\nHadoop uses SSH for accessing another slaves nodes to start and manage all HDFS and MapReduce daemons.\nHadoop通过ssh之间来通讯和管理节点之间的通讯.</p>\n<pre><code>$ sudo apt-get install openssh-server\n</code></pre><p>TIPS:\n通常来说,ssh远程到另一台安装了ssh的机器上,通过<code>ssh {username}@{hostname}</code>,之后输入密码便可以进入.\n对于一些自动化部署的脚本来说自动输入密码,还需要在脚本里面写下密码.\n怎么可能如此的不科学?</p>\n<p>所以需要通过ssh key公钥来进行认证,达到无密码传输的过程.\n假设我们需要在机器上A通过ssh远程到机器B且不需要密码,步骤如下:</p>\n<ol>\n<li><p>在机器A上生成自己的ssh公钥与密钥</p>\n<pre><code class=\"undefinedbash\">$ ssh-keygen -t rsa\n</code></pre>\n<p>此举将会在user目录下的<code>~/.ssh</code>文件夹创建对应的\n<code>id_rsa</code>和<code>id_rsa.pub</code>文件.\n其中<code>id_rsa.pub</code>就是公钥文件</p>\n</li>\n<li><p>在机器A上将自己的公钥复制到远程主机上</p>\n<pre><code class=\"undefinedbash\">$ ssh-copy-id {username}@B\n$ {username}@B password:\n$ #此时输入用户密码\n</code></pre>\n<p>此举会在远程主机B的对应user的home/.ssh 目录下创建<code>authorized_key</code>文件.\n该公钥已经信任,拥有这个公钥的A主机用户可以直接通过<code>ssh {username}@B</code>不输入密码而直接远程到B</p>\n</li>\n</ol>\n<p>OK.在了解到这一步之后,大概知道一台机器的主机需要如何配置ssh了.\n因为在Hadoop集群中,Master与每一台Slaves都需要进行ssh通讯,\n所以需要在Hadoop中每一台机器都生成自己的ssh公钥,然后与Master互相进行公钥传输动作.</p>\n<p>在我自己的集群中,进行了4次<code>ssh-copy-id</code>操作:</p>\n<ol>\n<li>elementary-os -&gt; hd-worker-a</li>\n<li>hd-worker-a -&gt; elementary-os</li>\n<li>elementary-os -&gt; hd-worker-b</li>\n<li>hd-worker-b -&gt; elementary-os</li>\n</ol>\n<h3 id=\"basic-environment-setup\">Basic Environment Setup</h3>\n<p>在修改Hadoop的配置之前,需要进行配置的是所有节点的环境变量设置与必要的基础程序.</p>\n<h4 id=\"jdk\">JDK</h4>\n<p>Hadoop运行在Java环境中,所以每个节点都需要安装JDK.\n需要保证的是确保每一台节点上安装的JDK版本一致.\nP.S 我自己是Master OpenJDK-8 + Slaves OpenJDK-7. 目前还是正常运行的\n(顺便吐槽一下 <code>Ubuntu14.04</code>默认的apt-get源,相当傻逼.在不添加自己订阅的其他源的情况下\n连OpenJDK8的地址都没有,而且如果安装Git之类的工具,为求稳定居然用的是1.7以下的版本.\n这也是为什么我日常开发用的是<code>elementary-os</code>,虽然也是基于ubuntu14的内核,\n但是elementary-os修改了其默认的apt源,ui看起来也更加顺眼)</p>\n<pre><code class=\"undefinedbash\">$ sudo apt-get install openjdk-7-jdk\n</code></pre>\n<p>通过此举,安装的默认的jdk路径是<code>/usr/lib/jvm/java-7-openjdk-amd64</code>.\nOpenJDK8同理.\nOracleJDK也推荐复制到<code>/usr/lib/jvm</code>目录下.(守序善良Linux派优雅的约定之一)</p>\n<p>记住这里咯.在下面我们会将这个JDK的目录,加到当前用户<code>hduser</code>的<code>.bashrc</code>中.</p>\n<h3 id=\"configure-hadoop\">Configure Hadoop</h3>\n<p>终于到了这一步.\n建议首先在Master上机器修改好Hadoop的配置.然后压缩该文件夹,复制到其他Slave节点上的同一目录.</p>\n<h4 id=\"unpack-and-move-hadoop-folder\">Unpack and move hadoop folder</h4>\n<p>假设下载好的hadoop-2.7.2.tar.gz 在 当前用户的<code>Downloads</code>文件夹中.\n解压完毕之后,将其移动到<code>/usr/local</code>下,并更名为<code>hadoop</code></p>\n<pre><code>$ mv hadoop-2.7.2 /usr/local/hadoop\n</code></pre><h4 id=\"update-environment-file\">Update Environment File</h4>\n<p>在配置Hadoop的过程中,下列配置文件将会被修改.</p>\n<blockquote>\n<p>~/.bashrc\n/usr/local/hadoop/etc/hadoop/slaves\n/usr/local/hadoop/etc/hadoop/hadoop-env.sh\n/usr/local/hadoop/etc/hadoop/core-site.xml\n/usr/local/hadoop/etc/hadoop/yarn-site.xml\n/usr/local/hadoop/etc/hadoop/mapred-site.xml\n/usr/local/hadoop/etc/hadoop/hdfs-site.xml</p>\n</blockquote>\n<h5 id=\"-bashrc\">~/.bashrc</h5>\n<p>还记得之前提过的JDK路径吗,将其配置成<code>JAVA_HOME</code>\n修改当前用户的bash配置文件,将其加到.bashrc的底部</p>\n<pre><code class=\"undefinedbash\">$ cd ~\n$ vi .bashrc\n</code></pre>\n<pre><code class=\"undefinedsh\">#Hadoop variables\nexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/\nexport HADOOP_INSTALL=/usr/local/hadoop\nexport PATH=$PATH:$HADOOP_INSTALL/bin\nexport PATH=$PATH:$HADOOP_INSTALL/sbin\nexport HADOOP_MAPRED_HOME=$HADOOP_INSTALL\nexport HADOOP_COMMON_HOME=$HADOOP_INSTALL\nexport HADOOP_HDFS_HOME=$HADOOP_INSTALL\nexport YARN_HOME=$HADOOP_INSTALL\n</code></pre>\n<h5 id=\"-usr-local-hadoop-etc-hadoop-hadoop-env-sh\">/usr/local/hadoop/etc/hadoop/hadoop-env.sh</h5>\n<p>还是跟上面一样,需要将JDK的路径设置成<code>JAVA_HOME</code></p>\n<pre><code>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64/\n</code></pre><h5 id=\"-usr-local-hadoop-etc-hadoop-core-site-xml\">/usr/local/hadoop/etc/hadoop/core-site.xml</h5>\n<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间\n添加一个fs.default.name,其值为master机器的9000端口.\n譬如我的master机器是<code>elementary-os</code>,则value是<code>hdfs://elementary-os:9000</code>\nP.S.接下来的变量<code>{master-hostname}</code>请自行替换成自己的master的机器名.</p>\n<pre><code class=\"undefinedxml\">&lt;configuration&gt;\n  &lt;property&gt;\n    &lt;name&gt;fs.default.name&lt;/name&gt;\n    &lt;value&gt;hdfs://{master-hostname}:9000&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;\n    &lt;value&gt;file:/usr/local/hadoop_store/tmp&lt;/value&gt;\n  &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h4 id=\"-usr-local-hadoop-etc-hadoop-yarn-site-xml\">/usr/local/hadoop/etc/hadoop/yarn-site.xml</h4>\n<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间\n添加:</p>\n<pre><code class=\"undefinedxml\">&lt;configuration&gt;\n  &lt;property&gt;\n    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;\n    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;\n    &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;\n    &lt;value&gt;{master-hostname}&lt;/value&gt;\n  &lt;/property&gt;\n&lt;/configuration&gt;\n</code></pre>\n<h5 id=\"-usr-local-hadoop-etc-hadoop-mapred-site-xml\">/usr/local/hadoop/etc/hadoop/mapred-site.xml</h5>\n<p><code>mapred-site.xml</code>默认是不存在的.\n但是有一份模板文件<code>mapred-site.xml.template</code>,我们将其复制并重命名成<code>mapred-site.xml</code></p>\n<pre><code class=\"undefinedbash\">$ cp /usr/local/hadoop/etc/hadoop/mapred-site.xml.template /usr/local/hadoop/etc/hadoop/mapred-site.xml\n</code></pre>\n<p>在<code>&lt;configuartion&gt;&lt;/configuration&gt;</code>之间\n添加:</p>\n<pre><code class=\"undefinedxml\">&lt;configuartion&gt;\n  &lt;property&gt;\n    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;\n    &lt;value&gt;yarn&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;mapred.job.tracker&lt;/name&gt;\n    &lt;value&gt;{master-hostname}:9001&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;\n    &lt;value&gt;{master-hostname}:10020&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;\n    &lt;value&gt;{master-hostname}:19888&lt;/value&gt;\n  &lt;/property&gt;\n&lt;/configuartion&gt;\n</code></pre>\n<h5 id=\"-usr-local-hadoop-etc-hadoop-hdfs-site-xml\">/usr/local/hadoop/etc/hadoop/hdfs-site.xml</h5>\n<p>在修改<code>hdfs-site.xml</code>这个配置文件之前,我们需要知道更多的一件事.\nhdfs的块状文件,储存在一个指定的目录中.\n按照官方文档的推荐,和网上一些文件夹的路径的约定,我们将这个\nhdfs的文件储存目录叫做<code>hadoop_store</code>.绝对路径为<code>/usr/local/hadoop_store</code></p>\n<p>于是hadoop的相关文件夹就变成了两个:</p>\n<blockquote>\n<p>/usr/local/hadoop\n/usr/local/hadoop_store</p>\n</blockquote>\n<p>由于读写权限问题,我们需要将<code>hadoop_store</code>的权限改成任意可读可写</p>\n<pre><code class=\"undefinedbash\">$ sudo mkdir -p /usr/local/hadoop_store\n$ sudo chmod -R 777 /usr/local/hadoop_store\n</code></pre>\n<p>然后再在配置文件里面加入</p>\n<pre><code class=\"undefinedxml\">&lt;configuartion&gt;\n  &lt;property&gt;\n    &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;\n    &lt;value&gt;{master-hostname}:50090&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;dfs.replication&lt;/name&gt;\n    &lt;value&gt;1&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;\n    &lt;value&gt;file:/usr/local/hadoop_store/hdfs/namenode&lt;/value&gt;\n  &lt;/property&gt;\n  &lt;property&gt;\n    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;\n    &lt;value&gt;file:/usr/local/hadoop_store/hdfs/datanode&lt;/value&gt;\n  &lt;/property&gt;\n&lt;/configuartion&gt;\n</code></pre>\n<h5 id=\"slaves\">slaves</h5>\n<p><code>slaves</code>文件里面存储的是作为slave的节点的机器名.\n以行为单位,一行一个.\n默认只有一行localhost.\n从一般的集群角度来说,Master不应该担当Worker的角色(老湿布置作业给小学僧,自己是不会一起做作业的)\n所以slaves文件一般只写slave节点的名字,即slave节点作为datanode,master节点仅仅作为namenode.</p>\n<p>但是由于我是一名好老湿,所以在本机配置中master也充当了worker的角色,所以本机是这样改的:</p>\n<pre><code>elementary-os\nhd-worker-a\nhd-worker-b\n</code></pre><p>致此,所有的配置文件已经修改完毕.\n可以将master上的hadoop文件夹压缩并且分发到各个slave节点上.</p>\n<h4 id=\"last-configure-format-namenode\">Last Configure : Format Namenode</h4>\n<p>最后一步配置,初始格式化 hdfs</p>\n<pre><code class=\"undefinedbash\">$ cd /usr/local/hadoop/\n$ hdfs namenode -format\n</code></pre>\n<h3 id=\"start-all-hadoop-deamons\">Start all Hadoop deamons</h3>\n<p>启动Hadoop服务.</p>\n<pre><code class=\"undefinedbash\">$ su hduser\n$ cd /usr/local/hadoop/\n$ sbin/start-dfs.sh\n$ sbin/start-yarn.sh\n</code></pre>\n<p>如果启动成功,在master节点上通过jps命令查看,应该包含如下hadoop进程</p>\n<pre><code>hduser@elementary-os:~$ jps\n51288 Jps\n22914 ResourceManager\n22361 NameNode\n23229 NodeManager\n22719 SecondaryNameNode\n</code></pre><p>在 slave节点上通过jps命令查看,应该包含如下hadoop进程</p>\n<pre><code>hduser@hd-worker-a:~$ jps\n6284 NodeManager\n6150 DateNode\n6409 Jps\n</code></pre><p>或者可以通过浏览器访问<a href=\"http://master:8088\">http://master:8088</a>\n或者<a href=\"http://master:50070\">http://master:50070</a>\n查看Hadoop服务状态.</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1vHd.MpXXXXXDXFXXXXXXXXXX.png\" alt=\"Nodes of the cluster\">\n<img src=\"https://img.alicdn.com/tfscom/TB16f8YMpXXXXbJXVXXXXXXXXXX.png\" alt=\"Namenode information\"></p>\n<p>P.S.关于<code>jps</code>命令.\njps位于jdk的bin目录下,其作用是显示当前系统的java进程情况,及其id号.\njps相当于linux进程工具ps,但是不支持管道命令grep\njps并不使用应用程序名来查找JVM实例.</p>\n<h2 id=\"trouble-shooting\">Trouble Shooting</h2>\n<p>防跌坑指南.\n记录了在Hadoop环境搭建过程中所遇到的坑</p>\n<h3 id=\"number-of-live-datanode-0\">Number of Live DataNode:0</h3>\n<p>通过<code>start-dfs.sh</code>启动了hadoop多个节点的datanode,\n且通过<code>jps</code>命令能够看到正常的datanode和resourcemanager进程,\n为什么live datanode数目为0,或者只有master的那个datanode?</p>\n<p>可通过以下方法排除:</p>\n<ol>\n<li><p>关闭所有节点的防火墙(ubuntu):\n先查看防火墙状态</p>\n<pre><code class=\"undefinedbash\">$ sudo ufw status\n</code></pre>\n<p>如果不是disabled,则禁用</p>\n<pre><code class=\"undefinedbash\">$ sudo ufw disable\n</code></pre>\n</li>\n<li><p>在hadoop服务运行的时候,关闭namenode的安全模式</p>\n<pre><code class=\"undefinedbash\">$ hadoop dfsadmin -safemode leave\n</code></pre>\n</li>\n<li><p>在关闭hadoop服务的情况下,删除所有的日志文件,存储文件并重新format\n确保<code>hadoop_store</code>文件夹下的所有文件夹权限都是777</p>\n<pre><code>$sudo rm -r /usr/local/hadoop/logs\n$sudo rm -r /usr/local/hadoop_store/tmp\n$sudo rm -r /usr/local/hadoop_store/hdfs\n$sidp hdfs namenode -format\n</code></pre></li>\n</ol>\n"},{"link":"2015/12/03/intallij-idea-bootstrap-useful-mean-stack-plugins-and-config","title":"IntelliJ IDEA 技巧系列:MEAN Stack 开发配置与常用插件","published":"2015-12-03T02:16:29.000Z","tags":["IntelliJ IDEA","Node.js","JavaScript"],"html":"<h2 id=\"background\">Background</h2>\n<blockquote>\n<p>As best Java,JavaScript,MEAN Stack IDE,\nWith useful MEAN plugin,\nIntelliJ IDEA helps you develop faster\nAnd get better coding experience.</p>\n</blockquote>\n<p>作为JetBrains系列IDE的爸爸,与<code>WebStorm</code>不同的是,Idea在默认安装过程中,\n默认只添加了Node.JS的支持.对于模块化JavaScript的支持(而非html内嵌JavaScript代码),\nIdea还需要修改一些配置,更新一些插件来达成完美的MEAN Stack开发体验.</p>\n<p>本文将从 MEAN 与 Common 配置两部分出发,介绍在开发过程中好评的插件.</p>\n<h2 id=\"common-useful-plugin\">Common Useful Plugin</h2>\n<blockquote>\n<p>所有的Jetbrains系列插件,都可以通过 <code>File</code>-&gt;<code>Settings</code>-&gt;<code>Plugin</code>界面进行搜索安装\n<img src=\"https://img.alicdn.com/tfscom/TB1Vlg.KFXXXXX8XVXXXXXXXXXX.png\" alt=\"Plugin Install UI\"></p>\n</blockquote>\n<h3 id=\"-ignore\">.ignore</h3>\n<blockquote>\n<p>不同的版本控制工具(Version Control),一般都有各自的忽略列表.\n通过忽略列表匹配对应的文件.\n来达到防止对不应该Commit的文件的提交.</p>\n</blockquote>\n<p><code>.ignore</code>是一款版本管理辅助插件.\n我一般使用它的以下功能:</p>\n<ol>\n<li><p>根据模板自动生成对应版本控制工具忽略列表\n<img src=\"https://img.alicdn.com/tfscom/TB10mplKVXXXXbuXpXXXXXXXXXX.png\" alt=\"创建.gitignore文件\"></p>\n</li>\n<li><p>根据忽略列表对文件名进行 灰度颜色\n灰度标记文件夹,时刻提升自己那个文件夹是 (Build出来的/临时文件/lib) 不必人工改动.\n<img src=\"https://img.alicdn.com/tfscom/TB1mZxzKVXXXXXoXXXXXXXXXXXX.png\" alt=\"文件忽略灰度标记\"></p>\n</li>\n</ol>\n<h3 id=\"grep-console\">Grep Console</h3>\n<blockquote>\n<p>查看控制台输出的时候,经常会忽略一些Exception,Error,Warning\n因为他们在控制台中跳得太快,而且不显眼\n当出现Exception需要快速定位问题的时候,查找log的效率一定程度上决定了debug的效率.</p>\n</blockquote>\n<p><code>Grep Console</code>是一款控制台润色插件.\n我主要使用它的润色功能:\n默认情况下,<code>Grep Console</code>会对每一行输出的关建字进行检索.\n该行出现<code>ERROR,FATAL,EXCEPTION</code>的时候会对该行进行红色润色\n该行出现<code>WARNING</code>的时候进行黄色润色.\n这样就可以快速翻滚追踪到这个信息</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1JNXeKVXXXXbWXFXXXXXXXXXX.png\" alt=\"根据特定规则对特定行列润色标记\"></p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1czdxKVXXXXXEXXXXXXXXXXXX.png\" alt=\"Grep Console 配置界面\"></p>\n<h3 id=\"batch-script-support-bash-support-\">Batch Script Support(Bash Support)</h3>\n<blockquote>\n<p>大多数项目都会有自己的自动构建/部署脚本.\n在<code>Mac</code>,<code>Linux</code>下通常是Shell脚本\n在<code>Windows</code>下通常是cmd,bat脚本</p>\n</blockquote>\n<p><code>Batch Script Support(Bash Support)</code>(分别是两个插件,但是功能大相径庭)\n是一款能够快速执行脚本的插件.</p>\n<blockquote>\n<p>一般我们是在对应系统的<code>Terminal</code>里面call这个脚本就行了.\n搞笑?这个功能不是没什么卵用吗</p>\n</blockquote>\n<p><strong>别闹</strong>,像Windows这些渣渣自带的Terminal去跑bat,cmd输出有颜色吗?\n设置的<code>Buffsize</code>太小还会吃掉最上一部分的内容\n所以这里就要配合上面的 <code>Grep Console</code>配合使用了.</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1hrhwKVXXXXaRXXXXXXXXXXXX.png\" alt=\"添加脚本文件到Run Configuration 一键运行\"></p>\n<h2 id=\"mean-stack-support-plugin\">MEAN Stack Support Plugin</h2>\n<h3 id=\"node-js-global-support\">Node.js Global Support</h3>\n<p><code>Node.JS</code>集成功能本来在安装Idea的时候就自带了这集成,不过有时候不小心会被取消掉.\n在编辑JavaScript代码的时候,如果用到了<code>Node.js</code>的原生API而没有配置<code>Node.JS</code>的提示的时候.\n写起来就比较烦心.</p>\n<blockquote>\n<p>在这里先提及一下 Idea的<code>Libraries in Scope</code>功能:\n<code>Libraries in Scope</code>是指当前编辑的JavaScript代码实际调用的函数库.\n对于代码分开存储,使用<code>bower</code>,<code>npm</code>管理第三方JavaScript代码库的动态链接相当使用.</p>\n</blockquote>\n<p><img src=\"https://img.alicdn.com/tfscom/TB14fk8KFXXXXb6XVXXXXXXXXXX.png\" alt=\"查看当前编辑文件的Scope Libraries\"></p>\n<p>如果开启<code>Node.js</code>的提示?</p>\n<ol>\n<li><p>在插件中安装<code>Node.js</code>集成.</p>\n<blockquote>\n<p>这一步估计大多数人都有,可以跳过</p>\n</blockquote>\n</li>\n<li><p>添加项目的<code>Node.js</code>全局支持</p>\n</li>\n</ol>\n<p><code>File</code>-&gt;<code>Settings</code>-&gt;<code>Languages &amp; Frameworks</code>-&gt;<code>Node.js and NPM</code>\n<img src=\"https://img.alicdn.com/tfscom/TB1m7A9KFXXXXbrXVXXXXXXXXXX.png\" alt=\"添加Node.js全局提示\"></p>\n<h3 id=\"angularjs-support-css-library-support\">AngularJS Support/CSS Library Support</h3>\n<blockquote>\n<p>当所引用的JS,CSS文件并不在源代码文件夹内\nIdea原本是不能提示的\n但是如果将所需的第三方lib添加到<code>Libraries in Scope</code>中,就可以</p>\n</blockquote>\n<p>还是在当前编辑文件的右下角,打开<code>Libraries in Scope</code>窗口-&gt;<code>Add</code>添加Library\n<img src=\"https://img.alicdn.com/tfscom/TB1JSRyKVXXXXXYXXXXXXXXXXXX.png\" alt=\"打开Libraries窗口\"></p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1m.s_KFXXXXaxXVXXXXXXXXXX.png\" alt=\"添加实际文件\"></p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1dRtjKVXXXXXeXFXXXXXXXXXX.png\" alt=\"添加github上提供的第三方lib\"></p>\n<h3 id=\"mongo-plugin\">Mongo Plugin</h3>\n<p>Idea官方自带的关系型数据库插件非常强大,但是对于<code>MongoDB</code>则支持不是很好.\n集成MongoDB的第三方插件,叫做<code>Mongo Plugin</code>.\n<img src=\"https://img.alicdn.com/tfscom/TB1y9Q9KFXXXXaWXVXXXXXXXXXX.png\" alt=\"不是很好用的Mongo Plugin\"></p>\n<p>其实个人比较推荐 另一个MongoDB 可视化工具,叫做<code>Robomongo</code></p>\n<h3 id=\"live-edit\">Live Edit</h3>\n<p>还记得之前Adobe出过一款叫<code>Brackets</code>的软件,前端开发修改源代码页面自动刷新的一改即可见的能力.\n非常强大.\n<code>Live Edit</code>其实也实现了这个功能.篇幅关系这里不详细讲,仅仅提及这个功能,且因为我只是在Chrome里面\n实验过,还没有深刻的体会.</p>\n<p>启动<code>Live Edit</code>功能之后,相当Chrome里面的html,js映射到源代码上来.\nIdea内部直接与Chrome的开发控制台连接,修改源代码等同在Chrome的开发者控制台中修改.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>其实Idea上还有一些比较常见的插件,但是需要结合实际的开发场景,决定是否<strong>Useful</strong>.</p>\n"},{"link":"2015/11/24/intellij-idea-bootstrap-installation-and-configuartion","title":"IntelliJ IDEA 技巧系列:安装后常见环境配置 [入门]","published":"2015-11-24T15:17:07.000Z","tags":["IntelliJ IDEA"],"html":"<p>以后推送的技巧系列文章,会在前面加一个实用系数标记,\n大概可以分成下面几种</p>\n<blockquote>\n<p><code>入门</code> 可视为弱智级别,适合完全没上手过的童鞋,用过一段时间的自动忽略\n<code>进阶</code> 进阶技巧,我觉得真实用的才会标记成进阶,适用范围时而小众[推荐]\n<code>转载</code> 转载官网的或者Tips中的实用技巧\n<code>实战</code> 实战经验[推荐]</p>\n</blockquote>\n<h2 id=\"-why-intellij-idea\">背景: Why IntelliJ IDEA</h2>\n<p>大学的时候,时间花费在WOW上.\n特别是在录制视频的时候,觉得没有一个好看的UI与插件布局,风骚的走位与操作都体现不出来.\n于是开始折腾插件与界面美化.</p>\n<p>界面美化,很重要一部分是字体.\n最后由游戏字体引发到Windows的字体渲染问题上.</p>\n<p>当时早就不爽Eclipse了(其实我好像还是用过Eclipse写过Java Web..),\n从UI上来讲:</p>\n<blockquote>\n<ul>\n<li>好好的字体设置只能选英文字体,然后在英文字体下的默认中文字体(宋体)会比英文小一截.</li>\n<li>Eclipse内置字体渲染也是屎.学C的时候,有个C的IDE叫做C-Free.或者Code-Blocks.他们对Courier New的字体都支持的非常好,饱满,圆润. 可是在Eclipse上显示,间距太大还不能调节</li>\n<li>沉迷于代码格式化,为什么没有一个对齐线 辅助对齐代码 ?</li>\n<li>Eclipse 检查代码 一旦有warning 就会在文件上多一个感叹号. 而且对压缩后的js hint支持还特别差,会一直有个红叉(查了好久也不知道为什么) 看着很烦</li>\n<li>当时写html的时候,Eclipse 是有一个 html的对比页面的.可是他的动态渲染 文件链接能力简直为0.动态生成的显示效果比屎还不如\n于是我便尝试了当时流行的一些JavaIDE:NetBeans,JBuilder 结论就是<strong>我草都丑哭了好吗</strong>\n这样一直提不起学Java的兴趣\n直到后来学Android的时候,除了Eclipse with Android ADT之外,Google官方推荐使用的是<code>Android Studio</code>\n立刻下了一个.感觉这个IDE相当有趣.\n再到后来才开始了解这个IDE的公司<code>JetBrains</code>.\n旗下的IntelliJ IDEA 旗舰版是目前号称<code>最智能的Java IDE</code>.\n什么<code>Android Studio</code>,<code>WebStorm</code>,<code>PHPStorm</code>,<code>PyCharm</code>都是<code>IntelliJ IDEA</code>的子集\n赶紧下了个来折腾.</li>\n</ul>\n</blockquote>\n<p>果不其然,作为生产力工具.一个好的IDE能够确切提高Coding时候的乐趣.\n至今,已经有快两年的使用IDEA的经验.\n与以往的编程/学习体验相比,更像是从自行车换成了奥迪,非一般的感觉,我的电脑已经没有Eclipse了.\n为了宣扬Idea大法,决定制作一系列的文章 分享使用Idea期间获取的有用的技巧.</p>\n<blockquote>\n<p>世上必定存在大大,认为成功的程序员并不依靠IDE.\n我从心底是赞成这个观点的\n但是从生产力与用户体验的角度来说,好的IDE提高了生产力与编程体验\n这与软件工程最终给用户带来的效果是一样的.为什么不让一个好的IDE来帮助自己呢?\n我会用Vim,入门过emacs.可是因为UI太丑还没体验到他们的神奇之处就退烧了..所以使用Vim,emacs的大大我还是相当佩服的\n(前提は私覇気ああよりもそのあなたの仕事が優れています)</p>\n</blockquote>\n<h2 id=\"-\">正文</h2>\n<p>言归正传,本文的主要内容是 安装之后的常见配置.\n由于Idea的安装过程非常简单,基本是无脑下一步即可.\n下面是一些常用的配置,(相对默认从其他IDE/文本编辑器迁移过来的一些配置)\n通过菜单<code>File</code>-&gt;<code>Settings</code>打开配置页面,下面的配置都通过这里来实现\n<img src=\"https://img.alicdn.com/tfscom/TB1fZYYKFXXXXbHXVXXXXXXXXXX.png\" alt=\"Perferences\"></p>\n<h3 id=\"-\">字体</h3>\n<p>Windows下Idea默认的代码字体显示简直就是屎,不换都对不起自己眼睛.\n其中字体在Idea里面默认分成三种全局型的字体:\n<code>Appearance</code>:<code>系统UI字体</code>\n<code>Code Font</code>:<code>文本编辑字体</code>\n<code>Console Font</code>:`控制台输出字体``</p>\n<h4 id=\"-appearance-\">修改Appearance字体</h4>\n<p><code>Appearance&amp;Behavior</code>-&gt;<code>Appearance</code> 建议系统默认,这里只是告诉大家怎么改\n<img src=\"https://img.alicdn.com/tfscom/TB180QqKFXXXXXHXXXXXXXXXXXX.png\" alt=\"修改Appearance字体\"></p>\n<h4 id=\"-\">修改文本编辑字体</h4>\n<p><code>Editor</code>-&gt;<code>Colors&amp;Fonts</code>\n要使用自定义字体,先点击下图的Schema 先另存为一份 配置.才能够进行更改.\n<img src=\"https://img.alicdn.com/tfscom/TB1AEn3KFXXXXacXVXXXXXXXXXX.png\" alt=\"修改文本编辑字体\"></p>\n<p>编程字体当然推荐等宽字体,如果对字体有选择困难,建议阅读这篇文章.\n<a href=\"https://www.zhihu.com/question/20299865?rf=22041107\">有那些适合用于写代码的字体?</a></p>\n<h4 id=\"-\">修改控制台字体</h4>\n<p>跟上图一样,图中有一栏叫做Console Font的配置.从那修改即可.</p>\n<h3 id=\"-\">显示行号</h3>\n<p>开启行号是必须的,不然报错怎么能快速查看行号?\n<code>Editor</code>-&gt;<code>General</code>-&gt;<code>Appearance</code>,勾选`Show line number``\n<img src=\"https://img.alicdn.com/tfscom/TB1TEjWKFXXXXcyXVXXXXXXXXXX.png\" alt=\"显示行号\"></p>\n<h3 id=\"-\">修改键位</h3>\n<p>从Eclipse迁移过来Idea,如果用惯了Eclipse的话可能对Idea的键位不是很习惯.\n实在受不了Idea默认键位的话,可以使用自己以前的Eclipse热键.\n<code>Keymap</code>,从下拉框中选择Eclipse(or其他)\n<img src=\"https://img.alicdn.com/tfscom/TB1e8_8KFXXXXcfXFXXXXXXXXXX.png\" alt=\"修改键位\"></p>\n<blockquote>\n<p>Thanks @James,还没想到有这么普遍的转型需求</p>\n</blockquote>\n<h3 id=\"-\">开启字体滚轮缩放</h3>\n<p><code>Editor</code>-&gt;<code>General</code>\n<img src=\"https://img.alicdn.com/tfscom/TB1wQH.KFXXXXaOXFXXXXXXXXXX.png\" alt=\"开启字体滚轮缩放\"></p>\n<h3 id=\"-\">修改默认文件编码</h3>\n<p>不管是中文还是英文的Windows.大部分的默认文本编码都是GBK,(什么简体中文版更有可能是Cp13252)\n代码文件编码 非<code>UTF-8</code>带来的屁事就是多.曾经看到一位大大的博客,他以前在Github上跟队友合作写项目\n其中有个队友用的是Windows,新加的源代码文件是GBK的编码,出现编译之后奇奇怪怪的结果.最后把那个队友<code>干掉</code>了.</p>\n<p><code>Editor</code>-&gt;<code>File Encodings</code>,\n将<code>IDE-Encoding</code>,<code>Project Encoding</code>,<code>Default encoding for properties files</code>都修改成<code>UTF-8</code>.\n<img src=\"https://img.alicdn.com/tfscom/TB1De.qKFXXXXX3XXXXXXXXXXXX.png\" alt=\"修改默认文件编码\"></p>\n<h2 id=\"-\">小结</h2>\n<p>以后推送的技巧系列文章,会在前面加一个实用系数标记,\n大概可以分成下面几种</p>\n<blockquote>\n<p><code>入门</code> 可视为弱智级别,适合完全没上手过的童鞋,用过一段时间的自动忽略\n<code>进阶</code> 进阶技巧,我觉得真实用的才会标记成进阶,适用范围时而小众[推荐]\n<code>转载</code> 转载官网的或者Tips中的实用技巧\n<code>实战</code> 实战经验[推荐]</p>\n</blockquote>\n<p>系列文章可以 通过点击标签:<a href=\"http://blog.aquariuslt.com/tags/IntelliJ-IDEA/\">IntelliJ IDEA</a> 获得.</p>\n<p>Idea 系列文章纯属个人经验之谈,抛开技术部分的讲解其余全部带有非客观的个人色彩.\n如有技术方面的错误,希望各位不吝提出并指正.感谢.\n(如有其他方面的意识形态方面的意见,恕在下年轻气盛一意孤行,你可以说,但我不听.)</p>\n"},{"link":"2015/07/09/intellij-idea-bootstrap-use-changelist","title":"IntelliJ IDEA 技巧系列:使用自带版本控制工具的ChangeList提升Commit效率","published":"2015-07-09T06:25:19.000Z","tags":["IntelliJ IDEA"],"html":"<h2 id=\"background\">Background</h2>\n<p>在一群使用Eclipse的队友中特立独行使用idea有时候会遇到各种让强迫症纠结的问题。\n当使用idea导入Eclipse或者其他IDE的项目的时候，idea会生成一系列的帮助idea本身配置项目的与项目无关的配置文件，比如 <em>.iml、</em>.vcs和一些xml文件。</p>\n<p>但这些文件是第一次生成的时候，直接加进去.gitignore列表即可解决问题。\n可是当遇到猪队友不懂或者误将这些文件 提交到Git一次之后，gitignore的忽略就会失效，使用桌面版Git Extension 去Commit的时候，每次都要小心翼翼不要选错文件。</p>\n<p>可是idea本身就整合了相当方便的ChangeList：\n<img src=\"\" alt=\"Change-List\"></p>\n<ol>\n<li>在下方工具栏位置 选中一系列需要整合到一个组的文件，右键Move to another Changelist\n<a href=\"\"><img src=\"\" alt=\"Move To Changelist\"></a></li>\n<li>可以给Changelist起一个名字叫做 IDE-Settings\n<a href=\"\"><img src=\"\" alt=\"Named Changelist\"></a></li>\n<li>当下次Commit的时候可以直接跳过该IDE-Settings中的列表，直接Commit其他全部文件\n<a href=\"\"><img src=\"\" alt=\"Commit\"></a></li>\n</ol>\n<p>方便的实现 软ignore不必要commit的文件。</p>\n"},{"link":"2016/03/22/intellij-idea-cannot-resolve-nodejs-core-modules","title":"IntelliJ IDEA 不能正常解析Node.js Core Modules 属性方法的解决方案","published":"2016-03-22T05:45:25.000Z","tags":["Node.js","IntelliJ IDEA"],"html":"<h2 id=\"background\">Background</h2>\n<p><code>IntelliJ IDEA</code>更新到2016.01之后,在使用<code>Node.js</code>的原生API的时候,遇到了了一个问题:\n不能够auto-complete出对应的属性方法:\n比如以下的代码:</p>\n<pre><code class=\"undefinedjs\">var filePath = &#39;/home/aquariuslt/Downloads/avator.png&#39;;\nvar path = require(&#39;path&#39;);\npath.basename(filePath);\n</code></pre>\n<p>正常情况下是能够根据<code>Node.js</code>的API预定义文件<code>core_moudles</code>对方法名进行自动补全.\n<img src=\"https://img.alicdn.com/tfscom/TB1c4XbMXXXXXX2aXXXXXXXXXXX.png\" alt=\"正常情况\"></p>\n<p>更新之后居然不能自动提示了</p>\n<h2 id=\"solutions\">Solutions</h2>\n<p>有两个解决方案,分别对应不同的情况.\n两个都试过了,分别在<code>Windows</code>,<code>Linux</code>下完成</p>\n<h3 id=\"-enable-node-js-framework-support\">重新Enable一次Node.js Framework Support</h3>\n<p><code>File</code>-&gt;<code>Settings</code>-&gt;<code>Languages &amp; Frameworks</code>\n先disable掉Node.js\n再enable.</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1gHQ_LVXXXXXrapXXXXXXXXXX.png\" alt=\"Languages &amp; Frameworks Settings\"></p>\n<h3 id=\"-node-js-idea-node-js-\">如果安装过不同版本的Node.js,删除不同版本的IDEA Node.js 定义文件</h3>\n<p>在User的个人目录<code>~</code>下\n可能存放了不同IDEA版本,不同Node.js版本的配置文件</p>\n<pre><code class=\"undefinedshell\">$ls -al | grep Idea\n\nC:\\Users\\CUIJA&gt;ls -al | grep Idea\ndrwxr-xr-x 1 CUIJA 1049089       0 Mar 21 18:38 .IntelliJIdea15\ndrwxr-xr-x 1 CUIJA 1049089       0 Mar 21 18:42 .IntelliJIdea2016.1\n</code></pre>\n<p>先删除旧的IDEA 版本的config文件夹.\n再进入当前使用的IDEA版本的config文件夹</p>\n<pre><code class=\"undefinedshell\">$cd .IntelliJIdea2016.1\\config\\javascript\\nodejs\ntotal 0\ndrwxr-xr-x 1 CUIJA 1049089 0 Mar 21 18:47 .\ndrwxr-xr-x 1 CUIJA 1049089 0 Mar 21 18:47 ..\ndrwxr-xr-x 1 CUIJA 1049089 0 Mar 21 18:47 4.3.1\ndrwxr-xr-x 1 CUIJA 1049089 0 Mar 21 18:47 4.4.0\n</code></pre>\n<p>删掉那个比较旧的文件夹 即可.</p>\n"},{"link":"2014/10/25/intellij-idea-github-connection","title":"IntelliJ IDEA 技巧系列:GitHub设置同步工程","published":"2014-10-24T16:22:22.000Z","tags":["IntelliJ IDEA","Github"],"html":"<p>之前弄过一次  后来因为一直在本机开发，所以用的是本地的Git</p>\n<p>通过IntelliJ IDEA + GitHub 管理代码仓库\n更加方便的看到版本提交历史+更变详细对比，公司+宿舍+笔记本三方同步开发</p>\n<p>一.事先准备</p>\n<p>1.安装Git</p>\n<p>Git下载: <a href=\"http://git-scm.com/downloads\">http://git-scm.com/downloads</a> 最新版本是2.1.2</p>\n<p>2.注册GitHub账号</p>\n<p>3.设置代理(可选)</p>\n<p>GitHub有一定记录是被墙的...在公司里能用Chrome直接改hosts访问，但是用Idea就无法连接上。所以有必要使用代理、</p>\n<p>GoAgent自己去搜一下下载啦</p>\n<p>开启GoAgent代理之后，默认是127.0.0.1:8087 作为VPN的地址。</p>\n<p>二.IntelliJ IDEA添加Git与GitHub支持</p>\n<p>Idea本身就支持Git和GitHub，不过先要设置Git的位置和跟你的GitHub账号连接起来。</p>\n<p>1.设置Git的路径</p>\n<p>在Idea中，File-Settings-Version Control-Git 中，在右侧指定git.exe的位置\n<img src=\"\" alt=\"\"></p>\n<p>2.添加GitHub账号</p>\n<p>2-0.在Idea中设置代理(可选)</p>\n<p>Settings-HTTP Proxy中，在右侧选中Manual proxy configuration</p>\n<p>host name 填127.0.0.1</p>\n<p>Port number 填8087</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>2-1.设置GitHub账号</p>\n<p>Settings-Version Control-GitHub</p>\n<p>host填写github.com</p>\n<p>Login和password 分别填写自己的GitHub账号密码</p>\n<p>然后下面的Connection timeout 连接时长上限\n修改成一个比较大的值\n比如50000(输入完记得回车，不然设置没有生效)</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>然后尝试点Test</p>\n<p>如果弹框如下，则说明连接成功。</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>三.同步工程</p>\n<p>在同步工程之前，我先说说我对Git在版本管理方面的一些理解：</p>\n<p>大概是这样:</p>\n<p>1.一开始，先创建一个项目工程的初始版本A，然后通过Git生成一个仓库A</p>\n<p>2.在A的基础上，进行多人协作开发/异地开发（这个其实上是一样的）的时候，先从仓库A那里同步，拿到最新版本的A的一份拷贝。这个动作成为Pull</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>3.拿到拿到仓库A的拷贝之后，程序员A和码农B负责编写不同的部分，反正不会修改到同一份代码文件，大部分情况是一部分负责做UI前端，另一部分负责做后台什么的。都是修改或者添加部分代码文件。</p>\n<p>在做好自己的单元工作的话，大概会变成这样</p>\n<p><img src=\"\" alt=\"\">\n4.这时候程序员A给自己修改后的整个工程项目\n打了备注(commit)：&quot;程序员A，增加了XXX后台功能&quot;,码农B 给自己的整个项目工程\n打了备注 &quot;码农B, 用苹果风格美化了界面&quot;，之后提交到本地Git仓库中。\n此时本地的Git仓库\n已经做好他们修改后的项目工程文件\n与原来仓库A的文件对比，记录在Git记录中。</p>\n<p>然后程序员A和码农B同时把自己做好的工程文件 push到远程的Git仓库中，远程的Git仓库就为仓库A添加了两个分支。</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>5.这时候，项目经理定时检查进度。</p>\n<p>查看了AB的分支之后，决定他们两个这段时间的工作成果可以融合起来</p>\n<p>就决定将这两个分支合并起来(merge)如果不合并起来，下次再开始修改\n不知道要从谁的分支开始进行工作，从程序员A的那个分支进行工作，就会发现码农B的界面代码又成了没修改过的那部分，还要码农B再修改。这样就是加大工作量，这样也侧面反映出低耦合，MVC模式对于团队合作的优点之处。</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>四.通过GitHub同步</p>\n<p>在了解了Pull,Push的意义之后，可以来通过Idea进行\n本地仓库创建，然后Share到GitHub，进行pull和push</p>\n<p>1.创建本地仓库</p>\n<p>对于没有在GitHub上创建仓库的一个本地项目，首先要在本地中创建本地仓库</p>\n<p>先选中整个项目目录，在菜单栏VCS-Git-Add  添加一个本地仓库</p>\n<p>2.Share to GitHub</p>\n<p>菜单栏VCS-Import into version control-share project on GitHub.\n<img src=\"\" alt=\"\"></p>\n<p>然后填写项目信息\n回车\n就能在你的GitHub主页创建一个新的开源项目，大概如下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>3.Pull and Push</p>\n<p>比如我在公司和宿舍都进行开发。每天下班不能搬着电脑回去吧，在单人开发的时候，这个是一个很好的同步方式。相当于云笔记那种功能。</p>\n<p>当我快要下班的时候，我就把项目先添加备注，表示这次项目的Push之前，我对其进行了什么修改的简述。</p>\n<p>我觉得这也是一个很好的版本功能更新记录。</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>添加了Commit之后，可以进行Push来上传修改后的分支</p>\n<p>下图是push</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>4.在GitHub上查看版本更替记录</p>\n<p>在你的GitHub上</p>\n<p>现在可以看到相对于原始版本\n有更新的每个地方的不同之处。\n<img src=\"\" alt=\"\"></p>\n<p>点击最上面的那部分查看，可以看修改了那些地方</p>\n<p><img src=\"\" alt=\"\"></p>\n"},{"link":"2016/04/02/javascript-document-create-element-xhr","title":"关于document.createElement的图片加载问题","published":"2016-04-02T09:14:39.000Z","tags":["JavaScript"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近在更新网站首页的时候,在实现文章摘要结果的时候,采用了不太正当的方法导致加载时间过长.</p>\n<p>在获取文章Summary的时候,原本Summary的样式应该是这样子的</p>\n<pre><code class=\"undefinedxml\">&lt;entry&gt;\n&lt;title&gt;\n&lt;![CDATA[ Angular Material md-button 不全部大写 ]]&gt;\n&lt;/title&gt;\n&lt;link href=&quot;http://debug.aquariuslt.com/2016/03/20/angular-material-md-button-using-lowercase/&quot;/&gt;\n&lt;id&gt;\nhttp://debug.aquariuslt.com/2016/03/20/angular-material-md-button-using-lowercase/\n&lt;/id&gt;\n&lt;published&gt;2016-03-20T07:33:50.000Z&lt;/published&gt;\n&lt;updated&gt;2016-03-22T05:42:44.939Z&lt;/updated&gt;\n&lt;content type=&quot;html&quot;&gt;\n&lt;/content&gt;\n&lt;summary type=&quot;html&quot;&gt;\n&lt;![CDATA[\n&lt;h2 id=&quot;BackGround&quot;&gt;&lt;a href=&quot;#BackGround&quot; class=&quot;headerlink&quot; title=&quot;BackGround&quot;&gt;&lt;/a&gt;BackGround&lt;/h2&gt;&lt;p&gt;刚刚接触&lt;code&gt;Angular-Material&lt;/code&gt;,发现其&lt;\n]]&gt;\n&lt;/summary&gt;\n&lt;/entry&gt;\n</code></pre>\n<p>在获取Summary的时候,由于summary的片段是不完整的html标签字符串,根本没有终止符,无法合理的转化成摘要文字.</p>\n<p>于是我就直接将content里面的全文html字符串来截取摘要内容.\n如何合理的截取到html字符串里面的innerText呢?\n一开始就使用了<code>document.createElement()</code>方法:\n通过将html字符串来创建一连串的dom element,然后用innerText来获取去除html标签之后的内容.</p>\n<pre><code class=\"undefinedjs\">function handleArticleSummary(articleSummary){\n    var div = document.createElement(&quot;div&quot;);\n    div.innerHTML = articleSummary.content._;\n    articleSummary.content.text = div.innerText;\n  }\n</code></pre>\n<p>但是这样就会导致 html 里面的 img 标签和以前涉及网络加载的标签,会在随着<code>createElement()</code>后的赋值方法,去获取实际上的img内容.\n加载图片或者其他脚本.这样导致第一次加载的时候耗时过长.</p>\n<h2 id=\"solution\">Solution</h2>\n<p>目前还没有正统的解决办法,我是使用正则表达式匹配img标签,将img标签过滤掉.\n来达到不必加载的目的.</p>\n<pre><code class=\"undefinedjs\">/**\n   * Get innerText from html body.\n   * When using document.createElement(htmlString),\n   * which htmlString contains image link, will load image from its src.\n   * it will cause much network time,so replace the image link.\n   * */\n  function handleArticleSummary(articleSummary){\n    var imageLinkRegex = /&lt;img\\s[^&gt;]*?src\\s*=\\s*[&#39;&quot;]([^&#39;&quot;]*?)[&#39;&quot;][^&gt;]*?&gt;/ig;\n    var originalHtmlString = articleSummary.content._;\n    var convertedHtmlString = originalHtmlString.replace(imageLinkRegex,&#39;&#39;);\n    var div = document.createElement(&quot;div&quot;);\n    div.innerHTML = convertedHtmlString;\n    articleSummary.content.text = div.innerText;\n  }\n</code></pre>\n"},{"link":"2016/02/22/javascript-packaging","title":"JavaScript Packaging","published":"2016-02-22T15:40:49.000Z","tags":["JavaScript","Node.js"],"html":"<h2 id=\"background\">Background</h2>\n<h3 id=\"history\">History</h3>\n<p>在原始阶段接触HTML,CSS,JavaScript的时候.\n对JavaScript的打包是没有概念的.\n毕竟Happy Case都不能跑通,优化的事情就抛诸脑后了.\n原始的HTML文件资源加载方式</p>\n<pre><code class=\"undefinedhtml\">&lt;html&gt;\n&lt;head&gt;\n  &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;link href=&quot;&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- Body Content--&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这种文件加载方式.第一个缺点就是需要加载多少个文件,写多少行文件的导入.\n(很不幸我现在还有一个项目使用这样的文件加载方式,哈哈)</p>\n<h3 id=\"performance-tuning\">Performance Tuning</h3>\n<p>后来确实遇到了一些需要前端优化的case.\nWeb前端性能优化来说,我遇到的case大概可以分成以下几种类型</p>\n<h4 id=\"html-\">HTML结构的优化</h4>\n<p>这点在使用ExtJS的过程中尤为明显,由于ExtJS采用了极端的界面渲染方式.\n在ExtJS的View代码中,一个子组件,或者面板的创建.实际上会以近十倍的DOM节点数量增加.\n在实际渲染成的界面之中.动态操作的非业务性DOM节点相当多.\n对于前期使用ExtJS官方推出的那个Sencha鸟蛋DreamViewer拖控件控制布局的方式,\n拖出来的布局.就会有相当多的冗余结构.\n随着业务代码的增多,这些冗余的视图层直接影响了JavaScript渲染DOM节点的时间.</p>\n<p>映射到裸露的HTML代码也是一样.</p>\n<h4 id=\"-\">资源文件的优化</h4>\n<p>这点是看了Bootstrap的介绍才开始知道的.\n他们将静态的资源文件.图标/字体 合成一个文件.\n动态切割获取子元素.\n后来在移动客户端那部分也遇到了很多类似的资源合并情况.</p>\n<h4 id=\"javascript-\">JavaScript逻辑的优化，模块化，异步加载，性能优化</h4>\n<p>这点就见仁见智了.\n从程序员的角度来说,我觉得这都得基于有扎实的编程基础,对JavaScript本身特性有一定程度的了解才能够有资格谈得上优化.\n自己在写代码的时候常见的JSHint约束的规范都做不到的话,恐怕还没资格去优化现有的程序.\n谁知道会不会引发其他问题呢.\n目前来说,将比较不科学的写法换成官方推荐的写法,不作负优化已经算是&quot;JS性能优化&quot;的明显手段之一了</p>\n<h4 id=\"http-\">HTTP请求的优化</h4>\n<p>从上面原始的HTML加载情况可以看出.\n就算是原始的JS/CSS记载方式.的HTML写法本身是先将静态css逐个加载,再将js文件置于body标签底部进行加载.\n在还没出现js文件打包合并之前,每个功能独立的js文件,在第一次加载的时候.都需要发送一次http请求.\nN个js文件,就必须发送N个http请求.\n如果不采用CDN,不做缓存的话.每次N个http硬性请求开销相当大</p>\n<h2 id=\"javascript-packaging\">JavaScript Packaging</h2>\n<p>于是在一些JavaWeb项目里面第一次接触到JavaScript文件合并,打包的概念.</p>\n<h3 id=\"jawr-in-javaweb\">JAWR in JavaWeb</h3>\n<blockquote>\n<p><a href=\"https://jawr.java.net/\">JAWR</a>is a tunable packaging solution for Javascript\nand CSS which allows for rapid development of resources in separate module files.</p>\n</blockquote>\n<p>遇到的第一个大型Java Web项目.\n在表现层使用到的技术栈是<code>SpringMVC</code>+<code>JSF</code>+<code>ExtJS</code>.\n按模块功能编写好ExtJS端的代码之后.通过JAWR的配置文件(可以是Properties+Web.xml加载,也可以与Spring集成,通过ApplicationContext配置)\n配置好一个合并(压缩)后的URL对应的是开发代码中的哪一个模块的集合\n在WebApp Server运行时将合并后的JavaScript代码释放出一个URL.通过该URL访问的实际上是合并后的js代码.\n<img src=\"https://img.alicdn.com/tfscom/TB1y.E6LFXXXXceXFXXXXXXXXXX.png\" alt=\"JAWR加载过程\"></p>\n<h3 id=\"mean-js-javascript-\">Mean.js的JavaScript加载方式</h3>\n<p>作为单页web应用,<code>mean.js</code>官方DEMO提供了一些前端打包的构建脚本.\n但是在还没使用打包脚本的时候,他也不是通过手动去维护<code>index.html</code>中应用到的JavaScript文件的.\n而是通过扫描所有约定的前端的路径下的所有js,css等文件,暴露出该文件的url,使之可以被web请求反问道.\n在批量替换到<code>index.html</code>中.\n省去了手动维护<code>index.html</code>对所用到的js引用的过程而已.</p>\n<h3 id=\"webpack-browserify\">Webpack/Browserify</h3>\n<p>之前对JavaScript的认识的一部分说到Node.js的模块加载方式.\n参考文章之一 <a href=\"http://www.infoq.com/cn/articles/nodejs-module-mechanism\">深入Node.js的模块机制</a></p>\n<p>贴出其中的一段内容:\nCommonJS规范</p>\n<blockquote>\n<p>早在Netscape诞生不久后，JavaScript就一直在探索本地编程的路，Rhino是其代表产物。\n无奈那时服务端JavaScript走的路均是参考众多服务器端语言来实现的，在这样的背景之下，一没有特色，二没有实用价值。\n但是随着JavaScript在前端的应用越来越广泛，以及服务端JavaScript的推动，JavaScript现有的规范十分薄弱，不利于JavaScript大规模的应用。\n那些以JavaScript为宿主语言的环境中，只有本身的基础原生对象和类型，更多的对象和API都取决于宿主的提供，所以，我们可以看到JavaScript缺少这些功能：</p>\n<ul>\n<li>JavaScript没有模块系统。没有原生的支持密闭作用域或依赖管理。</li>\n<li>JavaScript没有标准库。除了一些核心库外，没有文件系统的API，没有IO流API等。</li>\n<li>JavaScript没有标准接口。没有如Web Server或者数据库的统一接口。</li>\n<li>JavaScript没有包管理系统。不能自动加载和安装依赖。</li>\n<li>于是便有了<a href=\"http://www.commonjs.org\">CommonJS</a>规范的出现，其目标是为了构建JavaScript在包括Web服务器，桌面，命令行工具，及浏览器方面的生态系统。</li>\n</ul>\n</blockquote>\n<p>CommonJS制定了解决这些问题的一些规范，而Node.js就是这些规范的一种实现。\nNode.js自身实现了require方法作为其引入模块的方法，同时NPM也基于CommonJS定义的包规范，实现了依赖管理和模块自动安装等功能。</p>\n<p>所以当希望前端的代码以类似Node.js的方式一样实现模块加载,在打包JavaScript的时候,就需要用到一些JS打包的lib.\n目前流行的打包方式有webpack,browserify等.</p>\n<h4 id=\"browserify\">Browserify</h4>\n<p>以Webpack为例子,先对一个js文件进行打包</p>\n<p>文件A:</p>\n<pre><code class=\"undefinedjs\">var headerController = require(&#39;./controllers/header.controller&#39;);\nvar homeController = require(&#39;./controllers/home.controller&#39;);\nvar pictureSlideController = require(&#39;./controllers/picture.slide.controller&#39;);\nvar activitiesController = require(&#39;./controllers/activities.controller&#39;);\n\nvar activityArrayFilter = require(&#39;./filters/activity.array.filter&#39;);\nvar activityPublishFilter = require(&#39;./filters/activity.publish.filter&#39;);\n\nvar homeRoutes = require(&#39;./routes/home.routes&#39;);\nvar template = require(dest);\nvar angular = require(&#39;angular&#39;);\n\n\n//add sub module entries\n\n\nmodule.exports = angular.module(&#39;home&#39;,[\n  &#39;ngAnimate&#39;,\n  &#39;ngResource&#39;,\n  &#39;ui.bootstrap&#39;,\n  &#39;ui.router&#39;,\n  template.name\n]).config(homeRoutes)\n  .controller(&#39;homeController&#39;,homeController)\n  .controller(&#39;headerController&#39;,headerController)\n  .controller(&#39;pictureSlideController&#39;,pictureSlideController)\n  .controller(&#39;activitiesController&#39;,activitiesController)\n  .filter(&#39;activityArrayFilter&#39;,activityArrayFilter)\n  .filter(&#39;activityPublishFilter&#39;,activityPublishFilter)\n;\n</code></pre>\n<p>文件B:</p>\n<pre><code class=\"undefinedjs\">/** Created by Aquariuslt on 2016-01-15.*/\n&#39;use strict&#39;;\n\nvar async = require(&#39;async&#39;);\nvar xml2js = require(&#39;xml2js&#39;);\nvar xmlParser = new xml2js.Parser();\nvar _ = require(&#39;lodash&#39;);\n\nmodule.exports = function activitiesController($scope,$http){\n  $scope.atomList = [];\n  $scope.activitiesEntryArray =[];\n  $scope.activities = [];\n\n\n\n  init();\n\n\n  function init(){\n    async.series([\n      resetData,\n      initAtomList,\n      initActivitiesList\n    ],function(error,result){\n      console.log(&#39;error:&#39;,error);\n      console.log(&#39;result&#39;,result);\n    });\n  }\n\n  function resetData(callback){\n    $scope.atomList = [];\n    $scope.activitiesEntryArray =[];\n    $scope.activities = [];\n    callback();\n  }\n\n  function initAtomList(callback){\n    console.log(&#39;initAtomList&#39;);\n    $http({\n      url:&#39;/api/rss/activities&#39;,\n      method:&#39;GET&#39;\n    }).then(function success(response) {\n      $scope.atomList = response.data;\n      callback();\n    }, function error() {\n      $scope.atomList = [];\n      callback()\n    });\n  }\n\n  function initActivitiesList(callback){\n    console.log(&#39;initActivitiesList&#39;);\n    async.each($scope.atomList,function(item){\n      $http({\n        url:item,\n        method:&#39;GET&#39;\n      }).then(\n        function success(response){\n          console.log(&#39;getting response from &#39;,item);\n          xmlParser.parseString(response.data,function(error,result){\n            if(!_.isEmpty(error)){\n              console.log(&#39;convert xml to json error:&#39;,error);\n            }\n            $scope.activitiesEntryArray=$scope.activitiesEntryArray.concat(result.feed.entry);\n          });\n        },\n        function error(){\n          callback();\n        }\n      );\n    },function(error){\n      console.log(&#39;error in getActivities from atomList&#39;,error);\n    });\n  }\n};\n</code></pre>\n<p>打包之后的文件片段:\nP.S.此处打包 指的是仅仅用webpack完成js代码合并,打包的过程.\n没有经过压缩,变量名替换等进阶选项.</p>\n<pre><code class=\"undefinedjs\">\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n    /** Created by CUIJA on 2015-11-16.*/\n    &#39;use strict&#39;;\n\n\n    var headerController = __webpack_require__(11);\n    var homeController = __webpack_require__(12);\n    var pictureSlideController = __webpack_require__(13);\n    var activitiesController = __webpack_require__(14);\n\n    var activityArrayFilter = __webpack_require__(171);\n    var activityPublishFilter = __webpack_require__(172);\n\n    var homeRoutes = __webpack_require__(173);\n    var template = __webpack_require__(174);\n    var angular = __webpack_require__(1);\n\n\n    //add sub module entries\n    var demo = __webpack_require__(175);\n\n\n    module.exports = angular.module(&#39;home&#39;,[\n      &#39;ngAnimate&#39;,\n      &#39;ngResource&#39;,\n      &#39;ui.bootstrap&#39;,\n      &#39;ui.router&#39;,\n      template.name,\n      demo.name\n    ]).config(homeRoutes)\n      .controller(&#39;homeController&#39;,homeController)\n      .controller(&#39;headerController&#39;,headerController)\n      .controller(&#39;pictureSlideController&#39;,pictureSlideController)\n      .controller(&#39;activitiesController&#39;,activitiesController)\n      .filter(&#39;activityArrayFilter&#39;,activityArrayFilter)\n      .filter(&#39;activityPublishFilter&#39;,activityPublishFilter)\n    ;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n    /** Created by Aquariuslt on 2016-01-15.*/\n    &#39;use strict&#39;;\n\n    var async = __webpack_require__(15);\n    var xml2js = __webpack_require__(18);\n    var xmlParser = new xml2js.Parser();\n    var _ = __webpack_require__(169);\n\n    module.exports = function activitiesController($scope,$http){\n      $scope.atomList = [];\n      $scope.activitiesEntryArray =[];\n      $scope.activities = [];\n\n\n\n      init();\n\n\n      function init(){\n        async.series([\n          resetData,\n          initAtomList,\n          initActivitiesList\n        ],function(error,result){\n          console.log(&#39;error:&#39;,error);\n          console.log(&#39;result&#39;,result);\n        });\n      }\n\n      function resetData(callback){\n        $scope.atomList = [];\n        $scope.activitiesEntryArray =[];\n        $scope.activities = [];\n        callback();\n      }\n\n      function initAtomList(callback){\n        console.log(&#39;initAtomList&#39;);\n        $http({\n          url:&#39;/api/rss/activities&#39;,\n          method:&#39;GET&#39;\n        }).then(function success(response) {\n          $scope.atomList = response.data;\n          callback();\n        }, function error() {\n          $scope.atomList = [];\n          callback()\n        });\n      }\n\n      function initActivitiesList(callback){\n        console.log(&#39;initActivitiesList&#39;);\n        async.each($scope.atomList,function(item){\n          $http({\n            url:item,\n            method:&#39;GET&#39;\n          }).then(\n            function success(response){\n              console.log(&#39;getting response from &#39;,item);\n              xmlParser.parseString(response.data,function(error,result){\n                if(!_.isEmpty(error)){\n                  console.log(&#39;convert xml to json error:&#39;,error);\n                }\n                $scope.activitiesEntryArray=$scope.activitiesEntryArray.concat(result.feed.entry);\n              });\n            },\n            function error(){\n              callback();\n            }\n          );\n        },function(error){\n          console.log(&#39;error in getActivities from atomList&#39;,error);\n        });\n      }\n    };\n\n\n\n/***/ }\n</code></pre>\n<p>打包过程:\n首先webpack为了实现CommonJS的require规范\n释放出一个负责加载模块的 <code>__webpack_require__(moduleId)</code>函数.\n接着对每个js文件都进行编号.\n最后将每个js文件中用到的 <code>require(moduleName)</code>替换成自己的模块加载函数<code>__webpack_require(刚刚编号过的js文件编号)</code>\n在打包过程中,先会按照成绩解析依赖关系,如果该模块从头到尾都没有被使用过,这不会将该模块打包进去.\n66666</p>\n<pre><code class=\"undefinedjs\">(function(modules) { // webpackBootstrap\n    // The module cache\n    var installedModules = {};\n    // The require function\n    function __webpack_require__(moduleId) {\n        // Check if module is in cache\n        if(installedModules[moduleId])\n            return installedModules[moduleId].exports;\n        // Create a new module (and put it into the cache)\n        var module = installedModules[moduleId] = {\n            exports: {},\n            id: moduleId,\n            loaded: false\n        };\n        // Execute the module function\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        // Flag the module as loaded\n        module.loaded = true;\n        // Return the exports of the module\n        return module.exports;\n    }\n    // expose the modules object (__webpack_modules__)\n    __webpack_require__.m = modules;\n    // expose the module cache\n    __webpack_require__.c = installedModules;\n    // __webpack_public_path__\n    __webpack_require__.p = &quot;&quot;;\n    // Load entry module and return exports\n    return __webpack_require__(0);\n})\n</code></pre>\n<h3 id=\"preview\">Preview</h3>\n<p>Webpack等打包工具作为目前主流的前端打包工具(这个是我在2015年接触到的.可能现在又多了一批吧,日新月异的前端写法与多样化的工具).\n原生附带了各种打包时候的Option,与二次开发的插件库.</p>\n<p>接下来准备介绍目前的建站项目.</p>\n"},{"link":"2015/10/08/jrebel-configuration-with-weblogic-in-idea","title":"IntelliJ IDEA通过Jrebel热部署管理Weblogic","published":"2015-10-08T15:47:20.000Z","tags":["Weblogic","IntelliJ IDEA","Java"],"html":"<h1 id=\"idea-jrebel-weblogic\">idea通过Jrebel热部署管理Weblogic</h1>\n<blockquote>\n<p>Skip the build and redeploy process. JRebel reloads changes to Java classes, resources, and over 100 frameworks.\n以上这是Jrebel官网的介绍.Jrebel是一款热部署的IDE插件,(当然也可以脱离IDE直接使用)...\n通过热替换正在运行的类文件,减少deploy项目的等待时间,是增加Coding乐趣,延长Coder生命,杀人越货必备良药.</p>\n</blockquote>\n<h2 id=\"background\">Background</h2>\n<blockquote>\n<p>由于公司的项目规模是在挺大(架构复不复杂我还没理清,反正项目结构很复杂).\n每次deploy到weblogic上都要很多分钟,特别是后台代码的改动,必须要redeploy,一次就要3-5分钟,deploy的时候内存暴增,出来韩剧都播完一集了.\n恰好公司买了Jrebel license.所以早会使用早超生</p>\n</blockquote>\n<p><b>本配置基于以下项目配置情况,仅供参考.</b>\n<code>其实官网对普通的基本配置说的很详尽,只是因为我们的配置比较奇葩所以弄了挺久才懂</code></p>\n<blockquote>\n<ul>\n<li>使用maven构建程序,而不是通过直接的java compiler编译代码,生成artifact.</li>\n<li>使用maven去call ant构建程序,还不是直接通过maven build呢,是maven插件去读取ant配置构建..</li>\n<li>Weblogic的Server有自己定义的启动时类路径与固定参数</li>\n<li>原本部署在Weblogic是通过 weblogic redeploy命令重新部署的</li>\n</ul>\n</blockquote>\n<p><b>使用本配置之前的前置条件</b></p>\n<blockquote>\n<ul>\n<li>安装好Weblogic,配置好项目需要的类路径,参数.</li>\n<li>安装好idea的Jrebel插件</li>\n</ul>\n</blockquote>\n<h2 id=\"-\">原理浅析</h2>\n<p><code>Jrebel</code>热部署的原理,实际上是通过修改JVM的类加载方式,即在java的vm参数里面使用<code>jrebel</code>自己的java agent,\n然后在第一次编译,部署项目的时候,将生成的<code>rebel.xml</code>,放进项目target路径的classes目录下.\n通过监听<code>rebel.xml</code>中对应路径的类/静态资源文件的变化,替换到运行中的已部署的项目目录.</p>\n<pre><code class=\"undefinedxml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;application xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\nxmlns=&quot;http://www.zeroturnaround.com&quot; xsi:schemaLocation=&quot;http://www.zeroturnaround.com http://www.zeroturnaround.com/alderaan/rebel-2_0.xsd&quot;&gt;\n\n    &lt;classpath&gt;\n        &lt;dir name=&quot;D:/WorkSpace/${project.directory}/${module.name}/war_file/target/${module.name}/WEB-INF/classes&quot;&gt;\n        &lt;/dir&gt;\n    &lt;/classpath&gt;\n    &lt;web&gt;\n        &lt;link target=&quot;/&quot;&gt;\n            &lt;dir name=&quot;D:/WorkSpace/${project.directory}/${module.name}/war_file/src/main/webapp&quot;&gt;\n            &lt;/dir&gt;\n        &lt;/link&gt;\n    &lt;/web&gt;\n&lt;/application&gt;\n</code></pre>\n<p>所以,在Weblogic部署的项目中,只要所的war文件夹中包含<code>rebel.xml</code>,且部署的时候使用了<code>jrebel.jar</code> 作为javaagent替换jvm类加载方式.那么他就会\n根据<code>rebel.xml</code>中的路径进行监听,当路径中的 编译后的类文件/资源文件发生变化的时候,就会自动替换到weblogic已经部署的war文件夹对应的路径中去.</p>\n<blockquote>\n<p>通过本文的配置,可以达到如下的效果:</p>\n<ol>\n<li>通过shell/cmd 脚本使用maven命令编译一次源代码.打包生成war文件夹</li>\n<li>通过idea自带的weblogic配置执行war文件夹到服务器的部署,之后通过 其<code>update class and resources</code>进行热部署</li>\n</ol>\n</blockquote>\n<h2 id=\"weblogic-\">Weblogic配置</h2>\n<p>首先要知道weblogic本身是怎样配置的.如果weblogic的server本身有一些启动的类路径,和启动参数,此时应该将其记下.</p>\n<p>还需要知道的就是weblogic AdminServer的账号密码(废话),目标服务器的端口等基本配置</p>\n<h2 id=\"idea-\">idea 配置</h2>\n<p>idea的配置较为复杂,总体来说可以分成以下几个部分:</p>\n<h3 id=\"artifact-module-\">artifact 与 module 配置</h3>\n<h4 id=\"enable-jrebel\">enable Jrebel</h4>\n<p>如果一个project下有多个module,请为需要进行热部署/生成rebel.xml的项目enable jrebel.\n右键选中<code>module</code>-&gt;<code>jrebel</code>-&gt;<code>config module</code>勾上enable jrebel.</p>\n<h4 id=\"-artifact-module-output-\">修改 artifact与module 的output路径</h4>\n<ol>\n<li>选中对应module打开其配置,在module一栏,修改其output path 为你<code>rebel.xml</code>中想要的classpath路径</li>\n<li>在artifact一栏,对选中的artifact,修改其output path也改成<code>rebel.xml</code>的classpath路径,需要注意的是,所选的artifact必须是war_explored类型.不然压缩成war的话不能热部署</li>\n</ol>\n<h3 id=\"weblogic-server-\">weblogic server配置</h3>\n<ol>\n<li>新建一个server配置,选择<code>weblogic</code>-&gt;<code>local</code>.(应该先通过配置weblogic的安装目录,自动识别成一个application server)</li>\n<li>在Server一栏,\n<code>VM options</code>填写 上面<code>Weblogic Server的启动参数</code>\n<code>User</code>,<code>Password</code> 填写<code>weblogic AdminServer 的账号密码</code>\n<code>Domain path</code>填写weblogic server所属于的machine(机器)的路径.\n<code>Server to Launch</code>选择<code>managed</code> 下拉选择 子server\n<code>Admin host</code>填localhost\n<code>Admin post</code>默认是7001 可根据自己情况修改</li>\n<li>在Deployment一栏,<b>注意,这一步很重要</b>\n添加artifact,选择需刚刚修改过output path的artifact,\n把下面的before launch 的<code>make</code>,<code>build artifact</code>两步删掉.因为他们用的是java compiler而不是maven去构建项目,会导致build出来的代码不正确</li>\n<li>在Startup/Connection一栏\n可以看到有个run 或者 jrebel executor的配置.\n选中jrebel executor的配置.修改其<code>Pass environment variables</code>.\n添加一个键值对,名为CLASSPATH,值为 <code>weblogic 配置</code>中的<code>server类加载路径</code></li>\n</ol>\n<h2 id=\"maven-plugin-\">maven plugin配置</h2>\n<p>由于通过maven构建代码的时候如果不指定<code>rebel.xml</code>的生成目录,则默认会加载到<code>target/classes</code>中.所以在maven构建的时候需要添加参数如下,\n令整个构建程序的maven命令像这样:</p>\n<pre><code class=\"undefinedcmd\">mvn clean install\n-DskipTests=true\n-Drebel.xml.dir=D:\\WorkSpace\\{project.directory}\\{module.name}\\war_file\\target\\{module.name}\\WEB-INF\\classes\n-Drebel.generate.show=true jrebel:generate\n</code></pre>\n<p>其中跑jrebel:generate 需要maven的一个jrebel插件\n通过在项目的最高级pom.xml中添加maven jrebel plugin</p>\n<pre><code class=\"undefinedxml\">&lt;plugin&gt;\n    &lt;groupId&gt;org.zeroturnaround&lt;/groupId&gt;\n    &lt;artifactId&gt;jrebel-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.1.5&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;generate-rebel-xml&lt;/id&gt;\n            &lt;phase&gt;process-resources&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;generate&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>\n<h2 id=\"-\">配置完成,尝试运行</h2>\n<p>至此,配置应该全部完成了.\n重复刚才的结果,正常的编译一次,部署一次之后,就可以直接修改源文件看效果.</p>\n<ol>\n<li>通过shell/cmd 脚本使用maven命令编译一次源代码.打包生成war文件夹<blockquote>\n<p>这里倾向在项目目录中执行一条shell命令:(其中的{project.directory}等变量自己替换成现实的物理路径)</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<pre><code class=\"undefinedcmd\"> mvn clean install\n -DskipTests=true\n -Drebel.xml.dir=D:\\WorkSpace\\{project.directory}\\{module.name}\\war_file\\target\\{module.name}\\WEB-INF\\classes\n -Drebel.generate.show=true jrebel:generate\n</code></pre>\n<ol>\n<li>通过idea自带的weblogic配置执行war文件夹到服务器的部署,之后通过 其<code>update class and resources</code>进行热部署</li>\n</ol>\n<blockquote>\n<ol>\n<li>启动Weblogic Admin Server,但是不要启动对应的子Server</li>\n<li>点击idea server右边的jrebel executor的小按钮.进行子Server的启动代码部署</li>\n<li>Coding and hot swap</li>\n</ol>\n</blockquote>\n"},{"link":"2014/06/15/linux-export-variable-define-failed-solution","title":"Linux 用export 声明临时环境变量失败的方法","published":"2014-06-15T05:06:21.000Z","tags":["Linux"],"html":"<p>上次用export 声明了JAVA_HOME 和CLASSPATH和添加了一个PATH下的变量使得jdk指向正确，后来发现重启之后\n用echo $PATH 命令查不到对应的路径</p>\n<p>原来，用export 声明的环境变量是临时的，鸟哥私房菜没认真看逗比了.</p>\n<p>解决方法</p>\n<ol>\n<li>切换到root账户</li>\n</ol>\n<ol>\n<li>用命令gedit /etc/environment 打开环境变量修改，假设我的jdk路径是 /home/aquariuslt/jdk</li>\n</ol>\n<p>那么在打开的文件中\n输入如图</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>保存关闭</p>\n<ol>\n<li>在终端输入 gedit /etc/profile</li>\n</ol>\n<p>修改如图</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>然后重启才能生效</p>\n"},{"link":"2014/05/20/linux-openfire-server","title":"Linux搭建OpenFire服务","published":"2014-05-20T02:44:16.000Z","tags":["Linux","Openfire"],"html":"<h2 id=\"background\">Background</h2>\n<p>上周老师讲解了基于XMPP协议的即时通信应用概念，下面套用百度资料解析XMPP。</p>\n<p>中文全称:可扩展通讯和表示协议</p>\n<p>简介:可扩展通讯和表示协议 (XMPP)</p>\n<p>可用于服务类实时通讯、表示和需求响应服务中的XML数据元流式传输。XMPP以Jabber协议为基础，而Jabber是即时通讯中常用的开放式协议。XMPP is the IETF&#39;s formalization of the base XML streaming protocols for instant messaging and presence developed within the Jabber open-source community in 1999 XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线现场探测。它在促进服务器之间的准即时操作。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。 XMPP的前身是Jabber，一个开源形式组织产生的网络即时通信协议。XMPP目前被IETF国际标准组织完成了标准化工作。标准化的核心结果分为两部分； 核心的XML流传输协议 基于XMLFreeEIM流传输的即时通讯扩展应用 XMPP的核心XML流传输协议的定义使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常漂亮。 XMPP的即时通讯扩展应用部分是根据IETF在这之前对即时通讯的一个抽象定义的，与其他业已得到广泛使用的即时通讯协议，诸如AIM，QQ等有功能完整，完善等先进性。 XMPP的扩展协议Jingle使得其支持语音和视频。</p>\n<h2 id=\"-openfire\">安装OpenFire</h2>\n<p>1.下载地址：<a href=\"http://www.igniterealtime.org/downloads/index.jsp\">http://www.igniterealtime.org/downloads/index.jsp#openfire</a></p>\n<p><img src=\"\" alt=\"\"></p>\n<p>选择Linux版本下载，我这里下载tar.gz文件。</p>\n<p>2.上传到服务器上</p>\n<p>因为下载的是要解压的文件，所以上传到 /opt/ 文件夹下</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>之后用</p>\n<pre><code>tar –zxvf openfire_3_9_3.tar.gz\n</code></pre><p>解压</p>\n<p>3.在MySQL中添加数据库openfire</p>\n<p>#mysql –u root –p 登陆后</p>\n<p>创建数据库</p>\n<pre><code>create database openfire;\n</code></pre><p>导入对应的数据库文件</p>\n<pre><code>use openfire;\nsource /opt/openfire/resources/database/openfire_mysql.sql\n</code></pre><p>4.启动openfire服务</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>&nbsp;</p>\n<p>启动之后，现在可以通过你的域名/IP的9090端口访问openfire了。</p>\n<p><a href=\"http://aquariuslt.com:9090\">http://aquariuslt.com:9090</a></p>\n<ol>\n<li>配置openfire参数\n第一次进入这个9090端口的页面之后，是一个首次安装的页面</li>\n</ol>\n<p><img src=\"\" alt=\"\"></p>\n<p>进入下一页，也是继续到数据库设置页面</p>\n<p>数据库我们选择外置的数据库连接，也就是MySQL，因为刚刚已经在MySQL里面建立了数据库</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>将数据库URL中的[host]改成自己的IP或者域名,也可以设做localhost</p>\n<p>将[databasename]改成自己的数据库名字</p>\n<p>用户名和密码填写MySQL的用户名和密码</p>\n<p>下面的设置 不必多说，按照自己的喜好设定即可。</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>现在登陆到管理控制台。</p>\n<p>登录名固定为admin密码是刚刚你设置的管理员密码（一个邮箱账号+自己设定的密码，就是这个密码）</p>\n<p>Tips:因为Linux默认不开放1000以上的端口，如果在操作这部分的时候，发现9090端口不能访问，用netstat也找不到9090端口，使用下面的语句打开9090端口</p>\n<pre><code>/sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT&lt;/pre&gt;\n</code></pre><h2 id=\"-9090-\">开启9090端口</h2>\n<p>至此，安装配置Openfire完成。</p>\n"},{"link":"2015/08/31/mac-app-alternote","title":"Mac上优雅简洁的第三方Evernote客户端:AlterNote","published":"2015-08-31T06:55:33.000Z","tags":["OSX","Mac","Software"],"html":"<p>安利一个Mac OS X上的Evernote第三方客户端:AlterNote</p>\n<h3 id=\"-\">优点</h3>\n<p>界面优雅,扁平化UI.过渡动画非常流畅.比原生Evernote要好看很多.用起来非常舒爽.\n虽然有好几个重要的缺点,可是如此优雅的界面,必须满足了我的UI强迫症.</p>\n<h3 id=\"-\">缺点</h3>\n<ol>\n<li>不支持图片粘贴,只能右键空白处截屏或者导入.</li>\n<li>对Markdown支持还不完善.只能识别一些简单的Markdown标记,比如## — *</li>\n<li>如果笔记中包含大文件,处理方式比较傻逼,需要从服务器端下载一次.重复Evernote的下载量.</li>\n</ol>\n<p>放出几张张截图:\n[<img src=\"\" alt=\"AlterNote\"></p>\n"},{"link":"2016/01/15/mac-idea-15-remove-bundled-jdk","title":"Mac OS X下替换IDEA15自带的JDK","published":"2016-01-15T15:19:44.000Z","tags":["Java","IntelliJ IDEA"],"html":"<h2 id=\"background\">Background</h2>\n<p>由于最近一直在研究不同版本的JDK/JVM在不同操作系统下的字体渲染.(强迫症)\n发现<code>Mac</code>下的<code>IDEA</code>在更新到15之后,字体居然变粗了.\n从个人审美的角度看.觉得渲染不是很好看.\n通过菜单的<code>About IntelliJ IDEA</code>查看.\n发现启动运行<code>IDEA</code>的居然是<code>OpenJDK</code>.\n<img src=\"https://img.alicdn.com/tfscom/TB1H_y2LpXXXXXWXXXXXXXXXXXX.png\" alt=\"OpenJDK启动IDEA\"></p>\n<h2 id=\"solution\">Solution</h2>\n<p>解决办法相当简单.\n这是因为<code>IDEA</code>的Mac版本,在版本15之后在包内容下自带了个JDK/JRE.\n从启动的脚本来说,如果有内置的JDK/JRE,则会调用自带的JDK.</p>\n<p>在<code>应用程序</code>中右键<code>显示包内容</code>,进入<code>Contents</code>文件夹,删除<code>jre</code>文件夹即可.\n删除即可</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1xn1VLpXXXXcpXXXXXXXXXXXX.png\" alt=\"OracleJDK启动IDEA\"></p>\n"},{"link":"2015/08/07/mac-update-server-client-database-character","title":"Mac下修改MySQL编码","published":"2015-08-07T07:24:28.000Z","tags":["OSX","Mac"],"html":"<p>Windows/Mac 配置大不同,还没熟练操控ide的配置文件,回家经常搞半天.周末写不好代码心思都没了..\n1.关闭mysqld进程\n2.进入MySQL安装路径\n一般在 usr/local/mysql/ 下</p>\n<p>[<img src=\"\" alt=\"0C574640-B1A9-4FE9-81DD-E0BC18079A4F\">\n3.修改my.cnf配置文件\n添加两行:</p>\n<p>default-character-set=utf8\ncharacter-set-server=utf8\n<img src=\"\" alt=\"FF373523-398E-4421-BBEE-3764CDA16C93\"></p>\n<p>坑没完.你看看改了MySQL本身编码之后,之前创建的数据库并没有自动更改数据库级别的编码.\n在MySQL控制台输入命令:\n<img src=\"\" alt=\"28A1F66B-B3FD-4190-BC7D-E767394A049A\">\n还是latin1..\n4.修改已经存在的数据库的编码\nalter database sms CHARACTER SET UTF8;\n<img src=\"\" alt=\"9C6AEF66-E163-4F8C-BEAF-E4C0C7265E90\"></p>\n"},{"link":"2015/11/01/mean-study-project-file-structure","title":"MEAN笔记:项目结构解读","published":"2015-11-01T15:29:51.000Z","tags":["Node.js","AngularJS","Express","MongoDB"],"html":"<h2 id=\"background\">Background</h2>\n<p>终于盼来公司下一代产品的技术转型,技术逐渐从J2EE转换到MEAN Stack.\n虽然之后继续会做J2EE的Support和Development,但是接下来应该都把主要精力放在MEAN结构上.</p>\n<p>正式开始项目前两三个月正式进入技术学习准备阶段.我的分工主要是接触项目 构建,部署,打包的一些应用.</p>\n<blockquote>\n<p>  从过往的经验来说,特别是项目结构的分类,MEAN现在还没有公认的成熟的文件结构布局方案\n  开发环境,生产环境的部署,与不同 也跟Java Web有一定区别\n  这些部分都是经验之谈,必然要有遇到过不同项目结构的才能够有比较深刻的认识\n  不然选型之后遇到别人刁难当前选型就没法理据服的说出当初决定的优缺点,配合业务使用的场景</p>\n</blockquote>\n<p>通过比较几个Node.JS WebApp Generator 与 <a href=\"http://mean.io\">MEAN.IO</a>  的官方项目\n记录下初步学习的时候对项目结构的认识.方便在接下来的开发当中能够对应的进化出更科学的结构.</p>\n<h2 id=\"-\">项目比较</h2>\n<h4 id=\"express-webapp-generator\">Express WebApp Generator</h4>\n<p>Express Generator 官方生成的项目结构如下(<strong>当然没包括node_modules</strong>)</p>\n<pre><code class=\"undefinedshell\">Macbook:Express Aquariuslt$ tree -L 3\n.\n├── app.js\n├── bin\n│   └── www\n├── package.json\n├── public\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n│       └── style.css\n├── routes\n│   ├── index.js\n│   └── users.js\n└── views\n    ├── error.jade\n    ├── index.jade\n    └── layout.jade\n\n7 directories, 9 files\n</code></pre>\n<blockquote>\n<p>如果用Java Web的角度来看,routes充当了URL Mapping的角色,通过几种常见的视图解析(jade,ejs,还有后面的swig)拼装 渲染成html配合 public下的静态放行资源.\n<code>app.js</code>是服务器启动需要加载的必要配置.\n通过bin/www 脚本来启动 <code>app.js</code> 其目的只是为了分离一些基本的配置.\n正由于这个结构非常容易理解</p>\n</blockquote>\n<h4 id=\"yeoman\">Yeoman</h4>\n<pre><code class=\"undefinedshell\">Macbook:Yo Aquariuslt$ tree -L 2\n.\n├── Gruntfile.js\n├── app\n│   ├── apple-touch-icon.png\n│   ├── favicon.ico\n│   ├── fonts\n│   ├── images\n│   ├── index.html\n│   ├── robots.txt\n│   ├── scripts\n│   └── styles\n├── bower.json\n├── dist\n│   ├── apple-touch-icon.9727d3c2.png\n│   ├── bower_components\n│   ├── favicon.b25e58c4.ico\n│   ├── index.html\n│   ├── robots.txt\n│   ├── scripts\n│   └── styles\n├── package.json\n├── server.js\n└── test\n    ├── index.html\n    └── spec\n</code></pre>\n<blockquote>\n<p>Yeoman的部署方式比较接近HEXO,通过grunt task将程序要用到的js打包构建到<code>dist</code>文件夹并启动app.</p>\n</blockquote>\n<h4 id=\"mean-io-offical-demo\">Mean.io Offical Demo</h4>\n<pre><code class=\"undefinedshell\">Macbook:MEANJS Aquariuslt$ tree -L 3\n.\n├── CONTRIBUTING.md\n├── Dockerfile\n├── LICENSE.md\n├── Procfile\n├── README.md\n├── bower.json\n├── config\n│   ├── assets\n│   │   ├── cloud-foundry.js\n│   │   ├── default.js\n│   │   ├── development.js\n│   │   ├── production.js\n│   │   └── test.js\n│   ├── config.js\n│   ├── env\n│   │   ├── cloud-foundry.js\n│   │   ├── default.js\n│   │   ├── development.js\n│   │   ├── local.example.js\n│   │   ├── production.js\n│   │   └── test.js\n│   └── lib\n│       ├── app.js\n│       ├── express.js\n│       ├── logger.js\n│       ├── mongoose.js\n│       ├── multer.js\n│       ├── seed.js\n│       └── socket.io.js\n├── docker-compose.yml\n├── gruntfile.js\n├── gulpfile.js\n├── karma.conf.js\n├── manifest.yml\n├── modules\n│   ├── articles\n│   │   ├── client\n│   │   ├── server\n│   │   └── tests\n│   ├── chat\n│   │   ├── client\n│   │   ├── server\n│   │   └── tests\n│   ├── core\n│   │   ├── client\n│   │   ├── server\n│   │   └── tests\n│   └── users\n│       ├── client\n│       ├── server\n│       └── tests\n├── package.json\n├── protractor.conf.js\n├── public\n│   ├── humans.txt\n│   ├── lib\n│   │   ├── angular\n│   │   ├── angular-animate\n│   │   ├── angular-bootstrap\n│   │   ├── angular-file-upload\n│   │   ├── angular-messages\n│   │   ├── angular-mocks\n│   │   ├── angular-resource\n│   │   ├── angular-ui-router\n│   │   ├── angular-ui-utils\n│   │   ├── bootstrap\n│   │   ├── es5-shim\n│   │   ├── jquery\n│   │   └── owasp-password-strength-test\n│   └── robots.txt\n├── scripts\n│   ├── generate-ssl-certs.sh\n│   └── reset-password.js\n├── server.js\n└── test.js\n</code></pre>\n<blockquote>\n<p>这里这是本次笔记的重点.\n这是<code>mean.io</code>的官方demo.在这个项目里面,包含了使用MEAN技术栈开发的WebApp.\n涵盖了基本CRUD,登陆注册,权限校验,数据查询等Web应用常用场景.\n他的文件结构我也觉得相对来说容易看懂,并且应该能够很好的作为一个开发规范</p>\n</blockquote>\n<h3 id=\"-mean-io-\">精简mean.io项目结构</h3>\n<p>因为项目配置多且繁杂,对于我这种智商比较低的初次上手肯定没有那么容易走通全部流程,看明白其中的定义.\n所以我在相同的项目结构上,进行了功能与类库的缩减.从能够看懂的结构开始,说说我的理解.\n之后将会以一个练手的项目<code>零食管理系统-SnacksBar</code>进行一步一步的功能增加 <a href=\"https://github.com/Aquariuslt/Snacksbar\">项目地址</a></p>\n<h4 id=\"-\">精简后的项目结构</h4>\n<p>当然这是没有bower_components与node_modules</p>\n<pre><code class=\"undefinedshell\">Macbook:Snacksbar Aquariuslt$ tree -L 4\n.\n├── bower.json\n├── config\n│   ├── assets\n│   │   ├── default.js\n│   │   └── development.js\n│   ├── config.js\n│   ├── env\n│   │   ├── default.js\n│   │   ├── development.js\n│   │   └── production.js\n│   └── lib\n│       ├── app.js\n│       ├── express.js\n│       ├── logger.js\n│       └── mongoose.js\n├── modules\n│   └── home\n│       ├── client\n│       │   ├── app\n│       │   ├── config\n│       │   ├── controllers\n│       │   ├── home.client.module.js\n│       │   └── views\n│       └── server\n│           ├── controllers\n│           ├── routes\n│           └── views\n├── package.json\n├── readme.md\n└── server.js\n</code></pre>\n<p>言归正传,开始说下我对这个项目结构的理解,从Java的视角去思考项目结构.\n<code>server.js</code>作为程序入口</p>\n<h4 id=\"-\">包管理</h4>\n<p><code>package.json</code>是node的包管理信息,<code>bower.json</code>这是前端的包管理信息.作用等同maven的<code>pom.xml</code>.</p>\n<p><code>package.json</code></p>\n<pre><code class=\"undefinedjson\">{\n  &quot;name&quot;: &quot;Snacksbar&quot;,\n  &quot;version&quot;: &quot;0.0.1&quot;,\n  &quot;private&quot;: false,\n  &quot;author&quot;: &quot;Aquariuslt&quot;,\n  &quot;description&quot;: &quot;Snacksbar Management System&quot;,\n  &quot;homepage&quot;: &quot;http://github.com/Aquariuslt/Snacksbar&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https://github.com/Aquariuslt/Snacksbar.git&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;body-parser&quot;: &quot;~1.13.2&quot;,\n    &quot;chalk&quot;: &quot;^1.1.1&quot;,\n    &quot;consolidate&quot;: &quot;^0.13.1&quot;,\n    &quot;cookie-parser&quot;: &quot;~1.3.5&quot;,\n    &quot;debug&quot;: &quot;~2.2.0&quot;,\n    &quot;express&quot;: &quot;~4.13.1&quot;,\n    &quot;file-stream-rotator&quot;: &quot;0.0.6&quot;,\n    &quot;glob&quot;: &quot;^5.0.15&quot;,\n    &quot;jasmine-core&quot;: &quot;^2.3.4&quot;,\n    &quot;lodash&quot;: &quot;^3.10.1&quot;,\n    &quot;method-override&quot;: &quot;^2.3.5&quot;,\n    &quot;mongoose&quot;: &quot;^4.2.3&quot;,\n    &quot;morgan&quot;: &quot;~1.6.1&quot;,\n    &quot;serve-favicon&quot;: &quot;~2.3.0&quot;,\n    &quot;swig&quot;: &quot;^1.4.2&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;gulp&quot;: &quot;^3.9.0&quot;,\n    &quot;gulp-livereload&quot;: &quot;^3.8.1&quot;\n  }\n}\n</code></pre>\n<p>简要解析下 用到的一些类库(<strong>当然是我大概了解其功能的了</strong>)\n<code>body-parser</code>,<code>cookie-parser</code>,<code>express</code> Express 开发N件套,顾名思义是一些解析器.\n<code>chalk</code>,用于帮助在控制台花式输出各种颜色的log\n<code>lodash</code>,在此中的用处就是拼接json变量.将几份json形式的变量合并在一起.\n<code>mongoose</code>,连接MongoDB的中间件\n<code>swig</code>,一个前台的视图,相当于JavaWeb中的<code>ViewResolver</code>,有点像模板拼接.</p>\n<p><code>bower.json</code></p>\n<pre><code class=\"undefinedjson\">{\n  &quot;name&quot;: &quot;Snacksbar&quot;,\n  &quot;description&quot;: &quot;Snacksbar Management System&quot;,\n  &quot;homepage&quot;: &quot;http://github.com/Aquariuslt/Snacksbar&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;dependencies&quot;: {\n    &quot;bootstrap&quot;: &quot;~3&quot;,\n    &quot;angular&quot;: &quot;~1.3&quot;,\n    &quot;angular-resource&quot;: &quot;~1.3&quot;,\n    &quot;angular-animate&quot;: &quot;~1.3&quot;,\n    &quot;angular-mocks&quot;: &quot;~1.3&quot;,\n    &quot;angular-bootstrap&quot;: &quot;~0.13&quot;,\n    &quot;angular-ui-utils&quot;: &quot;bower&quot;,\n    &quot;angular-ui-router&quot;: &quot;~0.2&quot;,\n    &quot;angular-file-upload&quot;: &quot;1.1.5&quot;,\n    &quot;angular-messages&quot;: &quot;~1.3.17&quot;\n  },\n  &quot;resolutions&quot;: {\n    &quot;angular&quot;: &quot;~1.3&quot;\n  }\n}\n</code></pre>\n<h3 id=\"-workflow\">整体Workflow</h3>\n<p>整体的workflow大概便是:通过<code>node server.js</code>启动服务器,服务器加载配置,监听端口,运行.</p>\n<h4 id=\"-server-js-\">通过<code>server.js</code>启动服务器</h4>\n<p><code>server.js</code>内容如下,只有短短两行.</p>\n<pre><code class=\"undefinedJavaScript\">var app = require(&#39;./config/lib/app&#39;);\nvar server = app.start();\n</code></pre>\n<h4 id=\"-app-start-\"><code>app.start()</code> 监听端口,启动服务器</h4>\n<p><code>app.js</code>内容如下,实际上是先通过初始化<code>express</code>的一系列配置</p>\n<pre><code class=\"undefinedJavaScript\">&#39;use strict&#39;;\n\nvar config = require(&#39;../config&#39;);\nvar express = require(&#39;./express&#39;);\nvar mongoose = require(&#39;./mongoose&#39;);\n\n\nfunction init(callback) {\n  console.log(&quot;Init server environment configurations.&quot;);\n  mongoose.connect(function (db) {\n    var app = express.init(db);\n    if (callback) {\n      callback(app, db, config);\n    }\n  });\n}\n\nfunction start(callback) {\n  var self = this;\n  self.init(function (app, db, config) {\n    app.listen(config.port, function () {\n      console.log(&quot;----Environment Settings----&quot;);\n      console.log(&quot;Port:&quot; + config.port);\n      if (callback) {\n        callback(app, db, config);\n      }\n    });\n  });\n  console.log(&quot;Server Start&quot;);\n}\n\nmodule.exports.init = init;\nmodule.exports.start = start;\n</code></pre>\n<h4 id=\"-express-init-express-\"><code>express.init()</code> Express的初始化</h4>\n<p><code>express</code>也是启动的启动的配置文件之一,可以将express的初始化过程看做服务器端的启动过程:\n经过简化之后,服务器启动的过程可以分成如下几部:(并不是纯翻译,而是方法名本身就代表了其意义)</p>\n<ol>\n<li>initLocalVariables(app);         <code>加载全局环境配置</code></li>\n<li>initViewEngine(app);             <code>加载视图渲染</code></li>\n<li>initMiddleware(app);             <code>加载中间件</code></li>\n<li>initModulesConfiguration(app);   <code>加载模块配置</code></li>\n<li>initModulesClientRoutes(app);    <code>加载浏览器端路由</code></li>\n<li>initModulesServerRoutes(app);    <code>加载服务器端路由</code></li>\n</ol>\n<pre><code class=\"undefinedJavaScript\">var config = require(&#39;../config&#39;);\nvar express = require(&#39;express&#39;);\nvar morgan = require(&#39;morgan&#39;);\nvar bodyParser = require(&#39;body-parser&#39;);\nvar path = require(&#39;path&#39;);\nvar consolidate = require(&#39;consolidate&#39;);\nvar logger = require(&#39;./logger&#39;);\nvar methodOverride = require(&#39;method-override&#39;);\n\nfunction initLocalVariables(app) {\n  app.locals.title = config.app.title;\n  app.locals.description = config.app.description;\n  app.locals.host = config.host;\n\n  app.locals.jsFiles = config.files.client.js;\n  app.locals.cssFiles = config.files.client.css;\n  app.locals.livereload = config.livereload;\n\n\n  // Passing the request url to environment locals\n  app.use(function (req, res, next) {\n    res.locals.host = req.protocol + &#39;://&#39; + req.hostname;\n    res.locals.url = req.protocol + &#39;://&#39; + req.headers.host + req.originalUrl;\n    next();\n  });\n}\n\nfunction initSession(app, db) {\n\n}\n\nfunction initViewEngine(app){\n  app.engine(&#39;server.view.html&#39;,consolidate[config.templateEngine]);\n\n  app.set(&#39;view engine&#39;,&#39;server.view.html&#39;);\n  app.set(&#39;views&#39;,&#39;./&#39;);\n}\n\nfunction initMiddleware(app){\n  app.use(morgan(logger.getFormat(), logger.getOptions()));\n  app.use(bodyParser.urlencoded({\n    extended: true\n  }));\n  app.use(bodyParser.json());\n  app.use(methodOverride());\n}\n\nfunction initModulesClientRoutes(app){\n  app.use(&#39;/&#39;,express.static(path.resolve(&#39;./bower_components&#39;)));\n\n  config.folders.client.forEach(function (staticPath) {\n    console.log(&quot;Client Route:&quot;+staticPath);\n    app.use(staticPath, express.static(path.resolve(&#39;./&#39; + staticPath)));\n  });\n}\n\nfunction initModulesServerRoutes(app){\n  config.files.server.routes.forEach(function (routePath) {\n    require(path.resolve(routePath))(app);\n  });\n}\n\nfunction initModulesConfiguration (app, db) {\n  config.files.server.configs.forEach(function (configPath) {\n    require(path.resolve(configPath))(app, db);\n  });\n}\n\nfunction init(db) {\n  var app = express();\n  initLocalVariables(app);\n  initSession(app, db);\n  initViewEngine(app);\n  initMiddleware(app);\n  initModulesConfiguration(app);\n  initModulesClientRoutes(app);\n  initModulesServerRoutes(app);\n  return app;\n}\n\n\nmodule.exports.init = init;\n</code></pre>\n<h5 id=\"-\">加载全局环境配置</h5>\n<p><code>initLocalVariable()</code>方法主要是将配置文件读取 并且防止到app中作为运行时可获得的环境变量.</p>\n<pre><code class=\"undefinedJavaScript\">function initLocalVariables(app) {\n  app.locals.title = config.app.title;\n  app.locals.description = config.app.description;\n  app.locals.host = config.host;\n\n  app.locals.jsFiles = config.files.client.js;\n  app.locals.cssFiles = config.files.client.css;\n  app.locals.livereload = config.livereload;\n\n\n  // Passing the request url to environment locals\n  app.use(function (req, res, next) {\n    res.locals.host = req.protocol + &#39;://&#39; + req.hostname;\n    res.locals.url = req.protocol + &#39;://&#39; + req.headers.host + req.originalUrl;\n    next();\n  });\n}\n</code></pre>\n<p>因为config是从<code>config.js</code>里面抽取出来的,先看看<code>config.js</code>里面做了什么操作.\n因为WebApp通常会分成生产环境,开发环境等不同environment.\n所以config主要分成<code>development</code>,<code>production</code>两种.\n在config中手修改填写对应配置,或者通过函数根据运行时参数决定执行的是哪一种配置.</p>\n<p>在config的代码中,他会遍历搜索<code>assets</code>与<code>env</code>文件夹下的配置(虽然是js文件,但是通过<code>exports</code>返回的是一个json格式的变量),\n然后根据对应的环境变量(一般是<code>development</code>或<code>production</code>),将其与<code>default.js</code>中的变量融合在一起.\n接着将融合之后的一个json内容作为总的配置,传给<code>app</code>作为参数使用.</p>\n<blockquote>\n<p>这里的融合(merge)相当有趣,是一个很方便的轮子.\n它能够将 两份配置文件,相同的父节点下的子节点合并,最终融合成一个新的节点.\n举个例子:\n融合两个json A与B\nA:</p>\n<pre><code class=\"undefinedjson\">{\n &quot;name&quot;:&quot;Aquariuslt&quot;,\n &quot;level&quot;:100,\n &quot;skills&quot;:[\n   &quot;愤怒&quot;,&quot;星火术&quot;\n ]\n}\n</code></pre>\n<p>B:</p>\n<pre><code class=\"undefinedjson\">{\n &quot;item-level&quot;:&quot;655&quot;,\n &quot;skills&quot;:[\n   &quot;星涌术&quot;\n ]\n}\n</code></pre>\n<p>融合成</p>\n<pre><code class=\"undefinedjson\">{\n  &quot;name&quot;:&quot;Aquariuslt&quot;,\n  &quot;level&quot;:100,\n  &quot;item-level&quot;:&quot;655&quot;,\n  &quot;skills&quot;:[\n    &quot;愤怒&quot;,&quot;星火术&quot;,&quot;星涌术&quot;\n  ]\n}\n</code></pre>\n</blockquote>\n<p><code>config.js</code></p>\n<pre><code class=\"undefinedJavaScript\">&#39;use strict&#39;;\n\nvar lodash = require(&#39;lodash&#39;);\nvar glob = require(&#39;glob&#39;);\nvar chalk = require(&#39;chalk&#39;);\nvar path = require(&#39;path&#39;);\nvar defaultConfig = require(&#39;./env/default&#39;);\nvar environmentConfig = require(&#39;./env/development&#39;) || {};\nvar defaultAssets = require(&#39;./assets/default&#39;);\nvar environmentAssets = require(&#39;./assets/development&#39;)||{};\n\nfunction validateEnvironmentVariable() {\n  var environmentFiles = glob.sync(&#39;./config/env/&#39; + process.env.NODE_ENV + &#39;.js&#39;);\n  if (!environmentFiles.length) {\n    if (process.env.NODE_ENV) {\n      console.error(chalk.red(&#39;Error: No configuration file found for &quot;&#39; + process.env.NODE_ENV + &#39;&quot; environment using development instead&#39;));\n    } else {\n      console.error(chalk.red(&#39;Error: NODE_ENV is not defined! Using default development environment&#39;));\n    }\n    process.env.NODE_ENV = &#39;development&#39;;\n  }\n  // Reset console color\n}\n\nfunction initGlobalConfig() {\n  //merge assets\n  var assets = lodash.merge(defaultAssets,environmentAssets);\n  //merge config\n  var config = lodash.merge(defaultConfig, environmentConfig);\n  console.log(&quot;Merge config complete&quot;);\n  validateEnvironmentVariable();\n  //set other config\n  initGlobalConfigFolders(config,assets);\n  initGlobalConfigFiles(config,assets);\n  return config;\n}\n\nfunction initGlobalConfigFolders(config) {\n  // Appending files\n  config.folders = {\n    server: {},\n    client: {}\n  };\n\n  // Setting global client paths\n  config.folders.client = getGlobalPaths(path.join(process.cwd(), &#39;modules/*/client/&#39;), process.cwd().replace(new RegExp(/\\\\/g), &#39;/&#39;));\n}\n\nfunction initGlobalConfigFiles(config, assets) {\n  config.files = {\n    server: {},\n    client: {}\n  };\n\n  config.files.server.models = getGlobalPaths(assets.server.models);\n  config.files.server.routes = getGlobalPaths(assets.server.routes);\n  config.files.server.configs = getGlobalPaths(assets.server.config);\n  config.files.server.sockets = getGlobalPaths(assets.server.sockets);\n  config.files.server.policies = getGlobalPaths(assets.server.policies);\n  config.files.client.js = getGlobalPaths(assets.client.lib.js, &#39;bower_components/&#39;).concat(getGlobalPaths(assets.client.js, [&#39;bower_components/&#39;]));\n  config.files.client.css = getGlobalPaths(assets.client.lib.css, &#39;bower_components/&#39;).concat(getGlobalPaths(assets.client.css, [&#39;bower_components/&#39;]));\n  config.files.client.tests = getGlobalPaths(assets.client.tests);\n\n  console.log(&quot;assets.server.routes:&quot;+assets.server.routes);\n  console.log(&quot;config.files.server.routes:&quot;+config.files.server.routes);\n  console.log(&quot;config.files.client.js:&quot;+config.files.client.js);\n  console.log(&quot;config.files.client.css:&quot;+config.files.client.css);\n}\n\nfunction getGlobalPaths(globPatterns, excludes) {\n  // URL paths regex\n  var urlRegex = new RegExp(&#39;^(?:[a-z]+:)?\\/\\/&#39;, &#39;i&#39;);\n\n  // The output array\n  var output = [];\n\n  // If glob pattern is array then we use each pattern in a recursive way, otherwise we use glob\n  if (lodash.isArray(globPatterns)) {\n    globPatterns.forEach(function (globPattern) {\n      output = lodash.union(output, getGlobalPaths(globPattern, excludes));\n    });\n  }\n  else if (lodash.isString(globPatterns)) {\n    if (urlRegex.test(globPatterns)) {\n      output.push(globPatterns);\n    }\n    else {\n      var files = glob.sync(globPatterns);\n      if (excludes) {\n        files = files.map(function (file) {\n          if (lodash.isArray(excludes)) {\n            for (var i in excludes) {\n              file = file.replace(excludes[i], &#39;&#39;);\n            }\n          }\n          else {\n            file = file.replace(excludes, &#39;&#39;);\n          }\n          return file;\n        });\n      }\n      output = lodash.union(output, files);\n    }\n  }\n\n  return output;\n}\n\n\nmodule.exports = initGlobalConfig();\n</code></pre>\n<h5 id=\"-\">加载视图解析器</h5>\n<p><code>initViewEngine()</code>方法主要是提供<code>Express</code>使用的视图解析器.\n其实这个概念跟Java SpringMVC 中的视图解析器非常相似.\n在Spring MVC 的配置文件中,启用视图解析器 一般是通过下面这段配置:</p>\n<pre><code class=\"undefinedxml\">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;\n    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>这就是最常见的,也是默认的<code>InteralResourceViewResolver</code>.\n上面这段xml的主要内容是,当URL Mapping要返回的是一个视图的时候,将会根据要返回的视图的名字<code>{view-name}</code>,\n去<code>/WEB-INF/views</code>文件夹下,查找一个名字为<code>{view-name}</code>,后缀为<code>.jsp</code>的文件.\n即拼接成<code>/WEB-INF/views/{view-name}.jsp</code>的文件作为基本视图,再拼接一些返回过去的model等attribute渲染成实际的页面效果.</p>\n<p>同理,下面这份初始化视图解析器的代码,内容如下:\n首先,解析一下变量<code>consolidate[config.templateEngine]</code>,其值为 <code>swig</code>.\n表明,以<code>server.view.html</code>作为文件后缀的,都以<code>swig</code>类型的解析方法作为视图解析.\n然后,将默认的视图解析 设置成<code>server.view.html</code>类型.\n最后,选择URLMapping对应的视图解析模板的根目录,表明将从该目录开始寻找视图模板.</p>\n<pre><code class=\"undefinedJavaScript\">function initViewEngine(app){\n  app.engine(&#39;server.view.html&#39;,consolidate[config.templateEngine]);\n\n  app.set(&#39;view engine&#39;,&#39;server.view.html&#39;);\n  app.set(&#39;views&#39;,&#39;./&#39;);\n}\n</code></pre>\n<blockquote>\n<p><code>Express</code>中,常见的视图类型有<code>ejs</code>,<code>jade</code>,<code>swig</code>等.\n其中<code>jade</code>与<code>ejs</code>作为<code>Express</code>的默认视图解析器\n<code>jade</code>的特点是,像编写配置文件一样去写html,然后变量通过server端传过来替换,但是并不适合只熟悉html编码的前端与后端整合\n<code>ejs</code>其实与<code>swig</code>有点像,都基本是html格式,外加特定的变量解析符号.类似于jsp的jstl标签替换.\n<code>swig</code>则是之前接触<code>HEXO</code>的时候遇到的一种,与普遍的swig文件拼接相同,(窝猜可能是就是用C去实现的)`</p>\n</blockquote>\n<h5 id=\"-\">加载中间件</h5>\n<p>经过简化之后的<code>initMiddleware</code> 其实只做了几个功能:\n启动logger(指定了log的一些格式)\n启动express的配套组件<code>bodyParser</code>(这部分还没看懂,sorry)</p>\n<pre><code class=\"undefinedJavaScript\">function initMiddleware(app){\n  app.use(morgan(logger.getFormat(), logger.getOptions()));\n  app.use(bodyParser.urlencoded({\n    extended: true\n  }));\n  app.use(bodyParser.json());\n  app.use(methodOverride());\n}\n</code></pre>\n<blockquote>\n<p>根据个人理解,目前认为中间件大部分的作用是一种 类似切面编程的概念,即在代码中添加方便,可插拔的功能</p>\n</blockquote>\n<h5 id=\"-\">加载加载模块配置,服务器端与客户端所有路由</h5>\n<p>这三个方法放在一起说吧\n三个方法,其实都是修改了 app内部的变量值,\n通过扫描<code>config.js</code>中的内容,将路径以数组形式添加到app的环境变量里.</p>\n<p><code>config/assets/default.js</code>中涉及转化的部分</p>\n<pre><code class=\"undefinedJavaScript\">module.exports = {\n  client: {\n    lib: {\n      css: [\n        dest,\n        dest\n      ],\n      js: [\n        &#39;bower_components/angular/angular.js&#39;,\n        &#39;bower_components/angular-resource/angular-resource.js&#39;,\n        &#39;bower_components/angular-animate/angular-animate.js&#39;,\n        &#39;bower_components/angular-messages/angular-messages.js&#39;,\n        &#39;bower_components/angular-ui-router/release/angular-ui-router.js&#39;,\n        &#39;bower_components/angular-ui-utils/ui-utils.js&#39;,\n        &#39;bower_components/angular-bootstrap/ui-bootstrap.js&#39;,\n        &#39;bower_components/angular-bootstrap/ui-bootstrap-tpls.js&#39;,\n        &#39;bower_components/angular-file-upload/angular-file-upload.js&#39;,\n        dest\n        ],\n      tests: [&#39;bower_components/angular-mocks/angular-mocks.js&#39;]\n    },\n    css: [\n      &#39;modules/*/client/css/*.css&#39;\n    ],\n    less: [\n      &#39;modules/*/client/less/*.less&#39;\n    ],\n    sass: [\n      &#39;modules/*/client/scss/*.scss&#39;\n    ],\n    js: [\n      &#39;modules/home/client/app/config.js&#39;,\n      &#39;modules/home/client/app/init.js&#39;,\n      &#39;modules/*/client/*.js&#39;,\n      &#39;modules/*/client/**/*.js&#39;\n    ],\n    views: [&#39;modules/*/client/views/**/*.html&#39;],\n    templates: [&#39;build/templates.js&#39;]\n  },\n  server: {\n    gulpConfig: &#39;gulpfile.js&#39;,\n    allJS: [\n      &#39;server.js&#39;,\n      &#39;config/**/*.js&#39;,\n      &#39;modules/*/server/**/*.js&#39;\n    ],\n    models: &#39;modules/*/server/models/**/*.js&#39;,\n    routes: [\n      &#39;modules/!(home)/server/routes/**/*.js&#39;,\n      &#39;modules/home/server/routes/**/*.js&#39;\n    ],\n    sockets: &#39;modules/*/server/sockets/**/*.js&#39;,\n    config: &#39;modules/*/server/config/*.js&#39;,\n    policies: &#39;modules/*/server/policies/*.js&#39;,\n    views: &#39;modules/*/server/views/*.html&#39;\n  }\n};\n</code></pre>\n<p>实际上就是讲 client和server的<code>routes</code>文件夹下的所有文件扫了一遍,将其相对路径,放进环境变量的数组中.</p>\n<pre><code class=\"undefinedJavaScript\">function initModulesClientRoutes(app){\n  app.use(&#39;/&#39;,express.static(path.resolve(&#39;./bower_components&#39;)));\n\n  config.folders.client.forEach(function (staticPath) {\n    console.log(&quot;Client Route:&quot;+staticPath);\n    app.use(staticPath, express.static(path.resolve(&#39;./&#39; + staticPath)));\n  });\n}\n\nfunction initModulesServerRoutes(app){\n  config.files.server.routes.forEach(function (routePath) {\n    require(path.resolve(routePath))(app);\n  });\n}\n\nfunction initModulesConfiguration (app, db) {\n  config.files.server.configs.forEach(function (configPath) {\n    require(path.resolve(configPath))(app, db);\n  });\n}\n</code></pre>\n<hr>\n<p>其实对MEAN.JS官方DEMO的项目结构还是非常的走马观花,接下来必须先开搞一下AngularJS才能够理解前端与后端的较好交互方式,方便下一步功能的添加.\n将Java Server端的知识点与概念 转移到JavaScript方式去实现与使用,希望能够慢慢的加深面向对象语言的共同点,增强技术广度,突破现有的技术深度.</p>\n"},{"link":"2016/01/27/modulization-javascript-in-my-sight","title":"模块化JavaScript之我见","published":"2016-01-27T14:02:55.000Z","tags":["JavaScript","AngularJS","Node.js"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近接触了<code>MEAN</code>相关技术栈和实际项目开发有一段时间.\n在过程中公司同事也开展了多次Share Meeting去科普一些常见的技术点.\n鉴于已经对模块化JavaScript有了一定的实践,本次总结一下我所理解的JavaScript模块化.</p>\n<h2 id=\"javascript-\">JavaScript 发展历史</h2>\n<h3 id=\"-javascript-\">我的JavaScript践行史</h3>\n<p>对JavaScript的认识比较曲折,刚接触的时候觉得是一门乱来的语言.\n为什么说他乱来,因为JavaScript有很多糟糕的特性.\n当时体验到的最大的几个问题是:</p>\n<ol>\n<li>没有块级作用域名.</li>\n<li>隐式的全局变量.</li>\n</ol>\n<blockquote>\n<p>对于第一点&quot;没有块级作用域&quot;,摘录<a href=\"\">JavaScript:The Good Parts</a>一书.\nJavaScript的语法来源于C,在所有其他类似C语言风格的语言里,一个代码块 {} h会创造一个作用域.\n在 {} 代码块中声明的变量在其外部是不可见的.\nJavaScript采用了这样的块语法.但没有提供块级作用域:\n在JavaScript的代码块 {} 中声明的变量,在包含此代码块的函数的任何位置都是可见的.</p>\n<p>对于第二点&quot;隐式的全局变量&quot;,初衷可能是为了方便初学者,有意让变量在使用前无需声明,\n而JavaScript解析器帮你自动识别并当做是全局变量.导致debug难度变大.</p>\n</blockquote>\n<h4 id=\"-\">学生时期:乱来</h4>\n<p>大学的时候有一门课大概是&quot;Web开发&quot;.杂讲HTML/CSS/JS&quot;.\n当时用到JS的情况是做一些简单的DOM操作,加一些简单的移动效果.\n当时觉得JS可恶心了,还是因为JQuery这个库用了<code>$</code>符号作为window的全局变量.</p>\n<blockquote>\n<p>在使用JS的时候,对JS特性没有了解.所有函数都是全局函数,通过传参数进去调用.\n仅仅通过文件名的分割进行逻辑上的分成.</p>\n</blockquote>\n<h4 id=\"-extjs-4-2\">实习时期:ExtJS 4.2</h4>\n<p><code>ExtJS</code>对企业级应用相当有利.特别是 <code>ExtJS</code>,有着无比强大的Grid组件.\n实习时期的项目,前端UI的渲染部分全部通过<code>ExtJS 4.2 MVC</code>完成.\n在实际项目中的实践中,通过各种花式CRUD的case,了解整个<code>ExtJS</code>的常用API.</p>\n<blockquote>\n<p>虽然功能能够按部就班地完成,但是还是有很多不符合<code>JSLint</code>中的地方\n字面过很多JS的特性,并没有深刻的理解</p>\n</blockquote>\n<h4 id=\"-extjs-3-3-angularjs-1-5\">工作之后:ExtJS 3.3 + AngularJS 1.5</h4>\n<p>毕业之后换到了另一个组,由于项目开始时间更长一点,前端用的是跟<code>ExtJS 4.2</code>API有较大出入的<code>3.3</code>\n此前做了几件对JS理解有质的飞跃的几件事情:</p>\n<blockquote>\n<ol>\n<li><p>因为一些业务需求,发现原生的<code>ExtJS</code>并没有符合需求的组件,\n为了贴合需求,尽量以科学的方式编写代码\n为<code>ExtJS</code>进行一些自定义组件的开发.\n在编写过程中阅读了本身一些组件的源代码及实现\n扩展了视野</p>\n</li>\n<li><p>阅读了<a href=\"\">JavaScript:The Good Parts</a>一书.\n这本书是<code>JSLint</code>作者之一,JS大师<code>Douglas Crockford</code>出品.\n里面系统的吐槽了<code>JavaScript</code>的一些辣鸡特性,顺便为<code>JavaScript</code>的一些优点正名.\n最后通过<code>JSLint</code>这个作品为<code>JavaScript</code>洗地,让我对<code>JavaScript</code>的认识上了一个层次.\n其实就是说<code>JavaScript</code>是一门<code>抽烟喝酒纹身打架但他还是个好男人</code>的语言.(应该是基于成王败寇)\n只要按照<code>JSLint</code>的规范,约束去编写代码,则能够使得代码更加健壮,优雅.</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"-javascript-\">宏观JavaScript发展</h3>\n<p>宏观的JavaScript模块化发展历史,可以分成以下几个阶段:</p>\n<h4 id=\"-\">起源</h4>\n<p>起源: 在JS诞生之后的若干年,在项目发展到越来越大的时候,JS代码缺少一个科学有效的解决命名冲突,文件依赖解决方案.\n以<code>将JS代码以文件形式分割</code>的落后约定.</p>\n<p>那时候,所有的函数都是全局函数,只能靠命名来解决唯一性</p>\n<pre><code class=\"undefinedjs\">function refreshPage(){\n  window.location.reload();\n}\n\nfunction showSubmitButton(){\n  document.getElementById(&#39;submitFormButton&#39;).setAttribute(&#39;style&#39;,&#39;display:block&#39;);\n}\n</code></pre>\n<h4 id=\"package-\">Package命名方式</h4>\n<p>类似Java的包命名方式一样,使用多级的包命名</p>\n<pre><code>com.aquariuslt.utils.refreshPage = function(){\n\n}\n</code></pre><p>在<code>ExtJS 3.3</code>中要使用这种包命名的方式,则变成了</p>\n<pre><code>Ext.ns(&#39;com.aquariuslt&#39;);\ncom.aquariuslt.ui.bookingUi=Ext.extend(Ext.Viewport,{\n   layout:&#39;fit&#39;,\n   initComponent:function(){\n      var self=this;\n\n      Ext.applyIf(self,{\n         xtype:&#39;container&#39;,\n         items:[\n            {\n               xtype:&#39;panel&#39;,\n               ```metadata {  } ```&quot;title&quot;:&#39;Booking Search&#39;\n            }\n         ]\n      });\n   }\n});\nExt.reg(&#39;com.aquariuslt.ui.bookingUi&#39;,com.aquariuslt.ui.bookingUi);\n</code></pre><p>在<code>ExtJS 4</code>中,则变成了</p>\n<pre><code>Ext.define(&#39;Booking.view.BookingCreateView&#39;,{\n    extend:&#39;Ext.container.Viewport&#39;,\n\n    id:&#39;BookingCreateViewPort&#39;,\n    itemId:&#39;BookingCreateViewPort&#39;,\n\n    layout:&#39;fit&#39;,\n\n\n    initComponent:function(){\n        var self=this;\n\n        Ext.applyIf(self,{\n            xtype:&#39;container&#39;,\n            items:[\n                {\n                    xtype:&#39;panel&#39;,\n                    id:&#39;bookingPanel&#39;,\n                    border:false,\n                    layout:&#39;border&#39;,\n                    dockedItems:[\n                        {\n                            /*1.Booking Request Title*/\n                            xtype:&#39;panel&#39;,\n                            dock:&#39;top&#39;,\n                            frame:true,\n                            id:&#39;bookingCreateHeaderPanel&#39;,\n                            bodyCls:&#39;allPadding&#39;,\n                            border:false,\n                            items:[\n                                {\n                                    xtype: &#39;container&#39;,\n                                    region: &#39;north&#39;,\n                                    cls: &quot;pageTitleLevel leftRightPadding&quot;,\n                                    layout: {\n                                        type: &#39;hbox&#39;,\n                                        align: &#39;stretch&#39;\n                                    },\n                                    items: [\n                                        {\n                                            xtype: &#39;label&#39;,\n                                            cls: &#39;pageTitle&#39;,\n                                            id: &#39;bookingCreatePageTitle&#39;,\n                                            text: &#39;Booking Request - New&#39;\n                                        }\n                                    ]\n                                }\n\n                            ]\n                        }\n\n                    ],\n                    items:[\n                        /*2.Carrier and Traffic Mode*/\n                        {\n                            xtype:&#39;panel&#39;,\n                            id:&#39;bookingCreateCarrierInfoPanel&#39;,\n                            frame:true,\n                            ```metadata {  } ```&quot;title&quot;:&#39;Carrier&#39;,\n                            cls:&#39;allPadding&#39;,\n                            region:&#39;north&#39;,\n                            border:false,\n                            layout:&#39;column&#39;,\n                            items:[\n\n                            ]\n                        }\n\n\n                    ]\n                }\n            ]\n        });\n\n        self.callParent(arguments);\n\n    }\n});\n</code></pre><h4 id=\"-\">闭包自执行</h4>\n<p>还有一种与<code>JQuery</code>风格的匿名函数自执行</p>\n<pre><code class=\"undefinedjs\">(function(window){\n    window.jQuery = window.$ = jQuery;\n})(window);\n</code></pre>\n<h2 id=\"javascript-\">JavaScript 模块化实践</h2>\n<p>关于JavaScript的模块化,我是从接触<code>Node.js</code>的编写方式之后才开始真正实践起来.</p>\n<h3 id=\"amd-requirejs-cmd-\">AMD,RequireJS与CMD规范</h3>\n<blockquote>\n<p>此处AMD,RequireJS,CommonJS规范说明出自<a href=\"http://www.cnblogs.com/dolphinX/p/4381855.html\">前端模块化-Samaritans-博客园</a></p>\n</blockquote>\n<h4 id=\"amd-requirejs\">AMD 与 RequireJS</h4>\n<p>AMD 即<code>Asynchronous Module Definition</code>，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范</p>\n<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出</p>\n<p>requireJS主要解决两个问题</p>\n<p>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\njs加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</p>\n<h4 id=\"cmd\">CMD</h4>\n<p>CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<p>语法\nSea.js 推崇一个模块一个文件，遵循统一的写法</p>\n<h4 id=\"commandjs\">CommandJS</h4>\n<p>CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。\n根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。\n输出模块变量的最好方法是使用module.exports对象。</p>\n<pre><code>var i = 1;\nvar max = 30;\n\nmodule.exports = function () {\n  for (i -= 1; i++ &lt; max; ) {\n    console.log(i);\n  }\n  max *= 1.1;\n};\n</code></pre><p>上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。\n加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。</p>\n<h3 id=\"reference\">Reference</h3>\n<blockquote>\n<ol>\n<li><a href=\"https://github.com/seajs/seajs/issues/547\">前端模块化的价值</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/nodejs-module-mechanism\">深入Node.js的模块化机制</a></li>\n</ol>\n</blockquote>\n"},{"link":"2016/07/05/move-to-new-apartment","title":"蜗居","published":"2016-07-05T14:02:55.000Z","tags":["Diary"],"html":"<h2 id=\"-\">前言</h2>\n<p>毕业差不多有一年了,毕业时候租的一年的房子也到期了.<br>适逢有同事已经住到15年新建好的唐家人才公寓那边,那边房子环境不错,打听到详细情况后,发现最吸引我的还是里面两点:  </p>\n<blockquote>\n<ol>\n<li>里面没有家具,需要自己购置   </li>\n<li>合同是跟华发物业签而非个人房东  </li>\n</ol>\n</blockquote>\n<p>这两点真的是太适合我了,一方面是租房合同可以随时终止,而且不用跟各种恶毒的个人房东打交道,二是新交的房子没有家具.\n就不用担心租到不合适的房子看到家具风格不搭心里长草.</p>\n<p>从提交申请,审核,到正式通知抽签选房,签合同入住大概经历了快三个月.<br>三月初提交的申请,劳动节之后终于通知下来去抽签.  </p>\n<p>一层的户型图大概如下图:\n从结构上分,个人申请只能申请一房一厅或者单身公寓了.<br><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgw1f5nswirc5fj30zk0my42b.jpg\" alt=\"IMG_0916.JPG\">\n抽到了个08户型,一房一厅,实用面积才30多.</p>\n<h2 id=\"-\">布置</h2>\n<h3 id=\"-\">空无一物的房间</h3>\n<p>签完合同刚拿到房子的时候,房间里面除了空调和稍微有点像样的厨房灶台之后,其他空无一物,显得比较空洞.<br>大概是这样子的:  </p>\n<h4 id=\"-\">空洞的过道</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5ntaislpcj31kw23u1i4.jpg\" alt=\"空洞的过道\"></p>\n<h4 id=\"-\">空洞的客厅</h4>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgw1f5ntaknst1j31kw23ue5u.jpg\" alt=\"空洞的客厅\"></p>\n<h4 id=\"-\">空洞的睡房</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5ntanbwkbj31kw23ue7y.jpg\" alt=\"空洞的睡房\"></p>\n<h4 id=\"-\">空洞的厨房</h4>\n<p><img src=\"http://ww1.sinaimg.cn/large/006tNbRwgw1f5ntadsxnvj31kw23ux4c.jpg\" alt=\"空洞的厨房\"></p>\n<h4 id=\"-\">空洞的阳台</h4>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgw1f5ntaqatgsj31kw23ub29.jpg\" alt=\"空洞的阳台\"></p>\n<h3 id=\"-\">购置刚需家具</h3>\n<p>距离之前租的房子大概还有半个月到期,购置刚需家具就成了午休时间的任务.<br>由于我已经有一张黑胡桃色的电脑桌,所以整体的家具都选用棕色/黑胡桃色吧.<br>根据刚需的优先级,大概列了一下:  </p>\n<blockquote>\n<p>拐角电脑桌 &gt;= 床 &gt; 电脑椅 &gt;&gt; 书柜 &gt;&gt; 衣柜 </p>\n</blockquote>\n<p>家电的话,大概就只有</p>\n<blockquote>\n<p>洗衣机 &gt;&gt; 电饭煲</p>\n</blockquote>\n<h3 id=\"-\">安装与布置</h3>\n<p>陆续请了几个半天年假去办妥水电网络等各种开通手续之后,床和拐角电脑桌也送到了.\n花了一个下午才把他们装好.\n接着爸妈给我送来了窗帘和碗碟,还有一些大大小小的厨具~</p>\n<p>五月下旬住进去之后一直没有买书柜和室内的晾衣架,直到前几天才送到,感觉现在就差个舒适的床垫就完美了~  </p>\n<p>下面是上图时间:  </p>\n<h4 id=\"-\">大门过道就加了一个垫子</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5nze6dxhqj31kw23u7rf.jpg\" alt=\"21:37:44.jpg\"></p>\n<h4 id=\"-\">只有骨架的电脑桌</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5nzfqeev8j31kw2t4hdt.jpg\" alt=\"21:39:14.jpg\"></p>\n<h4 id=\"-\">上百螺丝还要反过来装</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5nzstrui8j31kw23unoc.jpg\" alt=\"21:51:48.jpg\"></p>\n<h4 id=\"-m18-p2415q-2414h-\">安装完毕 配上西昊M18 P2415Q+2414H 强 无敌</h4>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgw1f5nzxwv747j31kw16ok78.jpg\" alt=\"21:56:42.jpg\"></p>\n<h4 id=\"-\">原来的电脑桌变成了饭桌</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5nzymbcpmj31kw16onej.jpg\" alt=\"21:57:22.jpg\"></p>\n<h4 id=\"-\">室内衣架和一个杂物柜</h4>\n<p><img src=\"http://ww3.sinaimg.cn/large/006tNbRwgw1f5nz6fvo2vj31kw23ue5w.jpg\" alt=\"21:30:18.jpg\"></p>\n<h4 id=\"-\">低到类似榻榻米的床与床头柜</h4>\n<p><img src=\"http://ww2.sinaimg.cn/large/006tNbRwgw1f5nz4wdp7sj31kw16owvj.jpg\" alt=\"21:28:49.jpg\"></p>\n<h4 id=\"-\">楼再高一点就是海景啦</h4>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgw1f5o02np97tj31kw23unp4.jpg\" alt=\"22:01:15.jpg\"></p>\n<h2 id=\"-\">憧憬</h2>\n<p>配置齐全 感觉每天晚上专注 <del>学习</del> 的时间变长了.\n<code>wakatime</code>的report \n<img src=\"http://ww1.sinaimg.cn/large/006tNbRwgw1f5o0br69xbj31kw0kmtc0.jpg\" alt=\"22:10:03.jpg\"></p>\n<p><img src=\"http://ww4.sinaimg.cn/large/006tNbRwgw1f5o0lgzik4j30q209adgk.jpg\" alt=\"22:19:24.jpg\"></p>\n<p>希望在如此好的环境中,学习和工作效率会变得越来越高~</p>\n"},{"link":"2014/07/12/no-title-diary-july-12","title":"无题","published":"2014-07-12T07:15:00.000Z","tags":["Diary"],"html":"<p>生活中总会有些不如意的事情，所以有时候心情不好，便语无伦次起来。</p>\n<p>最近看到一些不会编程的颓废青年也开始因为工作要求开始接触IOS,Android开发了，而我也在接触自动化测试的学习与运用，写写脚本，调试脚本，熟悉下HTML，但与我想要学习的技术还是有一定区别的。</p>\n<p>我明白实际项目是提升技术水平最快的一个途径，我的主要目的是在工作中提升自己的能力，不断丰富自己的知识。虽然是在做名为自动化测试的脚本开发，但是我的方向是习武有用武之地，满足感还是比前者要强。专业分方向之后，由于应用项目的关系，我修的是移动开发方向，却完成了商业开发方向的项目内容，现在又接触自动化测试并且上手得很快，我觉得我已经可以一个打三个，当然，三个是那种不太上心的水平。</p>\n<p>现在看到自己一直看不起的某些人，因为工作任务接到了关于Android、IOS、HTML5相关的开发任务，他们总觉得压力很大因为他们根本不会编程，但是我知道如果熬过了初始的上手阶段，他们的能力会得到很大提升，技术水平。当然我没有去到那个能够忽略很多喽啰的技术水平高度，所以我才会发下牢骚。为了能够保持自己的水平远超同学，我很久之前就开始朝着在专业知识方面“我不止要比自己的专业方向的同学厉害，我还要超越其他方向的同学，还要跟更好的层次的同学比”的境界去，所以平时上课学Android，下课尝试结合SSH做服务器端、现在上班开发测试脚本、晚上回去看公司Android组的开发资料，速度不够别人的三倍，就会在某一方面被人追上。</p>\n<p>三人行，必有我师焉，意思是要其他人总有值得你学习的地方。这是当然的，必然要吸取其他人的优点，虚心请教。但是我的目标是在专业方面至少达到“一个打十个”的水平，才能对得起我付出的汗水。</p>\n<p>真正的大神我当然见过，我也知道要达到他们的技术不仅仅是努力才能够达到的，还要把握时机，抓准方向。</p>\n<p>一直在看海贼王，你看路飞索隆、亦或是世界级水平的角色，哪有天天抱怨待遇不公，都是充满自信，努力提升自己，因为目标是世界级的。</p>\n<p>[<img src=\"\" alt=\"索隆锻炼\"></p>\n<p>所以为了继续增强自己的实力，只好增强效率，加快完成自己的工作，把工作内容做好无可挑剔之后，再去听其他开发组的会议，各种吸收，之前做的这么多通宵都撑过来了，这短时间修炼过后，相信应该可以去新世界有所作为了。</p>\n<p>我可不只跟你比。</p>\n"},{"link":"2015/12/14/nodejs-libclntsh-so-11-1-cannot-open-shared-object-file","title":"Linux \"libclntsh.so.11.1 cannot open shared object file no such file or directory\"解决方案","published":"2015-12-14T08:48:46.000Z","tags":["Ubuntu","Linux","Oracle","Node.js"],"html":"<h2 id=\"description\">Description</h2>\n<p><code>Ubuntu 14.04</code>\n<code>node v4.2.3</code>\n<code>oracledb v1.4.0</code>\n在正常安装好<code>Node.js</code>和<code>oracledb</code>,之后,用到oracledb的那一步就开始提示这个错误;\n重新跑<code>npm install</code>不能解决问题</p>\n<h2 id=\"rootcause\">RootCause</h2>\n<p><code>LD_LIBRARY_PATH</code>没有设置好.\n我将OracleInstantClient的安装目录的路径,释放在当前用户的环境变量中.\n即将<code>export LD_LIBRARY_PATH=XXXX</code>写在当前user的<code>.bashrc</code>中\n导致terminal中启动的时候,读不到LB_LIBRARY_PATH变量.\n如果运行如下命令,没有设置环境变量的话,可以通过该解决方案解决.</p>\n<pre><code>locate libclntsh.so.11.1\n</code></pre><h2 id=\"solutions\">Solutions</h2>\n<p>将环境变量设置在<code>/etc/profile</code>中,问题解决.</p>\n"},{"link":"2016/01/11/nodejs-oracledb-install-on-rhel-6","title":"RHEL(CentOS)6环境下安装node-oracledb","published":"2016-01-11T15:53:07.000Z","tags":["Node.js","Linux"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近准备升级一下PROD服务器上的<code>node-oracledb</code>版本.\n但是遇到一个很奇怪的现象,就是我本地无法构建出服务器上可用的<code>oracledb</code>.\n(因为部署方式是打包部署而不是从<code>git</code>拉代码部署)</p>\n<p>一开始以为是<code>C++运行库</code>的原因.\n因为又仔细读了一遍<code>node-oracledb</code>的官方安装文档,发现<code>oracledb</code>在编译的时候,只支持支持<code>C++11</code>的编译器.</p>\n<p>立马查看本地环境的<code>gcc</code>版本与运行库版本<code>glibc</code></p>\n<pre><code>gcc -v\nldd --version\n</code></pre><p>发现本地<code>CentOS 6.6</code>版本自带的<code>gcc</code>版本是4.4,<code>glibc</code>版本是2.12\n但是支持编译和运行C++11新特性的<code>gcc</code>版本是4.7+,<code>glibc</code>版本是2.14+\n这.版本都不一样怎么玩.</p>\n<h2 id=\"rootcause\">RootCause</h2>\n<p>马上比较了一下 本地构建<code>oracledb</code>与服务器的各种版本\n发现相关的版本信息如下:</p>\n<blockquote>\n<p>服务器\nOS:RedHat Enterprise Linux 6.6\ngcc Version:4.4 (Red Hat)\nglibc Version:2.12\nnode Version:v0.10.38\nnpm Version:1.4.28(npm版本应该不会影响构建,预防万一还是提及一下)\nnode-gyp Version:不明.因为没权限调用该命令.\noracle instantclient Version:11.2</p>\n<p>本地环境\nOS:CentOS 6.7 x64\ngcc Version:4.4 (Red Hat)\nglibc Version:2.12\nnode Version:v4.2.4\nnpm Version:2.14.8\nnode-gyp Version:3.2.1\noracle instantclient Version:11.2</p>\n</blockquote>\n<h2 id=\"solution\">Solution</h2>\n<p>思前想后,想想也不知道<code>node.js</code>本身版本到底会对<code>oracledb</code>的构建有什么影响.\n毕竟<code>oracledb</code>官方对构建时的<code>C++11</code>编译支持的要求先入为主了</p>\n<p>最后还是决定先切换一下<code>node.js</code>版本,结果问题顺利解决</p>\n<pre><code class=\"undefinedsh\">$npm install n\n$n v0.10.38\n$npm install oracledb\n</code></pre>\n<p>构建成功.</p>\n"},{"link":"2016/01/12/nodejs-oracledb-ora-21561-solution","title":"Node.js oracledb \"ORA-21561 - OID generation failed\" 解决方案","published":"2016-01-12T04:55:31.000Z","tags":["Node.js","Linux"],"html":"<h2 id=\"background\">Background</h2>\n<p>千辛万苦在虚拟机的<code>CentOS 6</code>下编译好<code>oracledb</code>,运行时报错\n&quot;ORA-21561 - OID generation failed&quot;</p>\n<h2 id=\"solution\">Solution</h2>\n<p>原因是虚拟机下的<code>CentOS</code>连接到oracle服务器的时候,本地没有有效的连接名称(机器名)\n<a href=\"http://chaos667.tumblr.com/post/20006357466/ora-21561-and-oracle-instant-client-112\">Origin Post</a></p>\n<p>需要在<code>hosts</code>列表中添加本地的机器名.\n假设我local机器名为<code>centos-vm</code></p>\n<pre><code class=\"undefinedsh\">sudo gedit /etc/hosts   (vi也行)\n</code></pre>\n<p>查找<code>127.0.0.1</code> 在对应的hostname后面添加<code>centos-vm</code>,即本机器名</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB17d0.LpXXXXXpXpXXXXXXXXXX.png\" alt=\"修改CentOS hosts文件\"></p>\n<p>重启即可.</p>\n"},{"link":"2014/11/11/oocl-inner-interview-experience","title":"OOCL内部面试经历","published":"2014-11-11T15:01:04.000Z","tags":["Diary"],"html":"<h2 id=\"-\">面试经历</h2>\n<p>面试官主观问题：</p>\n<ol>\n<li>有关Java线程安全\n场景是 当服务器和用户 同时对一个数据进行操作的时候，如何保证 数据的安全是期望修改的形式？具体场景可能是 你在评论一条微博的时候，那个微博被删除了，从线程安全来说 是Java本身具有这种控制现成安全的方法，还是需要自己实现？</li>\n</ol>\n<p>这个问题，我想面试官本来是想考 线程锁和 或者Thread的Sync和Volite关键字\n，是两个线程同时对共享数据进行操作，是否需要对数据进行上锁。</p>\n<p>我当时想的是，在实际项目中主要不是线程锁的问题吧，是如何处理使得当要修改的数据不能访问的时候 为了用户体验一般是怎样处理？抑或说是类似代码版本管理中，如果同时提交了多个分支 默认应该取哪个？然后面试官说，这个问题是类似于版本分支这个概念\n 先后顺序，怎样告诉用户的。于是我先回答了个线程锁的概念，然后跳到Android那里 用AsyncTask的概念，线程内部重载doInBackground方法,再通知更新UI。又感觉好像服务器和用户请求之间没有一个权重比较，就说了个用队列去保存请求，然后根据请求的顺序锁起数据，服务器请求在先就先删掉服务器端的数据，然后用户请求到达的时候，返回提示微博可能已被删除，而不刷新页面。用户请求在先，评论请求发送完毕之后，立刻执行服务器的删除微博请求，更新UI的时候以服务器的更新UI方法为重，返回提示微博可能已经被删除。</p>\n<ol>\n<li>说说项目中的修改之后 相比以前有没有什么收获比较大的地方\n我这里就说之前项目中的内容，在修改使用了Spring MVC架构之后 降低了代码的耦合度，使得能够后台的代码与页面设置分开出来，减少了以后维护代码的成本。然后想到Android开发 本身就是界面，控制器 很系统的分开，就把学习Android的时候的对这种模式的理解。\n这里记得逼乎上面有个 解答，我觉得这里的概念有帮助与理解\n<a href=\"http://www.zhihu.com/question/19703369\">http://www.zhihu.com/question/19703369</a></li>\n</ol>\n<ol>\n<li>有关Spring MVC的问题：Spring是单例还是多例?\n这个问题跪了。</li>\n</ol>\n<p>正确答案是Spring 默认是单例，但是可以通过修改bean里面scope的属性修改，使得在单例中调用多里对象。</p>\n<p>半命题自由发挥部分：</p>\n<ol>\n<li><p>说我的项目之前使用MySQL，对数据库的安全操作有没有什么比较深刻的认识？\n第一次在项目中用JDBC搞MySQL的CRUD的时候，对数据库的操作是传参数 然后拼接成SQL字符串，这样的漏洞有一个很明显的地方就是注入漏洞，如果在参数里面包含多个其他操作使得原本应该拼接成的字符串实现了其他的数据库操作，就算是被注入了。\n后来改成使用PreparedStatement 来操作SQL，他本身能够对传进去的参数进行处理，防止在参数中有SQL关键字和分号，注释符号 等非代码本意的字符串出现。增加了一部分的安全性\n然后又说到之前 做项目，添加文章发布功能的时候，要使用可视化文本编辑器，怎么搞图片一边上传的解决方法。</p>\n</li>\n<li><p>因为我现在主要做的工作是自动化测试脚本的编写，平时回去的时间有没有关注技术，是Java Web方面，Android方面，还是现在的脚本开发...</p>\n</li>\n<li>现在在做的Web自动化测试 你觉得那些方便挑战比较大？\n学习过程的挑战目前都被克服了</li>\n</ol>\n<h2 id=\"-\">贡献：</h2>\n<ol>\n<li><p>改进脚本之间的数据传递方式(Global Sheet --&gt;外部文件xml/Excel)\n以前公司的ATF框架 在不同的脚本之前传递数据是通过一个存在内存中的GlobalSheet变量来传递的，我修改了代码之后，使用外部文件比如Excel或者XML来保存要传递的数据，使得脚本执行玩完之后，在生成的报告和排查过程中有了更客观的数据展示。</p>\n</li>\n<li><p>改进数据驱动方式\n之前ATF的数据驱动方式 主要是通过Excel方式来进行数据驱动。但是受限制与WinRunner与QTP本身读取Excel配置文件的限制。使用Excel在数据读取的可观性不够强，而且存在 数组设计，数据说明比较麻烦的情况。后来的改进方法是将数据存在XML里面，XML所具有的特性使得数据更加直观，还能在XML内部提供更好的注释、说明 帮助负责运行脚本的同事修改数据。\n使用XML作为数据文件，为以后公司系统统一切换到IRIS4 使用更先进的自动化测试框架 增加了通用的数据模型可用。</p>\n</li>\n<li><p>修改对象识别的方式\n对象库到XPath\n之前使用的QTP工具 大多数脚本都是通过对象库来对Web对象进行识别。\n但是这样做 代码的可读性上会比较强，但是依赖于工具本身的不可见的内部数据，不利于 根据外部数据来使用和移植</p>\n</li>\n</ol>\n<p>修改成以XPath方式来读取，代码移植性与对象描述能力得到了增强。</p>\n"},{"link":"2015/12/27/outlook-msg-file-eml-conversion-tool","title":"轮子:Microsoft Outlook .msg 文件解析转换 .eml 文件","published":"2015-12-27T07:57:07.000Z","tags":["Node.js","Java"],"html":"<h2 id=\"background\">Background</h2>\n<p>因为项目中遇到了一个比较正常的需求,就是用户可能会上传一份由软狗导出的.msg文件,\n然后读出里面的内容,在解析成.eml(通用的email message)格式.</p>\n<p>Google许久,发现Node.js并没有现成的lib能够解析.msg文件.\n想起了之前使用Java和VBS是有现成的类库的,所以打算用一个比较危险的方式,即\n使用node创建一个shell子进程,然后执行java命令,调用jar去解析文件.</p>\n<h2 id=\"link\">Link</h2>\n<p><a href=\"https://github.com/Aquariuslt/MsgFileConversionTool\">Github</a></p>\n<h2 id=\"usage\">Usage</h2>\n<ol>\n<li><p>构建jar</p>\n<pre><code class=\"undefinedsh\">$mvn clean package\n</code></pre>\n</li>\n<li><p>转换文件\n参考 <code>example.js</code>\n可以传三个参数进去<code>source</code>,<code>target</code>,<code>messageId</code></p>\n<blockquote>\n<p><code>source</code> 是源.msg文件路径(确保存在)\n<code>target</code> 是目标生生成的文件路径\n<code>messageId</code> 可选参数,将自定义的messageId赋予给所生成的 eml 文件的 messageId</p>\n</blockquote>\n</li>\n</ol>\n"},{"link":"2016/01/01/review-2015","title":"Year in Review 2015","published":"2016-01-01T13:50:12.000Z","tags":["Diary"],"html":"<blockquote>\n<p>2016新年伊始,回顾2015年时间线.</p>\n</blockquote>\n<h2 id=\"-macbook\">入手第一台Macbook</h2>\n<p>我是在苹果推出<code>Retina</code>屏幕之后才开始关注<code>Macbook</code>系列的.\n源于在大学中对字体的纠结.从<code>Windows</code>令人诟病的字体渲染方案,到使用<code>mactype</code>魔改本机的字体配置,\n到最后还是觉得屏幕中展示的效果不够美观.几乎失去了打开IDE的想法.\n再衍生到与<code>Linux</code>的羁绊,几乎把所有发行吧<code>Linux</code>都装了个遍,原生UI都丑哭了,虽然自由度大,环境好可是比<code>Windows</code>还丑.\n那就更不能玩了..</p>\n<p>最后还是在大四,省吃俭用终于入手了第一台<code>Retina Macbook Pro 13&#39;inch 2015</code>.\n再也没有借口不去写代码了..</p>\n<p>入手RMBP之后的那段时间,好像正是AFK的那段时间.\n真的就没主动打开过WOW了.</p>\n<p>正是由于有动力打开IDE,在下班的时候把陆续毕业设计做完,顺利完成真.毕业设计.\n<img src=\"https://img.alicdn.com/tfscom/TB1ahn5LXXXXXa5XpXXXXXXXXXX.jpg\" alt=\"开箱\">\n<img src=\"https://img.alicdn.com/tfscom/TB1DQz_LXXXXXcQXXXXXXXXXXXX.jpg\" alt=\"RMBP\"></p>\n<blockquote>\n<p>从此每天都背着电脑上班.\n就算没机会拿出来,也感觉是编程灵感的来源.\n讲真,我的编程能力有了质的飞跃</p>\n</blockquote>\n<h2 id=\"-\">毕业</h2>\n<blockquote>\n<p>1999-2015.\n不算上幼稚园和学前班 16年的学校生涯终于结束了.\n(其实好想不劳而获能读研究生,哈哈)\n想到自己失去了学生的身份,伤感.\n但是我想,在技术的层面上,更加能够专注的从实际应用中学习了.\n毕竟不会再被学校中一些无聊,过时的课程影响正常的学习计划.</p>\n</blockquote>\n<h3 id=\"-\">毕业设计</h3>\n<p>毕业设计题目是<code>基于XMPP协议的多平台消息推送的研究与实现</code>,这个选题其实有点坎坷.\n我毕业论文的导师,我一直敬仰他,因为他是确实能够将实际技术运用起来,并且确实能够在遇到困难时很快提供\n有效的关键字,帮助学生解决问题.</p>\n<p>所以在预选毕业论文的时候,我立马就联系了他,想选他当导师.\n然而一个老师只有十几个名额,跟老师做过项目的童鞋已经内定了名额,实际上只剩下两个名额\n于是十来名同学最后约战办公室,都希望能争夺这两个名额.</p>\n<p>聚集一堂的时候,老师也厅看得起我.立马就填了我的名字.\n岂料祸从口出&quot;蟹蟹老师,那我先回去上班了啊&quot;,&quot;你在实习啊,那不行,没时间把项目搞完,这个毕业论文很紧的&quot;.</p>\n<p>囧.这样我又失去了机会.\n后来还是老师联系到我,说如果我可以自己提一个选题,\n他也许能够在选题的基础上给我提一些意见,把握好大致方向.\n最后我提了我的想法,结果就被改成了现在的这个题目.</p>\n<p>紧接着联系到了整个本科四年用到的知识连贯起来才能写完\n用到了软狗的<code>WindowsPhone</code>,<code>JavaWeb</code>,<code>Android</code>.还有一些开源协议上的应用.\n特别是在Linux下的部署</p>\n<p>最后论文修改了八次去重了一次,终于把论文修改好了.\n我的毕业设计虽然名字高大上,内容平庸.但是从头到尾纯手打,倒过来也是自己写的.</p>\n<p>加上学校比较弱鸡,大部分的毕业论文都比较辣鸡,就评了个优秀.</p>\n<h3 id=\"-\">毕业照</h3>\n<p>那么快就到了6月27.传说中拍毕业照的日子.</p>\n<p>还是初中的死党过来帮我拍照.\n<img src=\"https://img.alicdn.com/tfscom/TB1zIzOLXXXXXcoXVXXXXXXXXXX.jpg\" alt=\"大合照\">\n<img src=\"https://img.alicdn.com/tfscom/TB1mjPMLXXXXXcVXVXXXXXXXXXX.jpg\" alt=\"...不敢放了\"></p>\n<h3 id=\"-\">找房子</h3>\n<p>公司附近其实是有便宜的城中村的,但是没物管也没保安,财产得不到保证.\n于是就找了中大那边的教师公寓,复式,够大,恰好家具也很不low.\n<img src=\"https://img.alicdn.com/tfscom/TB1J827LXXXXXaTXpXXXXXXXXXX.png\" alt=\"\">\n<img src=\"https://img.alicdn.com/tfscom/TB1OMYHLXXXXXaUaXXXXXXXXXXX.jpg\" alt=\"\">\n<img src=\"https://img.alicdn.com/tfscom/TB1Glb2LXXXXXXgXFXXXXXXXXXX.jpg\" alt=\"\">\n<img src=\"https://img.alicdn.com/tfscom/TB1d_YSLXXXXXaeXVXXXXXXXXXX.jpg\" alt=\"\">\n<img src=\"https://img.alicdn.com/tfscom/TB11NzJLXXXXXcLXVXXXXXXXXXX.jpg\" alt=\"\"></p>\n<p>环境什么都好,就是上网慢还不给拉光纤.\n一台99块的路由器要供10+台终端上网,还只有8M的总带宽,自然不稳定.</p>\n<h3 id=\"ita\">ITA</h3>\n<p>毕业之后耍了几天.\n进入公司之后,是一段时间的入职培训.\n他们把这个阶段叫做ITA(IT Academy)</p>\n<p>正是这段日子,趁机把<code>Clean Code</code>,<code>Head First-Desgin Pattern</code>看完,把实习的时候不明不白的地方,逐条击破.\n顺便阅读了下Spring的一些源码.</p>\n<p>不得不说<code>Clean Code</code>真的是一本看起来很爽的书.\n看的过程中得到了与作者的很多共鸣,也给了科学的代码命名,结构编排方式.一发解决困扰依旧多年的变量,方法命名习惯.\n再结合补完设计模式一书之后,以前很多程序结构上的问题也释然了.\n能够独当一面Hold住项目的程度也大大提升了</p>\n<p>然后在ITA也遇到了很多新的小伙伴.来自武大,吉珠,北理珠和中国政法大学的研究生转行的大大.\n<img src=\"https://img.alicdn.com/tfscom/TB1yzvKLXXXXXXQaXXXXXXXXXXX.jpg\" alt=\"ITA Team3 小分队\"></p>\n<h2 id=\"-idea-license\">入手Idea License</h2>\n<p>自从使用了Idea之后,再也没法打开Eclipse了.\n可是想起在实习的时候,遇到了问题,需要请教大大来帮忙DEBUG,大大不会用Eclipse,那我就只好再用Eclipse打开一次项目,太麻烦了.</p>\n<h3 id=\"-idea\">研究Idea</h3>\n<p>为了造福身边热爱Coding的小伙伴,为了不再打开Eclipse.我决定深入研究Idea各种配置与使用方式,同时提升自己的技术水平,不被那种等级的问题所困扰.\n于是在官网爬了官方文档个月有余,全方位了解了Idea各种使用方式.</p>\n<h3 id=\"-idea\">推广Idea</h3>\n<p>算上毕业之前接触的<code>Android Studio</code>部分,大概有一年半多的Idea使用经验,已经能够成为公司内部的Idea普法大使.\n在我的安利下,目测已经有16位同事使用Idea(包含了4位后来又反水回归Eclipse的)做Java/MEAN开发.</p>\n<p>毕业之前用的是注册机生成的Idea序列号.\n毕业之后,适逢Idea 15版本更新,并且自己也已经有正式收入了.\n决定正式购买Idea License.</p>\n<p>为了加大推广Idea的力度,故申请了个微信公众号,定期推送Idea相关文章.\n<img src=\"https://img.alicdn.com/tfscom/TB1R9DOLXXXXXX5XVXXXXXXXXXX.jpg\" alt=\"IDE Skill微信公众号:codingskills\"></p>\n<h2 id=\"-\">新的圈子</h2>\n<h3 id=\"-\">新同事</h3>\n<p>正式进入到工作岗位之后(卧槽这语气怎么感觉这么官腔,好像我不是一个Programmer一样),结识到了同部门的新同事和领导.\n可能大都是年轻人,所以平时交流起来氛围都比较轻松\n领导貌似也厅看得起我,有几个Item都是关于现有项目的性能优化而不是CRUD,\n最近接手HK的MEAN相关项目也挺有挑战的,感觉恰好是以前学到的知识底蕴都有的发挥了.能够学以致用,再边做边学,全面提升技术栈强度.</p>\n<h2 id=\"-\">展望</h2>\n<p>在2015年\n逐渐清晰了人生的方向,\n更明确了自己的价值观,\n能力也有了客观的提升,\n同时也摆脱了很多羁绊.</p>\n<p>虽然失去了一些重要的东西,\n新的一年,\n变得更强.</p>\n"},{"link":"2016/03/06/site-code-structure","title":"Site项目结构介绍","published":"2016-03-06T15:09:34.000Z","tags":["Node.js","JavaScript"],"html":"<h2 id=\"background\">Background</h2>\n<p>应该说是第一个Node.js建站项目.\n目的是用于替换JavaWeb的后台\n而且可以在过程中练习一下调节样式的水平.</p>\n<p>项目本身的结构是从<a href=\"https://github.com/Dantemo/JShelf\">JShelf</a>开始.\n是由于公司内部组织了一次MEAN的一些入门分享.\n分成了几个小组,我们小组根据对MEAN的认识魔改了这样一个基本的项目基础结构.\n在其原本的结构上.做了做了一些蛋疼的修改\n大概是根据<code>npm install</code>的提示,更换lib的名字或者升级lib的版本到最新版.\n然后删除了一些没必要的模块.</p>\n<p>目前已经在我的VPS上运行,<a href=\"http://aquariuslt.com\">主站</a>是目前的效果.</p>\n<h2 id=\"agenda\">Agenda</h2>\n<p>整个项目的结构从以下几个部分开始介绍,但是在过程中会交错穿插一点互相引用的地方.</p>\n<ul>\n<li>运作思路</li>\n<li>代码结构</li>\n<li>构建过程</li>\n<li>运行准备</li>\n</ul>\n<h2 id=\"thought\">Thought</h2>\n<p>从Coding的角度出发,<code>Node.js</code>作为服务器端语言的优势之一就是不需要编译,直接重启node进程即可.\n而前端代码呢,在开发的时候,我们希望能够达到所见即所得的方式,即html+样式的修改能够直接呈现在页面上.\n在生产环境的时候,为了加快访问速度,对前端代码进行必要的打包,压缩,混淆等操作.</p>\n<p>作为单页应用的一部分,希望能够进行自动引入所需的js文件,不需要手动维护首页html里面的</p>\n<pre><code class=\"undefinedhtml\">&lt;script src=&quot;after-respondent.md&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>按照这个想法,理想中的前端开发顺序希望是这样:</p>\n<ul>\n<li><p>开发环境</p>\n<blockquote>\n<ol>\n<li>以符合<code>RequireJS规范</code>编写前端代码</li>\n<li>前端的html,css,js代码一旦有改动,且通过了IDE的jshint与html格式化检查,立刻热替换到所展示的页面中</li>\n</ol>\n</blockquote>\n</li>\n<li><p>生产环境</p>\n<blockquote>\n<ol>\n<li>将写好的前端代码打包</li>\n<li>服务器将前端的首页,以及打包后的js,css文件,释放出一个可访问的url作为前端资源文件的全部</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"code-structure\">Code Structure</h2>\n<h3 id=\"folder-treeview\">Folder TreeView</h3>\n<p>首先我们来看一下项目的目录结构:</p>\n<blockquote>\n<p>这是一个遍历到子文件夹5层的项目结构目录.\n已经去除 <code>node_modules</code>文件夹和IDE的文件夹</p>\n</blockquote>\n<pre><code>├── dist\n│   ├── build\n│   │   ├── bundle.css\n│   │   ├── bundle.js\n│   │   ├── fonts\n│   │   │   ├── glyphicons-halflings-regular.eot\n│   │   │   ├── glyphicons-halflings-regular.svg\n│   │   │   ├── glyphicons-halflings-regular.ttf\n│   │   │   ├── glyphicons-halflings-regular.woff\n│   │   │   └── glyphicons-halflings-regular.woff2\n│   │   └── index.html\n│   └── tmp\n│       └── templates.js\n├── gulp\n│   ├── client\n│   │   ├── assets.js\n│   │   ├── browserify.js\n│   │   ├── clean.js\n│   │   ├── default.js\n│   │   ├── fonts.js\n│   │   ├── images.js\n│   │   ├── index.js\n│   │   ├── minify.js\n│   │   ├── serve.js\n│   │   ├── styles.js\n│   │   ├── templates.js\n│   │   ├── watch.js\n│   │   ├── watchify.js\n│   │   ├── webpack-watch.js\n│   │   └── webpack.js\n│   ├── config.js\n│   ├── index.js\n│   └── server\n│       ├── index.js\n│       └── server.js\n├── gulpfile.js\n├── node_modules\n├── package.json\n├── readme.md\n├── server.js\n├── src\n│   ├── client\n│   │   ├── home\n│   │   │   ├── controllers\n│   │   │   │   ├── activities.controller.js\n│   │   │   │   ├── header.controller.js\n│   │   │   │   ├── home.controller.js\n│   │   │   │   └── picture.slide.controller.js\n│   │   │   ├── filters\n│   │   │   │   ├── activity.array.filter.js\n│   │   │   │   └── activity.publish.filter.js\n│   │   │   ├── index.js\n│   │   │   ├── routes\n│   │   │   │   └── home.routes.js\n│   │   │   ├── styles\n│   │   │   │   ├── about.css\n│   │   │   │   ├── angular-ui-bootstrap.css\n│   │   │   │   ├── bootstrap-theme.css\n│   │   │   │   ├── bootstrap.css\n│   │   │   │   ├── common.css\n│   │   │   │   └── home.css\n│   │   │   └── views\n│   │   │       ├── home.about.html\n│   │   │       ├── home.footer.html\n│   │   │       ├── home.header.html\n│   │   │       └── home.index.html\n│   │   ├── index.html\n│   │   └── index.js\n│   └── server\n│       └── home\n│           ├── config\n│           │   └── activities.config.js\n│           ├── controllers\n│           │   └── activities.controller.js\n│           └── routes\n│               └── home.routes.js\n└── tree.txt\n\n2381 directories, 10428 files\n</code></pre><h3 id=\"review-with-java-web-project\">Review with Java-Web Project</h3>\n<p>回想一下使用maven进行依赖管理的简单Java Web项目.\n大致是以下一种目录:</p>\n<pre><code>├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   └── com\n│   │   │       └── aquariuslt\n│   │   └── webapp\n│   │       ├── WEB-INF\n│   │       │   ├── mvc-dispatcher-servlet.xml\n│   │       │   └── web.xml\n│   │       ├── booking-create.html\n│   │       └── js\n│   │           ├── booking\n│   │           └── extjs\n│   └── test\n│       └── java\n│           └── com\n│               ├── aquariuslt\n│               └── springapp\n└── target\n    ├── ITA-BookingUI\n    │   ├── META-INF\n    │   │   └── MANIFEST.MF\n    │   ├── WEB-INF\n    │   │   ├── classes\n    │   │   │   └── com\n    │   │   ├── lib\n    │   │   │   ├── aopalliance-1.0.jar\n    │   │   │   ├── commons-logging-1.2.jar\n    │   │   │   ├── freemarker-2.3.23.jar\n    │   │   │   ├── jackson-core-asl-1.9.13.jar\n    │   │   │   ├── jackson-mapper-asl-1.9.13.jar\n    │   │   │   ├── servlet-api-2.5.jar\n    │   │   │   ├── spring-aop-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-beans-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-support-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-core-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-expression-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-web-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-webmvc-4.2.0.RELEASE.jar\n    │   │   │   └── tomcat-servlet-api-7.0.63.jar\n    │   │   ├── mvc-dispatcher-servlet.xml\n    │   │   └── web.xml\n    │   ├── booking-create.html\n    │   └── js\n    │       ├── booking\n    │       │   ├── BookingCreateApp.js\n    │       │   ├── controller\n    │       │   └── view\n    │       └── extjs\n    │           ├── ext-all-debug.js\n    │           ├── ext-theme-neptune\n    │           └── resources\n    ├── ITA-BookingUI.war\n    ├── classes\n    │   └── com\n    │       └── aquariuslt\n    │           └── ita\n    ├── generated-sources\n    │   └── annotations\n    ├── generated-test-sources\n    │   └── test-annotations\n    └── test-classes\n        └── com\n            └── aquariuslt\n                └── ita\n\n41 directories, 28 files\n</code></pre><blockquote>\n<p><code>src</code>文件夹作为源代码目录\n<code>src-&gt;main-&gt;java</code>下的代码作为后台的代码\n<code>src-&gt;main-&gt;webapp</code>作为运行时web应用容器的配置,包含了前端的资源文件\n<code>pom.xml</code>作为项目的依赖管理,命名选项配置文件\n<code>target</code>文件夹则是通过maven构建命令编译构建出来的 输出目录</p>\n</blockquote>\n<h3 id=\"files-folders\">Files &amp; Folders</h3>\n<h4 id=\"package-json\">package.json</h4>\n<p>功能等同<code>pom.xml</code></p>\n<h4 id=\"src\">src</h4>\n<p>源代码文件夹.\n其中往下分可以分成前端模块和后端模块两个大部分\n为了方便分类,将它分成了<code>client</code>,<code>server</code>\n源代码的子层级命名方式为<code>module</code>-<code>mvc feature</code>-<code>submodule</code></p>\n<h4 id=\"gulp\">gulp</h4>\n<p>存放<code>GulpTask</code>的文件夹.\n子文件夹又分成<code>client</code>和<code>server</code>的tasks.\n至于使用Gulp来进行什么样的构建,在下一部分会说明</p>\n<h4 id=\"dist\">dist</h4>\n<p>构建出来的前端输出文件夹.类似于JavaWeb里面的target.\n但是仅限前端.\n这里存放的是经过打包后的前端资源.\n在整个应用启动的时候,将会扫描该文件夹,将其全部作为静态资源暴露出url.</p>\n<h2 id=\"gulptask\">GulpTask</h2>\n<h3 id=\"gulp\">Gulp</h3>\n<h4 id=\"what-is-gulp\">What is Gulp</h4>\n<p><a href=\"http://gulpjs.com/\">Gulp官方网站</a>\nGulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。</p>\n<h4 id=\"how-to-use\">How to Use</h4>\n<p>我使用gulp来干什么呢?\n单从前端运行的过程来说.我使用Gulp的Task进行下面一个流程.\n<img src=\"https://img.alicdn.com/tfscom/TB1DX9QLVXXXXXNaXXXXXXXXXXX.png\" alt=\"\"></p>\n<h3 id=\"build-flow\">Build Flow</h3>\n<p>为了达到最终的目的:单页应用输出最终的一个页面.</p>\n<pre><code class=\"undefinedhtml\">&lt;!DOCTYPE html&gt;\n&lt;html ng-app=&quot;home&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460&quot;&gt;\n    &lt;title&gt;Aquariuslt Home&lt;/title&gt;\n    &lt;link href=&quot;bundle.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;header ng-include=&quot;&#39;home/views/home.header.html&#39;&quot; class=&quot;navbar navbar-default navbar-fixed-top navbar-inner&quot;&gt;&lt;/header&gt;\n    &lt;div class=&quot;page-header&quot;&gt;\n    &lt;/div&gt;\n    &lt;div ui-view&gt;&lt;/div&gt;\n    &lt;script src=&quot;bundle.min.js&quot;&gt;&lt;/script&gt;\n    &lt;footer ng-include=&quot;&#39;home/views/home.footer.html&#39;&quot; class=&quot;footer&quot;&gt;&lt;/footer&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>我们需要怎么构建出这样一个页面呢?\n按照我的gulp tasks\n代码上是这样:</p>\n<pre><code class=\"undefinedjs\">//按照以下顺序运行task\nif (process.env.NODE_ENV==&#39;release&#39;) {\n    runSequence(\n      &#39;clean&#39;,\n      [&#39;index&#39;, &#39;styles&#39;, &#39;images&#39;, &#39;fonts&#39;, &#39;assets&#39;, &#39;templates&#39;],\n      //&#39;browserify&#39;,\n      &#39;webpack&#39;,\n      &#39;minify&#39;,\n      &#39;server&#39;\n    );\n  }\n</code></pre>\n<p>前面第一个clean只是清除dist文件夹的任务而已而已.</p>\n<p>一开始,<code>index.html</code>只是这样:</p>\n<pre><code class=\"undefinedhtml\">&lt;!DOCTYPE html&gt;\n&lt;html ng-app=&quot;home&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n    &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460&quot;&gt;\n    &lt;title&gt;Aquariuslt Home&lt;/title&gt;\n    &lt;!--styles--&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;header ng-include=&quot;&#39;home/views/home.header.html&#39;&quot; class=&quot;navbar navbar-default navbar-fixed-top navbar-inner&quot;&gt;&lt;/header&gt;\n    &lt;div class=&quot;page-header&quot;&gt;\n    &lt;/div&gt;\n    &lt;div ui-view&gt;&lt;/div&gt;\n    &lt;!--scripts--&gt;\n    &lt;footer ng-include=&quot;&#39;home/views/home.footer.html&#39;&quot; class=&quot;footer&quot;&gt;&lt;/footer&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"index\">index</h4>\n<p><code>index</code>这个task,主要功能是读取构建的一个配置文件<code>config.js</code>获取<code>index.html</code>的路径.\n紧接着比较傻逼的将html中的</p>\n<pre><code>&lt;!--styles--&gt;\n</code></pre><p>替换成</p>\n<pre><code>&lt;link href=&quot;bundle.min.css&quot; rel=&quot;stylesheet&quot;&gt;\n</code></pre><p>将</p>\n<pre><code>&lt;!--scripts--&gt;\n</code></pre><p>替换成</p>\n<pre><code>&lt;script src=&quot;bundle.min.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>虽然css,js还没有经过打包.但是先替换,存放在dist文件夹下.</p>\n<h4 id=\"styles\">styles</h4>\n<p>在配置文件<code>config.js</code>里面,需要维护一个css文件夹的正则路径.匹配到多个路径下的css位置供扫描.\ncss文件的路径大概是这样子的:</p>\n<pre><code>styles: [config.folder.src + &#39;/client/**/styles/*.css&#39;],\n</code></pre><p>即src文件夹下,匹配到client下的隔层文件夹里的所有叫<code>styles</code>的子文件夹下的所有css文件\n<code>styles</code>主要是\n将扫描出来的所有css文件打包在一起,融合成 刚刚替换成的<code>bundle.min.js</code></p>\n<h3 id=\"images-fonts-assets\">images,fonts,assets</h3>\n<p>这三个tasks功能类似.即也是读取配置文件所维护的一个匹配所有静态资源文件\n将其放到dist下对应的文件夹内.</p>\n<h3 id=\"templates\">templates</h3>\n<p>在配置文件<code>config.js</code>,控制将一个负责控制所有视图(views)的路径</p>\n<pre><code>templates: config.folder.src + &#39;/client/**/*.html&#39;,\n</code></pre><p><code>templates</code>这个tasks主要是扫描所有<code>.html</code>的视图文件,用于生成一些 <code>ngTempalte</code>供angular调用html模板\n其实最后这些生成的模板将会合并进js中.\n大概会变成下面这样:</p>\n<pre><code class=\"undefinedjs\">module.exports = angular.module(&quot;templates&quot;, []).run([&quot;$templateCache&quot;, function($templateCache) {\n$templateCache.put(&quot;index.html&quot;,&quot;&lt;!DOCTYPE html&gt;\\n&lt;html ng-app=\\&quot;home\\&quot;&gt;\\n  &lt;head&gt;\\n    &lt;meta charset=\\&quot;utf-8\\&quot;&gt;\\n    ...&quot;);\n$templateCache.put(&quot;home/views/home.about.html&quot;,&quot;&lt;div role=\\&quot;main\\&quot; class=\\&quot;container\\&quot;&gt;\\n  &lt;div class=\\&quot;row\\&quot;&gt;\\n    &lt;...&quot;);\n$templateCache.put(&quot;home/views/home.footer.html&quot;,&quot;&lt;div class=\\&quot;container\\&quot;&gt;\\n  &lt;div class=\\&quot;center-block\\&quot;&gt;\\n    &lt;h5&gt;B...&quot;);\n$templateCache.put(&quot;home/views/home.header.html&quot;,&quot;&lt;div class=\\&quot;container\\&quot; ng-controller=\\&quot;headerController\\&quot;&gt;\\n  &lt;div...&quot;);\n$templateCache.put(&quot;home/views/home.index.html&quot;,&quot;&lt;div class=\\&quot;container\\&quot;&gt;\\n  &lt;div class=\\&quot;jumbotron\\&quot;&gt;\\n    &lt;div clas...&quot;);\n}]);\n</code></pre>\n<h3 id=\"webpack-browserify\">webpack/browserify</h3>\n<p>这两个是现在主流的js打包工具.配合自身的一些插件.主要做到能够将以<code>requirejs</code>方式编的方式的代码.\n为了方便开发和调试,\n<code>webpack</code>和<code>browserify</code>都有一个热打包插件:过程都是监听所有js源代码的路径.当文件更新的时候,自动在打包一次.部署到运行的服务器上.</p>\n<h3 id=\"minify\">minify</h3>\n<p>这个以前叫做uglify,就是压缩js代码,变量名混淆.</p>\n"},{"link":"2015/12/27/site-upgrade-plan","title":"网站重构升级计划","published":"2015-12-27T08:32:39.000Z","tags":["Site","Blog","VPS","Node.js"],"html":"<h2 id=\"background\">Background</h2>\n<p>大三的时候,终于接触了第一个能够证实上线的网站项目.\n虽然那个项目最后的完成度不咋地,但是从头到尾从需求分析,代码编写,\n最后部署到正式服务器上一条龙的经验还是被我全吃掉了.</p>\n<p>有了掌控Web项目的部署运维的初级能力,所以我还是希望能够有一个自己的网站,自己亲手去维护.\n由于自己设计UI又太low,然后对CMS的能力还是掌控不够.\n所以,在购买了自己的VPS和域名之后,\n就一直使用<code>WordPress</code>作为博客应用.</p>\n<p>作为兴趣使然的Loser,收入不高.所以VPS一直都是购买的最低配.\n(单核,512M内存,20GSSD)</p>\n<p>本身这个配置去跑<code>WordPress</code>也是足够了.无奈将WP部署在阿里云的时候被攻击了好几次,导致经常瘫痪.\n后来迁移到DO上情况还好,但是还是经常出现了MySQL进程死掉,守护进程也没用的情况.\n一直觉得代码与资源都不在自己的掌握中比较苦难哦.\n数据迁移与备份还需要导出WP的配置与MySQL的数据,操作起来比较繁琐.</p>\n<blockquote>\n<p>更可能是因为我不懂高级的运维技巧)</p>\n</blockquote>\n<p>后来,<code>Github Pages</code>静态博客的方式作为流行的一种打包型的博客托管方式进入我的视野,\n也就是现在技术博客方面正在使用的方式.</p>\n<p>毕业工作之后,开始接触到一些<code>MEAN</code>的技术栈,打算用这方面的知识,去构建新的主站方式.</p>\n<h2 id=\"plan\">Plan</h2>\n<p>从目前的域名的管理情况来看,应该是打算 这样</p>\n<blockquote>\n<p>A域名<code>aquariuslt.com</code>作为导航主站,纯手工MEAN.\nCNAME<code>blog.aquariuslt.com</code>作为主要的博客站,放Post\nCNAME<code>debug.aquariuslt.com</code>作为主要的跌坑笔记手册\n-- CNAME<code>game.aquariuslt.com</code>作为我的(粗口)游戏哲学理论 --</p>\n</blockquote>\n<p><a href=\"http://aquariuslt.com\">主站</a>正在重建ing,已经可以访问\n目前使用的是<code>iptables</code>命令进行端口转发\n当然日后也可能考虑<code>httpd</code>转发or<code>nginx</code>.</p>\n<h2 id=\"source\">Source</h2>\n<p>所有代码都放在Github上.</p>\n<p>Home:<a href=\"https://github.com/Aquariuslt/Site-SourceCode\">https://github.com/Aquariuslt/Site-SourceCode</a>\nBlog<a href=\"https://github.com/Aquariuslt/Blog-SourceCode/\">https://github.com/Aquariuslt/Blog-SourceCode/</a>\nDebug<a href=\"https://github.com/Aquariuslt/Debug-SourceCode\">https://github.com/Aquariuslt/Debug-SourceCode</a></p>\n"},{"link":"2016/01/03/ubuntu-ldd-lib-linking-solutions","title":"Linux \"libxx cannot open shared object file no such file or directory\"解决方案","published":"2016-01-03T08:41:03.000Z","tags":["Linux","Ubuntu"],"html":"<blockquote>\n<p>This is a patch/enhancement about <a href=\"http://debug.aquariuslt.com/2015/12/14/libclntsh-so-11-1-cannot-open-shared-object-file/\">http://debug.aquariuslt.com/2015/12/14/libclntsh-so-11-1-cannot-open-shared-object-file/</a></p>\n</blockquote>\n<h2 id=\"description\">Description</h2>\n<p>I was install Ubuntu 15.10 for tasting the new version of Ubuntu.\nAfter setting up MEAN development and run node.js program.</p>\n<p>Node.js throw error belows:</p>\n<blockquote>\n<p>libaio.so cannot open shared object file no such file or directory</p>\n</blockquote>\n<p>I try to find this in oracle instant client directory, but there is no file named this in it.\nThen I power on the <code>Ubuntu 14.04</code> and type command</p>\n<pre><code>locate libaio.so\n</code></pre><p>It can be found in <code>/lib/x86_64_linux_gnu</code>\nBut not found in <code>UBuntu 15.10</code></p>\n<h2 id=\"rootcause\">RootCause</h2>\n<p>That&#39;s because <code>Ubuntu 15.10</code> use different gnu/g++ version from <code>Ubuntu 14.04</code>.</p>\n<h2 id=\"solution\">Solution</h2>\n<p>You can follow these steps to locate the root cause and solve it.</p>\n<ol>\n<li><p>Using command <code>locate {filename}</code> to search .so file.\nIf result is empty, you can try below;</p>\n</li>\n<li><p>Install the *.so file.\nUsing command</p>\n<pre><code>sudo apt-get install {filename without .so}\n</code></pre><p>or</p>\n</li>\n</ol>\n<p>If you found there is the same filename prefix but with version number,\nfor example,the error tips <code>libaio.so</code> not found, but you found there is  a file named <code>libaio.so.11.2</code> in <code>/lib/x86_64_linux_gnu</code>\nyou can make a softlink\nusing command</p>\n<pre><code>ln -s libaio.so.11.2 libaio.so\nsudo updatedb\n</code></pre>"},{"link":"2015/12/13/ubuntu-mean-development-environment-setup","title":"Linux Mean 开发环境搭建","published":"2015-12-13T07:27:48.000Z","tags":["Ubuntu","Linux","IntelliJ IDEA"],"html":"<h2 id=\"background\">Background</h2>\n<p>最近一个项目中需要用到<code>Redis</code>和Node.js操作OracleDB,而Windows下开发就是屁事多.\n恰好用到的这两个东西,都写明了官方不支持Windows,<code>Redis</code>在Widnows下的版本是由微软的工程师们在维护.\n在Windows下搭建好了环境之后,发现<code>Redis</code>在Windows下会有一些常见的崩溃情况,上网搜了下估计是Windows才会有的情况.\n本篇主要介绍在Linux(Ubuntu)下搭建MEAN Stack的相关内容,包括:</p>\n<ul>\n<li>Linux下<code>Redis</code>的安装与配置</li>\n<li>Ubuntu下<code>Node.js</code>与<code>MongoDB</code>安装与配置</li>\n<li>Linux下<code>oracledb</code>的安装与配置</li>\n<li>Ubuntu下<code>IntelliJ IDEA</code>的配置</li>\n</ul>\n<blockquote>\n<p>可能看起来有点奇怪,为什么我会<code>Linux</code>,<code>Ubuntu</code>这样穿插这顺序反过来写\n这是因为由于<code>Ubuntu</code>安装<code>Node.js</code>这方面我使用的是 <code>apt-get</code>来管理安装包\n而<code>oracledb</code>又是<code>Node.js</code>的一个类库</p>\n</blockquote>\n<h2 id=\"linux-redis-\">Linux下Redis的安装与配置</h2>\n<h3 id=\"-\">下载</h3>\n<p>从官方地址\n<a href=\"https://github.com/antirez/redis/archive/2.8.23.tar.gz\">https://github.com/antirez/redis/archive/2.8.23.tar.gz</a>\n下载.\n由于项目用到的Redis版本是2.8,所以下的是2.8版本.</p>\n<h3 id=\"-\">安装</h3>\n<p>将 redis2.8.23.tar.gz 解压到任意文件夹.</p>\n<blockquote>\n<p>目前按照个人习惯还是放在home下面一个叫server的目录\n但是unix系统的路径与程序摆放位置应该是大有讲究的,近期将会加强研究之后更新结论\n先凑合着放</p>\n</blockquote>\n<p>此时文件列表应该如下:</p>\n<pre><code>Macbook:redis-2.8.23 Aquariuslt$ tree -L 1\n.\n├── 00-RELEASENOTES\n├── BUGS\n├── CONTRIBUTING\n├── COPYING\n├── INSTALL\n├── MANIFESTO\n├── Makefile\n├── README\n├── deps\n├── redis.conf\n├── runtest\n├── runtest-sentinel\n├── sentinel.conf\n├── src\n├── tests\n└── utils\n\n4 directories, 12 files\n</code></pre><p>看到有<code>makefile</code>就知道需要自己编译一边,其实这里按照官网的Installation就可以.\n直接输入<code>make</code>编译</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.0.5.tar.gz\n$ tar xzf redis-3.0.5.tar.gz\n$ cd redis-3.0.5\n$ make\n</code></pre><h3 id=\"-\">以服务运行</h3>\n<p>在<code>Redis</code>安装目录下有一些脚本,执行之后,帮助以Service运行</p>\n<pre><code>\nIn order to install Redis binaries into /usr/local/bin just use:\n\n    % make install\n\nYou can use &quot;make PREFIX=/some/other/directory install&quot; if you wish to use a\ndifferent destination.\n\nMake install will just install binaries in your system, but will not configure\ninit scripts and configuration files in the appropriate place. This is not\nneeded if you want just to play a bit with Redis, but if you are installing\nit the proper way for a production system, we have a script doing this\nfor Ubuntu and Debian systems:\n\n    % cd utils\n    % ./install_server.sh\n\nThe script will ask you a few questions and will setup everything you need\nto run Redis properly as a background daemon that will start again on\nsystem reboots.\n\nYou&#39;ll be able to stop and start Redis using the script named\n/etc/init.d/redis_&lt;portnumber&gt;, for instance /etc/init.d/redis_6379.\n</code></pre><p>如果执行<code>make install</code>命令,则自动ln到<code>/usr/local/bin</code>\n如果执行<code>utils</code>路径下的<code>install_server.sh</code>则会添加启动项,开机自动运行.</p>\n<h2 id=\"ubuntu-node-js-mongodb-\">Ubuntu下Node.js与MongoDB的安装与配置</h2>\n<blockquote>\n<p>在Linux下<code>Node.js</code>的安装并不像<code>Windows</code>,<code>OS X</code>有.msi,.pkg 安装包走UI安装.\n但是在各个发行版的Linux下都有自己对应的包管理器.\n<code>Ubuntu</code>就有自己的包管理器<code>apt-get</code>(但是会有坑)</p>\n</blockquote>\n<p>Ubuntu 安装<code>Node.js</code>可以分成如下步骤</p>\n<ol>\n<li>更新包管理器的版本,使之能够获取最新版本的应用程序包</li>\n<li>通过包管理器,安装<code>Node.js</code></li>\n<li>通过<code>npm</code>再更新一次<code>Node.js</code></li>\n</ol>\n<h3 id=\"-ubuntu-\">更新Ubuntu的包管理器</h3>\n<pre><code>$apt-get update\n</code></pre><h3 id=\"-node-js\">通过包管理器安装Node.js</h3>\n<pre><code>$apt-get install nodejs-legacy\n</code></pre><p>通过此命令安装的是一个比较老版本的Node.js\n输入查看版本命令大概是 node v0.10 和 npm v1.14</p>\n<blockquote>\n<p>我也不知道为什么Ubuntu的package list 更新了之后 Node.js包版本还是那么低..\n下面更新的Node.js版本以2015-12-13官网的稳定版本为准</p>\n<pre><code>node -v &amp;&amp; npm -v\n</code></pre></blockquote>\n<p>这时候,首先先升级 <code>npm</code> 到 <code>npm3</code></p>\n<pre><code>$npm install -g npm\n</code></pre><blockquote>\n<p>此时npm的版本应该更新到v3.5.1+</p>\n</blockquote>\n<p>然后通过<code>npm</code>安装一个用<code>node</code>去切换<code>node</code>版本的库,叫做<code>n</code></p>\n<pre><code>$npm install -g n\n</code></pre><p>接着用<code>n</code>去安装所需版本的<code>node.js</code></p>\n<pre><code>$n v4.2.3\n</code></pre><p>重启电脑\n之后在查看<code>node</code>和<code>npm</code>版本,应该如下图\n<img src=\"https://img.alicdn.com/tfscom/TB1JHnGKVXXXXaFXVXXXXXXXXXX.png\" alt=\"更新Node.js\"></p>\n<h2 id=\"linux-node-oracledb-\">Linux下Node-OracleDB的配置</h2>\n<p>Linux 下搭建好node-oracledb 也是相当操蛋.\n大概需要做下面几个工作:</p>\n<ul>\n<li>下载 version &gt;= 11.2 的OracleInstantClient(basic&amp;sdk)</li>\n<li>设置环境变量,供构建npm install oracledb 构建使用</li>\n</ul>\n<h3 id=\"-oracleinstantclient-for-linux\">下载 OracleInstantClient for Linux</h3>\n<p>官网还要登陆下载,太过傻逼.所以放出了个某度的链接\n<a href=\"http://pan.baidu.com/s/1boxV2iV\">http://pan.baidu.com/s/1boxV2iV</a></p>\n<h3 id=\"-\">设置环境变量</h3>\n<p>先将下载的两个zip包解压到<code>/opt/oracle/instantclient</code>下.</p>\n<blockquote>\n<p>官方推荐,可自行替换路径</p>\n</blockquote>\n<p>然后修改全局的环境变量.</p>\n<blockquote>\n<p><strong>注意</strong> 这里说的是 <strong>全局变量</strong>,这里曾经被坑过一次.\n通过命令行的 <code>export PATH=XXX:PATH</code>之类的命令.只能作为临时变量,重启之后就会失效\n而Linux的环境变量,跟Windows类似,也分成全局的环境变量和当前用户的环境变量.\n在系统启动之后,先读取全局变量,用户登陆之后,再继承全局环境变量的前提下,读取当前用户的环境变量</p>\n</blockquote>\n<pre><code>$sudo gedit /etc/profile\n</code></pre><p>在底部添加如下内容</p>\n<pre><code># Export Oracle Client Varirable\nexport OCI_LIB_DIR=/opt/oracle/instantclient\nexport OCI_INC_DIR=/OPT/oracle/instantclient\nexport ORACLE_HOME=$OCI_LIB_DIR\nexport LD_LIBRARY_PATH=/opt/oracle/instantclient:$LD_LIBRARY_PATH\n</code></pre><p><img src=\"https://img.alicdn.com/tfscom/TB1PA2SKVXXXXX2XpXXXXXXXXXX.png\" alt=\"添加Oracle Client 相关全局环境变量\"></p>\n<p>此时执行命令安装 <code>oracledb</code> 大概应该不会出问题了</p>\n<blockquote>\n<p>其实还有个小问题,<code>oracledb</code>得必须是1.3.0 以上的版本..不然爆的错我也无法入手解决</p>\n<pre><code>$npm install oracledb\n</code></pre></blockquote>\n<h2 id=\"ubuntu-intellij-idea-\">Ubuntu下IntelliJ IDEA的配置</h2>\n<p>终于到重头戏了.其实我就是想说这个\n在GNOME下安装Idea遵循下面几步</p>\n<ol>\n<li>安装JDK,设置JDK相关环境变量</li>\n<li>配置Idea在Ubuntu的启动图标</li>\n<li>一些关于Idea在Linux下与Widnows/Mac不同的特殊配置</li>\n</ol>\n<h3 id=\"-jdk\">安装JDK</h3>\n<p>从Oracle 官网下载Linux版本jdk,解压到<code>/usr/lib/jvm/jdk8</code>下.</p>\n<blockquote>\n<p>该路径也是个人喜好,官网推荐这么做就照做了\n因为Idea启动的时候需要检查 Java的安装.且是按照<code>IDEA_JDK</code>,\n<code>JDK_HOME</code>,<code>JAVA_HOME</code>的顺序来进行查找,只要其中之一存在且对应了JDK的路径即可</p>\n</blockquote>\n<p>所以,在系统中添加全局环境变量\n如下图</p>\n<pre><code>$sudo gedit /etc/profile\n</code></pre><p>在底部添加</p>\n<pre><code># Set JAVA_HOME fOR Maven/Idea Settings\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JDK_HOME=$JAVA_HOME\nexport IDEA_JDK=$JAVA_HOME\nexport PATH=$PATH:$JAVA_HOME/bin\n</code></pre><p>保存后,查看java版本</p>\n<pre><code>$java -version\n</code></pre><p><img src=\"https://img.alicdn.com/tfscom/TB10eYyKVXXXXc8aXXXXXXXXXXX.png\" alt=\"配置JDK路径\"></p>\n<h3 id=\"-idea-ubuntu-\">配置Idea在Ubuntu中的启动图标</h3>\n<p>默认情况下,通过Idea目录下的<code>/bin/idea.sh</code>即可启动IdeaUI\n但是为了能够显示Ubuntu的docker里面(左边那条任务栏,不知道叫什么东西,叫docker吧)</p>\n<p>需要在<code>/usr/share/applications</code>下新建一个<code>intellij-idea.desktop</code>\n加个配置文件</p>\n<blockquote>\n<p>我本地的Idea解压后的目录在<code>/home/dev/Applications/IntellijIdea15</code></p>\n</blockquote>\n<pre><code>[Desktop Entry]\nType=Application\nName=IntelliJ IDEA\nComment=The best Java and MEAN IDE\nIcon=/home/dev/Applications/IntellijIdea15/bin/idea.png\nExec=/home/dev/Applications/IntellijIdea15/bin/idea.sh\nTerminal=false\nCategories=Development;IDE;Java;\n</code></pre><p><img src=\"https://img.alicdn.com/tfscom/TB100DBKVXXXXbCaXXXXXXXXXXX.png\" alt=\"添加Ubuntu Applications启动图标\"></p>\n<h3 id=\"idea-ubuntu-\">Idea在Ubuntu下一些特殊的配置</h3>\n<blockquote>\n<p>虽然都是类Unix系统,Idea跟Mac在一些读取环境变量时候的做法不大一样.\n本质上其实还是我对他认识不够深,还找不到原因..以后找到会更新\nLiux下在<code>run configuration</code>里面添加新的<code>Node.js</code>脚本或者<code>shell</code>脚本的时候,有一些不一样的地方就是\n通过Ubuntu桌面启动Idea,会读不到用户级别的环境变量.\n所以有一在配置一些的脚本的时候,需要确保运行时的环境变量,查看方法</p>\n</blockquote>\n<p>在<code>Run Configurations</code>-&gt;<code>Environment Variables</code>-&gt;<code>Include Parents Variables</code>-&gt;<code>Show</code> 查看所有环境变量.\n如果没有,烦请自己加上,为求能达到与Terminal运行同样的结果.</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1ik2EKVXXXXaxaXXXXXXXXXXX.png\" alt=\"查看Run Configurations全局变量\"></p>\n"},{"link":"2015/12/30/vmware-ubuntu-expand-disk-space-using-gparted","title":"vmware下为Ubuntu扩容","published":"2015-12-30T15:40:11.000Z","tags":["Linux","vmware"],"html":"<h2 id=\"description\">Description</h2>\n<p>一时大意,本以为<code>vmware</code>下的虚拟机可以随便调整磁盘容量,于是在给有1T SSD的服务器建立<code>Ubuntu</code>虚拟机镜像的时候很傻比的只分了40G的最大容量.\n没想到开发环境用的DB日渐增长,磁盘空间竟然很快消耗殆尽.</p>\n<p>于是赶紧给通过<code>vmware</code>的虚拟机硬件设置给将最大磁盘空间升级到120G(依然很小气- -)</p>\n<p>突然想起 Linux 的磁盘挂载方式 不大一样.上网找了一些类似的解决方案之后,都发现不太好记.</p>\n<h2 id=\"solution\">Solution</h2>\n<p>通过<code>Ubuntu</code>下的一个GUI软件,叫<code>gparted</code>,能够图形化的类似Windows下的磁盘管理工具一样,进行磁盘空间的重新划分与转移.</p>\n<p>在本次使用<code>gparted</code>进行分区转移,大概分成以下几步:</p>\n<blockquote>\n<ol>\n<li>安装并运行<code>gparted</code></li>\n<li>删除<code>Ubuntu</code>下原本的extend分区及<code>linux swap</code>空间</li>\n<li>对原有磁盘空间进行扩容</li>\n<li>新建extend分区,建立<code>linux swap</code>空间</li>\n</ol>\n</blockquote>\n<h3 id=\"-gparted-\">安装并运行<code>gparted</code></h3>\n<pre><code class=\"undefinedsh\">$sudo apt-get install gparted\ngparted\n</code></pre>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1s16KLXXXXXXVXpXXXXXXXXXX.png\" alt=\"gparted界面\"></p>\n<h3 id=\"-ubuntu-extend-linux-swap-\">删除<code>Ubuntu</code>下原本的extend分区及<code>linux swap</code>空间</h3>\n<blockquote>\n<p>这里提及一下之前有的错误做法\n我一开始的做法是,直接给未格式化的空间,格式化之后,作为一个新的磁盘挂载在系统中\n这样,需要对 /media/${username}/新空间名称 进行一个链接\n才能达到扩容的目的.\n感觉这样相当不优雅.像是乱插了N个奇形怪状的U盘在身上</p>\n</blockquote>\n<p>研究后发现,<code>Linux</code>的Swap空间阻断了分区扩容,在磁盘起始点和终点上不连续.\n所以先右键<code>File System</code>为<code>extend</code>的分区,删除之</p>\n<h3 id=\"-\">对原有磁盘空间进行扩容</h3>\n<p>删除<code>extend</code>的空间之后,便可以对原有的<code>/dev/sda1</code>进行扩容.\n此时右键<code>/dev/sda1</code>选择<code>resize</code>,在保证预留出大小相当于分配给虚拟机的内存的空间的情况下,分多点~\n点击<code>apply</code>生效</p>\n<h3 id=\"-extend-linux-swap-\">新建extend分区,建立<code>linux swap</code>空间</h3>\n<p>最后,重新建立<code>linux swap</code>空间.\n对着还未分配的空间,新增一个<code>file system</code>为<code>extended</code>的扩展分区,<code>apply</code>之.\n然后在该分区下新建一个<code>linux-swap</code>空间.</p>\n<p><img src=\"https://img.alicdn.com/tfscom/TB1HPTxLXXXXXXoXVXXXXXXXXXX.png\" alt=\"扩容后截图\"></p>\n"},{"link":"2015/02/20/vps-from-aliyun-to-digitalocean","title":"VPS从阿里云迁移到Digital Ocean","published":"2015-02-19T19:51:53.000Z","tags":["VPS"],"html":"<p>最近发现阿里云主机哪边老发生数据库连接错误，经查看原来是内存不够了，随着阿里云自己的升级 乱给我装那些AliYunDun的进程和服务\n导致我mysqld进程因为内存不够而被自动关闭。\n后来发现的问题是 通过回滚快照的办法 重启主机 也有很大几率导致mysql.sock无法正常启动\n看来是启动Linux的时候 随系统初始化启动的进程太多 导致内存不够了</p>\n<p>本来想用Linode的，但是发现好像暂时没必要用这么好的 其实是因为没钱\n于是去买了个Digital Ocean的账号 下个月准备停掉阿里云</p>\n<p>回家由于是垃圾的移动/铁通宽带 ping 到位于纽约的VPS 延迟比较大，开头还担心访问延迟也比较大呢\n后来发现还是挺流畅的</p>\n<p>迁移了一晚上WordPress的数据 还有一些插件不能备份过来但是后面就算了吧 再慢慢搞</p>\n"},{"link":"2016/04/26/what-i-have-done-these-days","title":"What I have done these days","published":"2016-04-26T14:30:39.000Z","tags":["Diary"],"html":"<h2 id=\"buging-in-day-coding-at-night\">Buging in day,Coding at night</h2>\n<p>白天写bug,晚上写代码.\n开玩笑,这段日子忙了了好几个地方.\n思绪都没挺得下来.</p>\n<h3 id=\"hadoop-training-sharing\">Hadoop Training &amp; Sharing</h3>\n<h4 id=\"training-background\">Training Background</h4>\n<p>之前是公司安排了一个为期两天的Hadoop Training.\n请了中科院的一个老师给参加培训的同事讲讲概念性的东西.\n大概课程的内容就是<code>Hadoop</code>+<code>Hadoop平台体系</code>+<code>Hadoop衍生工具</code>.</p>\n<p>讲完之后依然不知其所以然.\n但是对大数据的实际应用场景已经有了比较深刻的印象:</p>\n<ul>\n<li><strong>选型决策</strong>(其实主要理解还是这边)</li>\n<li><strong>传统行业改造</strong></li>\n<li><strong>促进信息消费</strong></li>\n</ul>\n<h4 id=\"episode\">Episode</h4>\n<p>有句讲句,大数据的数据挖掘方向让我感到神秘而有一丝厌恶.<br>有时候在想,是不是搞大数据的人都这么喜欢装逼,卖弄.<br>源自于我的大学班主任吕威.除了是我班主任,另一个身份是中大数据挖掘方向的研究生导师.  </p>\n<p>他在本科的教学上看不出有任何的为师之道.(至少对我们这种学校).<br>曾教我们的离散数学+数据结构与算法.<br>一周两节课80分钟,套路都是固定的  </p>\n<ul>\n<li>前10分钟,讲大数据很火,他读书的时候就是这个专业的,他很牛逼.  </li>\n<li>10-20分钟,讲数据挖掘很牛逼,他和他的学生跟中移动合作项目,水平相当高.  </li>\n<li>后10分钟,讲他的同学很牛逼,已经年入百万级别,但是让他跟他一起打拼,他又说自己处于安逸.  </li>\n<li>剩下的讲PPT.不讲算法实质,演示全靠PPT(不过PPT做的不错,跟AMD有的一拼)  </li>\n<li>听到大数据这么火,不禁想深入了解一下,每当学生问出这个问题的时候,他的回答总是走向(&#39;你只用知道我很牛逼+数据挖掘很牛逼,过程你就不必知道了,说了也不懂.&#39;)</li>\n</ul>\n<p>至于为什么要指名道姓的点草他,也无所谓了.<br>是大学生涯中少有的能全线让我评E的老师.  </p>\n<p>吐槽完毕.  </p>\n<h4 id=\"sharing\">Sharing</h4>\n<p>在接收培训完之后,回到Team里面必然需要分享一些学到的知识.<br>不仅如此还需要给ITA的同事两周内介绍+一些实战分享.<br>我的任务是分享HBase.<br>对于没有在项目中经过实战经验的我来说,这个难度不低.<br>在搭建环境中又看到了大数据平台的这些东西在部署,配置方面的一些套路,最后总结出一些有干货非假大空的分享,<br>倒是花费了挺多经历.  </p>\n<h3 id=\"project-platform-migration\">Project Platform Migration</h3>\n<h4 id=\"background\">Background</h4>\n<p>从去年年底开始项目转移过来之后,就开始全职接手该项目的开发任务.<br>由于这个是公司开始的比较早的实验性MEAN项目,项目代码/结构虽有很多可取之处,但是槽点更多.  </p>\n<p>在用户数量逐渐增多,对可用性和稳定性的要求日渐增高的时候,项目的定位自然要从实验性项目升级到常规项目中.<br>于是展开了HA(High Availability,高可用性)计划.  </p>\n<h4 id=\"solution\">Solution</h4>\n<p>HA计划分成下面几步来执行:  </p>\n<p><strong>硬件方面</strong></p>\n<ul>\n<li>数据库MongoDB部分迁移到MongoDB集群上.</li>\n<li>项目部署方式迁移到Docker上,实现扩展性高的水平扩容.</li>\n<li>Redis单节点升级成Redis多节点.</li>\n</ul>\n<p><strong>业务代码方面</strong></p>\n<ul>\n<li>前端UI的性能优化</li>\n<li>统一项目之间的日志规则</li>\n</ul>\n<h4 id=\"challenge-and-difficult\">Challenge and Difficult</h4>\n<p>如果原先的代码架构标准,框架良好,单节点 &lt;-&gt; 多节点 之间的切换实际上并不需要深层的代码级别改动.<br>但是之前说过代码的槽点比较多,而且没有一个正确的编码习惯.导致我们在增加节点的时候,遭遇了很多挑战.<br>(这其有一部分感觉也是JavaScript的锅,这点大喷子王垠其实有喷过,某些方面还是要&quot;苟同&quot;)</p>\n<p>暂列出几点,感觉这些挑战和中间曲折的解决方案,即使抽去业务逻辑,也可以通过多几个篇幅来详细描述.<br>嗯.这里就不一一细诉了:</p>\n<ul>\n<li>数据访问层(Node.js)由单节点转变成多节点,UI展示层的Server端也转变成了多节点,加上新的生产环境中加多了一些防火墙,导致请求转发次数较多,不能顺利追踪.  </li>\n<li>由于新的生产环境的代理和规律规则问题,前端的WebSocket无法维持与服务端的长连接(网上常见方案是修改Nginx配置,但是我们生产环境的代理是购买的第三方网络分配服务)</li>\n<li>由于硬件的变化,Redis,socket.io,redis-socket.io 等JS库原先都在比较旧的版本.阅读过版本更变记录之后决定升级到新的库版本,但是出现了严重的连接错误.  </li>\n<li><p>静态的数据文件迁移到专门的文件服务器,需要大量的DataPatch与合理的迁移方案  </p>\n</li>\n<li><p>由于一些历史的业务逻辑需求原因,需要在前端加载出所有数据.但是接手之前的代码并没有做一些常规的优化方案(分页,优化页面DOM节点数,减少Listener).开始着手优化,期望与硬件上的迁移升级同步带来更好的用户体验.</p>\n</li>\n</ul>\n<p>其中有一些坑在迁移测试的时候没有跌出来,导致第一次更换生产环境之后,系统不稳定,发生了几次故障,事态紧急性升高,时间都花在着手解决稳定性问题(网络配置,代码缺陷)上.</p>\n<p>整个团队在紧张加班加点定位问题之后,发现问题根源不止一个,只能一个一个去制定解决方案.  </p>\n<p>最后一个一个定位了已出现的问题,目前系统得以恢复稳定.HA的硬件部分暂告一段落,前端UI性能优化是我主要负责的部分,由于页面比较多,还需要提供一个合理的网页性能测试基准来比较优化前后的对比\n这部分也是花了相当多的时间去阅读一些Angular性能优化最佳实践,做各种尝试.等等.</p>\n<p>目前从已进行性能优化的两个页面来说,性能提升目测相当明显.<br>主要的优化手段一个是将错误的Angular写法转变到正确的标准写法上,(其实就是先擦干净屁股).<br>经过上面这种手段,前端的UI性能提升已经非常明显.至少限制了页面DOM和Listener的上限,不因数据量而线性增长压力.<br>第二个才是在遵循规范的写法上更改UI操作的内部逻辑,寻求更高细粒度的优化.  </p>\n<h3 id=\"site-sourcecode-refactor\">Site SourceCode Refactor</h3>\n<h4 id=\"background\">Background</h4>\n<p>加班加多了自然在下班时间尽量不惦记一些技术问题.<br>恰逢前端看到了Angular2 Beta版本的发布,便有想法通过重写主站代码,边学习Angular2,边学习Angular2官方推荐的TypeScript.\n在着手做了几个Demo之后,发现两个问题,导致我对Angular2目前的版本暂时失去兴趣,还开始拒绝使用TypeScript.</p>\n<ol>\n<li>Beta版本的Angular2开发体验特差.\n在Angular1版本中,在html中手动加入<code>ng-app</code>的标记,即可当成是Angular Bootstrap,自启动的一个入口.</li>\n</ol>\n<p>目前在Angular2中,加载了Angular2本身代码是远远不够的,因为他的bootstrap需要另外一个引路人的角色来帮忙启动.\n即需要<code>Angular2</code>编写业务代码+引入<code>ES6,RxJS,SystemJS</code>,最终通过<code>System.import</code>+<code>Angular2</code>的入口文件才得以启动整个应用.<br>所以说开发体验很差.</p>\n<ol>\n<li>TypeScript 所吹嘘的语言特性都是鸡肋.\n第二个情况就是虽然可以通过原生JS的方式编写Angular2代码,但是由于开发Angular2本身就是通过TypeScript写的.<br>那么从最好的情况便是遵循官方推荐学习TypeScript.<br>从官方吹的特性来看,TypeScript的出现主要是为了解决JavaScript的几类问题:<br>我就不忍了直接边说边喷我的观点吧  </li>\n<li><p>弱类型-&gt;强类型.<br>TypeScript是强类型的语言,虽然转译之后会变成弱类型的原生JavaScript代码,但是TypeScript本身就需要依赖IDE的提示进行静态类型检查,以提示错误.<br>这就相当不必要了,有了Jetbrains系列产品,遵循ESLint/JSHint提示与蝴蝶书的规范,IDE本身就会简单的对JS代码进行浅层次的类型推导(更常见的方式是通过\nJavaScript的注释文档中,限定参数的类型).<br>都依赖IDE,为了调试代码的时候,还得可以通过<code>source map</code>再定位一次出问题的TypeScript代码.<br>这不是自己找事吗.</p>\n</li>\n<li><p>依赖tsd文件自动提示方法\n为了实现OO概念,TypeScript添加了interface的概念,其中这些interface,接口定义文件存储在<code>.tsd</code>文件当中.<br>然后IDE会预先读取定义好的tsd文件,当编写一个实现了该接口的实现类(或者新建一个对象的时候)便会根据<code>.tsd</code>进行方法自动提示.<br>然后TypeScript吹的另外一个特点就是:可以与原生JavaScript混合使用.  </p>\n</li>\n</ol>\n<p>这跟口音不正的二打六演员去出演TVB然后夹着不纯正的广东话一样,吃了苍蝇的恶心.\n然后去找了一下常见的JavaScript库的tsd,因为这些tsd文件软狗官方怎么会帮大家做维护呢?<br><code>lodash</code>的tsd文件我愣是没找到.那些个人维护的名不见经传的小众lib就不必多说了.\n在开始系统化的大型JS项目之前,需要对用到的第三方lib进行仔细的阅读,然后编写一份tsd文件,只是为了在用TypeScript的时候获得接口化编程的体验.<br>看来他们都不知道有IDEA.</p>\n<p>无可否认.TypeScript的初衷和他的作者实力都相当强.但是强并不代表做出来的东西不成为一坨屎,也不必要赶着去吃它.  </p>\n<p>然后我就放弃了TypeScript,对Angular2的原生版本还是持观望状态.  </p>\n<h4 id=\"using-angular-material\">Using Angular-Material</h4>\n<p>刚又不小心吐槽多了几个地方.\n言归正传,重写主站代码的原因是一方面是想试试使用<code>Material Design</code>.\n另外一方面是子站写日志的时候使用的是<code>Hexo</code>,一个类似Markdown的开源博客框架.<br>在编写的时候通过Markdown的格式撰写日志内容,唯一恶心的就是他的header.</p>\n<p>要求如下:</p>\n<pre><code>title: Hadoop 2.7.2 单节点与集群安装部署\ndate: 2016-04-09 13:09:51\ntags:\n  - Hadoop\n  - Linux\n---\n</code></pre><p>这么说的话,使用IDEA的预览在即时预览中显示出来的效果就太难看了.<br>于是我决定在从写的时候使用自定义的Markdown渲染器,自己定义一个可读性和渲染出来不难看的header.<br>然后借助<code>marked</code>生成html.  </p>\n<p>为此还添加了一个小Feature:Online Markdown Editor<br><a href=\"http://aquariuslt.com/#/features/md-editor\">Markdown Editor</a><br>支持已经被我抛弃的<code>Hexo</code>,<code>TOC标记</code>,<code>非严格模式</code>.  </p>\n<p>花了挺多时间去写的.<br>具体内容感觉觉得再开一个篇幅去讲.  </p>\n<h2 id=\"an-other-graduation-season\">An other Graduation season</h2>\n<p>有时候晚上醒来,我还以为我是一名学生.\n昨天站在台上大合照的是我.</p>\n<p>若然现时士气高昂<br>即管放肆任性<br>当你感到无力软弱<br>切记不怪宿命<br>若然做人未算聪明<br>更要卖力亡命<br>还未要负责之际 切记尽兴<br>谁亦会随年变老<br>方懂得童年多好<br>等不到来年变老<br>才怀念 那种悠然脚步<br>来吧趁毫无控诉<br>快释穿沿途的污糟<br>这段少年时间 既然昂贵<br>大好青春要尽耗<br>记住要共最美的人分享每个夜晚<br>别忘掉原是靠坚持医好每个伤患<br>既是有力挺起胸膛即管好好作反<br>无惧雨水沾湿两眼<br>无用听谁来劝告<br>一街的人言滔滔<br>不需坐下来计数<br>前行吧 你想做 全意做<br>如没有无穷气数<br>也可跟神明赌一铺<br>这段少年时间 有谁无悔<br>大好青春要消耗<br>记住要共最美的人分享每个夜晚<br>别忘掉原是靠坚持医好每个伤患<br>记住趁尚有些本钱签多一些帐单<br>如若你还淘气 你还强壮<br>尽管出走别折返<br>无需定立时限 如风一般往返<br>人未老 还未晚<br>还未到尽头记住来放心荒旦<br>若生命是无限 何必自定界限<br>大好青春就要多贪<br>记住要共最美的人分享每个夜晚<br>别忘掉原是靠坚持医好每个伤患<br>记住趁尚有些本钱签多一些帐单<br>如若你还淘气 你还强壮<br>尽管出走别折返<br>记住每日尽兴欢腾通宵至到达旦<br>别忘掉原是以单纯体恤每个灾难<br>既是有力挺起胸膛即管好好作反<br>无惧雨水沾湿两眼 年月灿烂    </p>\n"},{"link":"2016/06/01/wow-movie","title":"Warcraft","published":"2016-05-31T16:00:00.000Z","tags":["WoW","Diary"],"html":"<h2 id=\"warcraft-movie\">Warcraft Movie</h2>\n<p>作为11年的骨灰WoWer,本来期待是和战友们一起去看的.\n首映IMAX票太难买了,当两个星期前打开猫眼的时候,剩下的都不是看电影的位置.\n最后没想到是跟同事去看的.  </p>\n<p>在电影开始之前,发现预售率破纪录,我想抛弃情怀粉,大部分都是盲流吧.心里也做好了烂片预警.<br>结果发现这一部至少做工上表现还是挺有诚意的.  </p>\n<p>电影中场景的还原度相当高,跟WoW里面的场景表现一致.<br>暴风城,铁炉堡,艾尔文森林(这个就不是飞过而已),前诅咒之地(黑暗之门所在地)\n卡拉赞.</p>\n<p>但是电影里面还是有一些地方跟历史小说有些出入,譬如最后迦罗娜杀死莱恩国王的那段.\n正史应该是应该是&quot;由于麦迪文的控制,迦罗娜在混战中刺杀了莱恩&quot;,\n电影却煽情的变成了莱恩发现自己可能单挑不过被邪能腐蚀的黑手,将杀死自己的荣耀希望送给迦罗娜,从而打开兽人合作的桥梁.  </p>\n<h2 id=\"durotan-bust\">Durotan Bust</h2>\n<p>买爆米花可乐套餐只能选这个胸像,好丑啊.<br><img src=\"https://img.alicdn.com/tfscom/TB1jiGrKpXXXXciaXXXXXXXXXXX.jpg\" alt=\"杜隆坦胸像\"></p>\n"},{"link":"2015/05/31/wp-hexo-image-robot","title":"Word Press迁移Hexo附加工具","published":"2015-05-31T02:33:51.000Z","tags":["Blog","Hexo","Node.js"],"html":"<h1 id=\"wp-hexo-imagerobot\">WP-HEXO-ImageRobot</h1>\n<p>一个帮助从WordPress转移到Hexo博客过程中，下载原WordPress的图片到本地然后替换到Hexo的markdown文件中的链接的工具。</p>\n<h2 id=\"background\">Background</h2>\n<p>之前的WordPress博客文章迁移到Hexo博客的过程中，大概的步骤是这样的</p>\n<ol>\n<li>从WordPress仪表盘中导出所有文章与图片到xml文件中</li>\n<li>使用 ![][(<a href=\"https://github.com/hexojs/hexo-migrator-wordpress\">https://github.com/hexojs/hexo-migrator-wordpress</a>)] 的迁移工具生成source基本文件</li>\n</ol>\n<p>但是缺点就是 文章中 img的src地址往往还是不变的。 这对于使用WordPress主机，且把图片放在WordPress主机上的博客迁移非常不友好。 因为一旦你将Hexo博客绑定到你的域名的时候，原来原来的图片链接将会失效。 这个工具帮你自动把生成的source中_post文件夹下的所有md文件中的图片链接下载下来，并且替换到md文件中。 重新生成Hexo博客之后，所有的图片都指向了本地文件，迁移得更完美</p>\n<h2 id=\"usage\">Usage</h2>\n<p>编译之后 传入一个参数</p>\n<pre><code>/Users/Aquariuslt/Code/HEXO/source/`\n</code></pre><p>即可</p>\n"}];